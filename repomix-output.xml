This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: */old-working/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
AGENTS.md
package.json
public/common.js
public/index.html
public/join.html
public/streamer.html
public/styles.css
README.md
src/config.ts
src/room.ts
src/worker.ts
wrangler.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AGENTS.md">
# Repository Guidelines

This project is a minimal Cloudflare Worker + Durable Objects backend with static client files for a “Streamer vs. Chat Zombies” arena. Use this guide to navigate, develop, and contribute efficiently.

## Project Structure & Module Organization
- `src/worker.ts` — Worker entry (routes `/create`, `/ws/:room`).
- `src/room.ts` — Durable Object logic and game loop.
- `public/` — Static client: `streamer.html`, `join.html`, `common.js`, `styles.css`.
- `wrangler.toml` — Worker config, DO binding, migrations, assets.
- `README.md` — Run and deploy notes.

## Build, Test, and Development Commands
- `npx wrangler dev` — Run local dev server with DO and assets.
- `npx wrangler deploy` — Deploy to Cloudflare.
- Optional: `npm i -D wrangler` then `wrangler dev/deploy` via PATH.

## Coding Style & Naming Conventions
- Language: TypeScript for Worker/DO; plain JS/HTML/CSS for `public`.
- Indentation: 2 spaces; keep lines concise and explicit.
- Naming: TypeScript uses `camelCase` for vars/functions, `PascalCase` for classes (e.g., `RoomDO`). Static files use kebab-case (e.g., `streamer.html`).
- Imports: prefer relative module paths within `src`.
- Keep Worker code side-effect–free on import; initialize within handlers/constructors.

## Testing Guidelines
- No formal test harness included. Validate via `wrangler dev` and manual flows:
  - Open `http://127.0.0.1:8787/streamer.html` ? Create Room.
  - Join with `public/join.html?room=XXXXXX` in another tab.
- If adding tests, colocate under `src/__tests__/` and use a lightweight runner (e.g., `vitest`) without changing runtime behavior.

## Commit & Pull Request Guidelines
- Commits: concise imperative subject, scoped changes (e.g., `room: cap zombies at 100`).
- PRs: include purpose, screenshots/GIFs for UI changes, and steps to validate with `wrangler dev`. Link related issues and note any config changes in `wrangler.toml`.

## Security & Configuration Tips
- `wrangler.toml` contains `ROOMS` Durable Object binding and `TARKOV_NAMES` sample names. Add secrets via `wrangler secret put NAME` (do not commit secrets).
- Expose only `/create` and `/ws/*` from the Worker; serve `public/` via Pages or Worker assets.
- Sanitize/validate inputs in `room.ts`; keep server authoritative state and tick rate conservative.

## Architecture Overview
- Worker handles HTTP routes and WebSocket upgrades; a Room Durable Object instance owns room state and broadcasts at ~20Hz. Static pages connect to `/ws/:room` and render client controls.
</file>

<file path="package.json">
{
  "devDependencies": {
    "wrangler": "^4.35.0"
  }
}
</file>

<file path="README.md">
# Cloudflare Arena Shooter (Streamer vs. Chat Zombies)

Ultra-minimal top-down arena where the **streamer** moves fast and shoots; **chat** joins via a link and plays slow **zombies**. Built on **Cloudflare Workers + Durable Objects** with raw **WebSockets**. Static HTML served by Pages (or any static host).

## Features
- Rooms keyed by URL (e.g. `/ws/abcd12`) with one DO instance per room.
- Streamer: WASD + mouse aim + click to shoot.
- Chat: WASD movement as slow zombies; on touch, streamer loses 1 score.
- Server-authoritative positions; 20Hz snapshots.

## Run locally
```bash
npm create cloudflare@latest . # or `npm i -D wrangler`
wrangler dev
```
Open `http://127.0.0.1:8787/streamer.html` and click **Create Room**. Share the generated `join.html?room=XXXXXX` link.

> If serving static files from another host (e.g. Pages), ensure the Worker is reachable at the same domain (or adjust `public/*.html` to point to your Worker origin).

## Deploy
1. `wrangler deploy`
2. Host `/public` with Cloudflare Pages **or** serve them elsewhere.
3. Point your domain routes to the Worker (`/ws/*`, `/create`).

## Notes
- This is intentionally minimal: no authentication, no persistence beyond DO lifetime.
- For cost/scale, consider Durable Object WebSocket hibernation and backoff reconnects.
- Security: names are sanitized; inputs are rate-limited implicitly by tick; add explicit token bucket if you expect abuse.

## Customize
- Speeds, radii, arena size in `src/room.ts`.
- Add scoreboard UI, streamer-only control panel, zombie cosmetics, etc.
</file>

<file path="wrangler.toml">
name = "arena-shooter"
main = "src/worker.ts"
compatibility_date = "2024-10-22"

[[durable_objects.bindings]]
name = "ROOMS"
class_name = "RoomDO"

[vars]
TARKOV_NAMES = "KibaRogue,WoodsScav,ShorelineRat,FactoryGhost,LabsRunner,InterchangeChad,DormsGoblin,ReserveMole,FleaFlipper,TetrizHoarder,LedXHunter,SlickSeeker,RSASSEnjoyer,M995Enjoyer,GrenadierGoon,SanitarStan,KillaChaser,TagillaTapper,GluharGuy,ShturmanScout,KnightWatcher,RogueRaider,USECFriend,BEARBuddy,JaegerPal,FenceFella,TherapistAlly,RagmanRigger,SkierSlinger,PraporPatron,MechanicMain,PeacekeeperPro,LabsRat,MarkedRoomMole,StashGremlin,MoonshineMax,ScavJunkie,OmComEnjoyer,SJ6Sprinter,AltynAddict,ThermalAndy,GreenBatteryGuy,DormsKeyKing,GPUGoblin,AmmoArbiter,WaffleFilter"

[assets]
directory = "public"

[[migrations]]
tag = "v1"
new_sqlite_classes = ["RoomDO"]
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Cloudflare Workers
.wrangler/
worker/
dist/

# Environment variables
.env
.env.local
.env.production
.env.staging

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# Build outputs
build/
dist/
out/

# Temporary folders
tmp/
temp/
old-working/

# Cache
.cache/
.parcel-cache/

# Lock files (keep package-lock.json but ignore others)
yarn.lock
pnpm-lock.yaml
</file>

<file path="src/config.ts">
export type GameConfig = {
  arena: { width: number; height: number };
  ticks: { mainMs: number; pickupMs: number };
  round: { durationMs: number };
  speeds: { streamer: number; zombie: number; zombieBoostMultiplier: number; zombieSlowMultiplier: number };
  streamer: { maxHp: number };
  combat: { zombieTouchDamage: number; knockbackStep: number; respawnMs: number };
  weapons: {
    damage: { pistol: number; smg: number; shotgun: number; melee: number };
    cooldownMs: { pistol: { base: number; boosted: number }; smg: { base: number; boosted: number }; shotgun: { base: number; boosted: number } };
    projectile: { pistol: { speed: number; ttl: number }; smg: { speed: number; ttl: number }; shotgun: { speed: number; ttl: number; pellets: number } };
    ammo: { initial: { pistol: number; smg: number; shotgun: number }; pickupGain: { pistol: number; smg: number; shotgun: number }; max: { pistol: number; smg: number; shotgun: number } };
  };
  melee: { cooldownMs: number; reach: number; arcRad: number };
  dash: { cooldownMs: number; durationMs: number; speedMultiplier: number };
  pickups: {
    spawnIntervalMs: number;
    totalCap: number;
    minDistance: number;
    caps: Record<string, number>;
    treasureScore: number;
    blastRadius: number;
  };
  effects: { weaponBoostMs: number; shieldMs: number; magnetMs: number; zombieBoostMs: number; freezeMs: number };
  extraction: { radius: number; countMin: number; countMax: number; minActiveMs: number; maxActiveMs: number };
  radii: { streamer: number; zombie: number; bulletMargin: number };
  zombies: {
    baseHp: number;
    weights: { runner: number; brute: number; spitter: number };
    speedMul: { runner: number; brute: number; spitter: number };
    hpMul: { runner: number; brute: number; spitter: number };
    detectionRange: { runner: number; brute: number; spitter: number };
    chaseRange: { runner: number; brute: number; spitter: number };
    brute: { extraKnockbackMul: number };
    spitter: { cooldownMsMin: number; cooldownMsMax: number; manualCooldownMs: number; projectileSpeed: number; projectileTtl: number; hitDamage: number; slowMs: number; streamerSlowMul: number; range: number };
    runnerAbility: { cooldownMs: number; durationMs: number };
    bruteAbility: { cooldownMs: number; durationMs: number; speed: number };
  };
  aiZombies: {
    maxCount: number;
    spawnCooldownMs: number;
    dropChance: number;
    ammoDropChance: number;
    treasureDropChance: number;
    treasureValues: Record<string, number>;
    treasureDropRates: Record<string, number>;
  };
  tiles: { size: number; theme: "dungeon" | "cave" | "lab" };
};

export const CONFIG: GameConfig = {
  arena: { width: 7200, height: 4050 },
  ticks: { mainMs: 50, pickupMs: 500 },
  round: { durationMs: 5 * 60 * 1000 },
  speeds: { streamer: 175, zombie: 65, zombieBoostMultiplier: 1.75, zombieSlowMultiplier: 0.55 },
  streamer: { maxHp: 100 },
  combat: { zombieTouchDamage: 10, knockbackStep: 12, respawnMs: 800 },
  weapons: {
    damage: {
      pistol: 100,
      smg: 100,
      shotgun: 100, // Per pellet
      melee: 100,
    },
    cooldownMs: {
      pistol: { base: 320, boosted: 200 },
      smg: { base: 90, boosted: 60 },
      shotgun: { base: 800, boosted: 550 },
    },
    projectile: {
      pistol: { speed: 360, ttl: 1200 },
      smg: { speed: 340, ttl: 900 },
      shotgun: { speed: 300, ttl: 600, pellets: 6 },
    },
    ammo: {
      initial: { pistol: 60, smg: 120, shotgun: 24 },
      pickupGain: { pistol: 15, smg: 30, shotgun: 6 },
      max: { pistol: 120, smg: 240, shotgun: 48 },
    },
  },
  melee: { cooldownMs: 500, reach: 28, arcRad: Math.PI / 1.8 },
  dash: { cooldownMs: 1000, durationMs: 180, speedMultiplier: 3.5 },
  pickups: {
    spawnIntervalMs: 12000,
    totalCap: 12,
    minDistance: 48,
    caps: { health: 3, speed: 3, ammo: 3, weapon: 2, shield: 2, magnet: 2, freeze: 1, blast: 2, treasure: 3, key: 1 },
    treasureScore: 3,
    blastRadius: 90,
  },
  effects: { weaponBoostMs: 8000, shieldMs: 6000, magnetMs: 8000, zombieBoostMs: 7000, freezeMs: 6000 },
  extraction: { radius: 28, countMin: 1, countMax: 2, minActiveMs: 60_000, maxActiveMs: 90_000 },
  radii: { streamer: 10, zombie: 12, bulletMargin: 2 },
  zombies: {
    baseHp: 100,
    weights: { runner: 6, brute: 2, spitter: 2 },
    speedMul: { runner: 2.5, brute: 0.5, spitter: 1.5 },
    hpMul: { runner: 1.5, brute: 5, spitter: 2 },
    detectionRange: { runner: 300, brute: 300, spitter: 300 },
    chaseRange: { runner: 180, brute: 150, spitter: 200 },
    brute: { extraKnockbackMul: 1.4 },
    spitter: { cooldownMsMin: 1800, cooldownMsMax: 3000, manualCooldownMs: 900, projectileSpeed: 160, projectileTtl: 1800, hitDamage: 6, slowMs: 1600, streamerSlowMul: 0.65, range: 360 },
    runnerAbility: { cooldownMs: 1200, durationMs: 280 },
    bruteAbility: { cooldownMs: 1600, durationMs: 320, speed: 240 },
  },
  aiZombies: {
    maxCount: 30,
    spawnCooldownMs: 5000,
    dropChance: 0.45, // overall chance that ANY drop happens at all
    ammoDropChance: 0.5, // chance of ammo drop (if drop happens)
    treasureDropChance: 0.3, // chance of treasure drop (if drop happens)
    treasureValues: {
      coin: 10,
      gem: 25,
      crystal: 50,
      orb: 75,
      relic: 100,
      artifact: 150,
      medallion: 250,
      scroll: 400,
      crown: 1000
    },
    treasureDropRates: {
      coin: 0.25,        // Common (25%)
      gem: 0.20,         // Common (20%)
      crystal: 0.15,     // Uncommon (15%)
      orb: 0.13,         // Uncommon (13%)
      relic: 0.11,       // Rare (11%)
      artifact: 0.08,    // Rare (8%)
      medallion: 0.05,   // Epic (5%)
      scroll: 0.02,      // Epic (2%)
      crown: 0.01        // Legendary (1%)
    }
  },
  tiles: { size: 24, theme: "dungeon" },
};

export type TileId = 0 | 1 | 2 | 3 | 4 | 5; // floor, wall, pit, water, doorClosed, doorOpen
</file>

<file path="src/worker.ts">
import { RoomDO } from "./room";

export interface Env {
  ROOMS: DurableObjectNamespace;
  TARKOV_NAMES: string;
}

declare global {
  interface DurableObjectNamespace {
    idFromName(name: string): DurableObjectId;
    get(id: DurableObjectId): DurableObjectStub;
  }
  
  interface DurableObjectId {}
  
  interface DurableObjectStub {
    fetch(request: Request): Promise<Response>;
  }
}

export default {
  async fetch(req: Request, env: Env) {
    const url = new URL(req.url);

    // Return current default config (for UI/editor)
    if (url.pathname === "/config" && req.method === "GET") {
      // Lazy import to avoid side-effects on module load
      const { CONFIG } = await import("./config");
      return new Response(JSON.stringify(CONFIG), { headers: { "content-type": "application/json" } });
    }

    // WebSocket upgrade routed to the Room Durable Object
    if (url.pathname.startsWith("/ws/") && req.headers.get("Upgrade") === "websocket") {
      const roomId = url.pathname.split("/").pop()!;
      const id = env.ROOMS.idFromName(roomId);
      const stub = env.ROOMS.get(id);
      return stub.fetch(req);
    }

    // Mint a new room id with regional hint
    if (url.pathname === "/create" && req.method === "POST") {
      let overrides: any = undefined;
      try {
        const ct = req.headers.get('content-type') || '';
        if (ct.includes('application/json')) {
          const body = await req.json().catch(() => ({}));
          if (body && typeof body === 'object') overrides = body.overrides || body.config || undefined;
        }
      } catch {}

      const region = getRegionFromRequest(req);
      const roomId = `${region}-${crypto.randomUUID().slice(0, 6)}`;

      // If overrides provided, initialize the DO instance with them before returning
      if (overrides && typeof overrides === 'object') {
        try {
          const id = env.ROOMS.idFromName(roomId);
          const stub = env.ROOMS.get(id);
          await stub.fetch(new Request(`https://do/${roomId}/setup`, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ overrides })
          }));
        } catch {}
      }
      return new Response(JSON.stringify({ roomId }), { headers: { "content-type": "application/json" } });
    }

    // Simple health
    if (url.pathname === "/health") return new Response("ok");

    return new Response("Not found", { status: 404 });
  },
};

// Required for binding discovery in some setups
// Get region hint from CF headers or fallback
function getRegionFromRequest(req: Request): string {
  // Cloudflare provides colo (data center) in CF-Ray header
  const cfRay = req.headers.get('CF-Ray');
  if (cfRay) {
    const colo = cfRay.split('-')[1];
    if (colo) {
      // Map some common colos to regions
      const regionMap: Record<string, string> = {
        'LAX': 'us-west', 'SFO': 'us-west', 'SEA': 'us-west',
        'DFW': 'us-central', 'ORD': 'us-central', 'ATL': 'us-central',
        'IAD': 'us-east', 'EWR': 'us-east', 'MIA': 'us-east',
        'LHR': 'eu-west', 'CDG': 'eu-west', 'AMS': 'eu-west',
        'FRA': 'eu-central', 'WAW': 'eu-central',
        'NRT': 'asia-east', 'ICN': 'asia-east', 'HKG': 'asia-east',
        'SIN': 'asia-south', 'BOM': 'asia-south'
      };
      return regionMap[colo] || 'global';
    }
  }
  
  // Fallback to CF-IPCountry header
  const country = req.headers.get('CF-IPCountry');
  if (country) {
    const countryToRegion: Record<string, string> = {
      'US': 'us-central', 'CA': 'us-central',
      'GB': 'eu-west', 'DE': 'eu-central', 'FR': 'eu-west', 'NL': 'eu-west',
      'JP': 'asia-east', 'KR': 'asia-east', 'CN': 'asia-east',
      'SG': 'asia-south', 'IN': 'asia-south', 'AU': 'asia-south'
    };
    return countryToRegion[country] || 'global';
  }
  
  return 'global';
}

export { RoomDO };
</file>

<file path="public/index.html">
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Streamer vs. Chat — Zombies</title>
  <link rel="stylesheet" href="/styles.css" />
  <style>
    .hero {
      position: relative;
      min-height: 100dvh;
      display: grid; place-items: center;
      overflow: hidden;
    }
    .hero-inner { text-align: center; padding: 100px 20px 60px; }
    .title {
      font-weight: 800; font-size: clamp(28px, 6vw, 56px);
      letter-spacing: .5px;
      background: linear-gradient(90deg, #fff, #a5b4fc 35%, #99f6e4 70%);
      -webkit-background-clip: text; background-clip: text; color: transparent;
      text-shadow: 0 10px 40px rgba(0,0,0,.45);
    }
    .subtitle { color: var(--muted); margin-top: 10px; max-width: 900px; margin-inline: auto; }
    .cta { margin-top: 26px; display: inline-flex; gap: 10px; flex-wrap: wrap; }
    .cta a { text-decoration: none; }
    .btn-xl { padding: 14px 18px; font-size: 16px; border-radius: 14px; border: 1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.08)); box-shadow: 0 12px 30px rgba(0,0,0,.35); }
    .btn-xl.primary { color: var(--teal); border-color: color-mix(in oklab, var(--teal) 35%, transparent); }
    .btn-xl.secondary { color: #c3c7d1; }

    /* Floating blobs */
    .blob {
      position: absolute; width: 60vmax; height: 60vmax; border-radius: 50%; filter: blur(60px); opacity: .22; pointer-events: none;
      background: radial-gradient(circle at 40% 40%, rgba(45,212,191,.6), transparent 55%);
      animation: drift 24s ease-in-out infinite alternate;
    }
    .blob.b2 { background: radial-gradient(circle at 60% 60%, rgba(244,114,182,.6), transparent 55%); animation-duration: 28s; animation-delay: -4s; }
    .blob.b3 { background: radial-gradient(circle at 50% 50%, rgba(96,165,250,.6), transparent 55%); animation-duration: 30s; animation-delay: -8s; }
    @keyframes drift { from { transform: translate(-10%, -10%) scale(1); } to { transform: translate(10%, 10%) scale(1.08); } }

    /* Cards row with subtle entrance */
    .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; padding: 24px; max-width: 1100px; margin: 0 auto 40px; }
    .card.hero-card { opacity: 0; transform: translateY(10px); animation: rise .6s ease forwards; }
    .card.hero-card:nth-child(2) { animation-delay: .08s; }
    .card.hero-card:nth-child(3) { animation-delay: .16s; }
    @keyframes rise { to { opacity: 1; transform: translateY(0); } }
    /* Modal */
    .modal { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,.55); z-index: 50; }
    .modal.hidden { display: none; }
    .modal .sheet { width: min(720px, 92vw); background: linear-gradient(180deg, var(--panel), var(--panel-2)); border: 1px solid var(--border); border-radius: 16px; padding: 16px; box-shadow: 0 20px 60px rgba(0,0,0,.5); }
    .modal .sheet .hd { display:flex; align-items:center; justify-content:space-between; font-weight:600; color: var(--text); margin-bottom: 8px; }
    .modal .sheet .bd { color: var(--muted); }
    .modal .sheet .ft { display:flex; gap:8px; justify-content:flex-end; margin-top: 12px; }
    /* Down chevron at bottom of hero */
    .down-cta {
      position: absolute; left: 50%; bottom: 18px; transform: translateX(-50%);
      width: 44px; height: 44px; border-radius: 999px;
      display: grid; place-items: center;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.12));
      color: var(--text);
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
      cursor: pointer; transition: transform .15s ease, box-shadow .2s ease, border-color .2s ease;
      animation: bob 2.4s ease-in-out infinite;
    }
    .down-cta:hover { border-color: rgba(255,255,255,.2); box-shadow: 0 12px 34px rgba(0,0,0,.45), 0 0 0 4px rgba(158,241,209,.08); }
    .down-cta:active { transform: translateX(-50%) translateY(1px); }
    .down-cta svg { width: 20px; height: 20px; opacity: .9; }
    @keyframes bob { 0%,100%{ transform: translateX(-50%) translateY(0); } 50%{ transform: translateX(-50%) translateY(4px); } }
  </style>
  <script type="module">
    // Tiny confetti bursts on load that loop at random, firing from random sides/angles
    window.addEventListener('load', () => {
      const container = document.createElement('div');
      container.style.position = 'fixed';
      container.style.inset = '0';
      container.style.pointerEvents = 'none';
      container.style.overflow = 'hidden';
      document.body.appendChild(container);

      const colors = ['#60a5fa','#f472b6','#2dd4bf','#ffd54f'];
      const parts = [];

      function spawnBurst(count=50){
        // Random origin: top, bottom, left, right, or center
        const side = ['top','bottom','left','right','center'][Math.floor(Math.random()*5)];
        const w = window.innerWidth; const h = window.innerHeight;
        let ox = w/2, oy = h/2;
        if (side==='top')    { ox = Math.random()*w; oy = -20; }
        if (side==='bottom') { ox = Math.random()*w; oy = h+20; }
        if (side==='left')   { ox = -20; oy = Math.random()*h; }
        if (side==='right')  { ox = w+20; oy = Math.random()*h; }

        for (let i=0;i<count;i++){
          const el = document.createElement('div');
          el.style.position = 'absolute';
          el.style.width = '6px'; el.style.height = '10px'; el.style.borderRadius = '2px';
          el.style.left = ox + 'px'; el.style.top = oy + 'px';
          el.style.background = colors[i % colors.length];
          el.style.opacity = '.95';
          el.style.transform = `rotate(${Math.random()*360}deg)`;
          container.appendChild(el);
          // Random direction and speed
          const ang = Math.random()*Math.PI*2; // 0..2PI any direction
          const spd = 2 + Math.random()*4;     // pixels/frame (scaled later)
          const vx = Math.cos(ang)*spd;
          const vy = Math.sin(ang)*spd;
          const vr = (Math.random()-.5)*6;     // deg/frame
          parts.push({ el, x: ox, y: oy, vx, vy, r: Math.random()*360, vr, life: 120 + Math.random()*80 });
        }
      }

      let last = performance.now();
      function step(now){
        const dt = Math.min(32, now - last) / 16.6; // normalize to ~60fps steps
        last = now;
        for (let i = parts.length-1; i>=0; i--) {
          const p = parts[i];
          // simple drag and gravity-ish drift
          p.vx *= 0.995; p.vy = p.vy*0.995 + 0.06;
          p.x += p.vx * dt; p.y += p.vy * dt; p.r += p.vr * dt; p.life -= dt;
          p.el.style.left = p.x + 'px'; p.el.style.top = p.y + 'px'; p.el.style.transform = `rotate(${p.r}deg)`;
          // Cull when off-screen or out of life
          if (p.life <= 0 || p.x < -60 || p.x > window.innerWidth+60 || p.y < -80 || p.y > window.innerHeight+80) {
            p.el.remove(); parts.splice(i,1);
          }
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);

      // Kick off initial burst and then loop random bursts
      spawnBurst(60);
      function loop(){
        spawnBurst(40 + Math.floor(Math.random()*40));
        // Next burst between 3–8 seconds
        setTimeout(loop, 3000 + Math.random()*5000);
      }
      setTimeout(loop, 1800 + Math.random()*1200);
    });

    // Role selection modal
    const showRoleModal = async (role) => {
      const modal = document.getElementById('roleModal');
      const title = document.getElementById('roleTitle');
      const body = document.getElementById('roleBody');
      const play = document.getElementById('rolePlay');
      const cancel = document.getElementById('roleCancel');
      const isStreamer = role === 'streamer';
      title.textContent = isStreamer ? 'Play as Streamer' : 'Join as Zombie';
      // Streamer body with inline advanced config editor
      const streamerBody = `
        <div style="line-height:1.8">
          <div><strong>Move:</strong> WASD · <strong>Aim:</strong> Mouse · <strong>Shoot:</strong> Left‑click</div>
          <div><strong>Melee (bat):</strong> Right‑click or Q/E</div>
          <div><strong>Weapons:</strong> 1=Pistol · 2=SMG · 3=Shotgun</div>
          <div><strong>Dash:</strong> Space (1s CD) — brief burst</div>
          <div><strong>Scoring:</strong> Treasure adds <em>Score</em>. Dying clears current score.</div>
        </div>
        <details style="margin-top:10px">
          <summary style="cursor:pointer">Advanced: Edit Room Config (JSON)</summary>
          <div class="row" style="margin-top:8px">
            <textarea id="configEditor" class="mono" style="width:100%; height:220px"></textarea>
          </div>
          <div class="tip">Edit only what you need. Invalid JSON will be ignored.</div>
        </details>`;
      const zombieBody = `
        <div style="line-height:1.8">
          <div><strong>Move:</strong> WASD · <strong>Aim:</strong> Mouse · <strong>Ability:</strong> Left‑click</div>
          <div style="margin-top:6px"><strong>Classes:</strong></div>
          <div>• <span style=\"color:#64b5f6\">Runner</span>: Sprint burst on click (1.6× speed, 0.6× HP)</div>
          <div>• <span style=\"color:#ffa726\">Brute</span>: Charge toward cursor on click (0.7× speed, 2× HP, strong knockback)</div>
          <div>• <span style=\"color:#ba68c8\">Spitter</span>: Spit slow glob on click (damage + slow); also auto‑spits in range</div>
          <div style=\"margin-top:6px\">Touch the streamer to deal damage; coordinate to pin and overwhelm.</div>
        </div>`;
      body.innerHTML = isStreamer ? streamerBody : zombieBody;
      // Preload default config JSON if streamer
      if (isStreamer) {
        try {
          const res = await fetch('/config');
          if (res.ok) {
            const cfg = await res.json();
            const ed = document.getElementById('configEditor');
            if (ed) ed.value = JSON.stringify(cfg, null, 2);
          }
        } catch {}
      }
      play.onclick = async () => {
        if (isStreamer) {
          // Create room with optional overrides
          let overrides = undefined;
          const ed = document.getElementById('configEditor');
          if (ed && ed.value.trim()) {
            try { overrides = JSON.parse(ed.value); } catch { overrides = undefined; }
          }
          try {
            const res = await fetch('/create', { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify({ overrides }) });
            const data = await res.json();
            if (data && data.roomId) { window.location.href = `/streamer.html?room=${encodeURIComponent(data.roomId)}`; return; }
          } catch {}
          // Fallback
          window.location.href = '/streamer.html';
        } else {
          window.location.href = '/join.html';
        }
      };
      cancel.onclick = () => { modal.classList.add('hidden'); };
      modal.classList.remove('hidden');
    };

    document.addEventListener('click', (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      if (t.matches('#ctaStreamer')) { e.preventDefault(); showRoleModal('streamer'); }
      if (t.matches('#ctaZombie')) { e.preventDefault(); showRoleModal('zombie'); }
    });

    // Smooth scroll to How To Play
    const scrollBtn = document.getElementById('scrollDown');
    const howto = document.getElementById('howto');
    if (scrollBtn && howto) {
      scrollBtn.addEventListener('click', () => {
        try { howto.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        catch { window.scrollTo({ top: howto.getBoundingClientRect().top + window.scrollY - 12, behavior: 'smooth' }); }
      });
    }
  </script>
</head>
<body>
  <div class="topbar">
    <div class="brand">Streamer vs. Chat</div>
    <div class="middle-controls">
      <span class="badge" id="status" data-state="disconnected">Welcome</span>
    </div>
    <div class="right-controls">
      <button class="primary" id="ctaStreamer">Streamer</button>
      <button id="ctaZombie">Join</button>
    </div>
  </div>
  <div class="hero">
    <div class="blob b1"></div>
    <div class="blob b2"></div>
    <div class="blob b3"></div>
    <div class="hero-inner">
      <div class="title">Streamer vs. Chat — Zombies</div>
      <div class="subtitle">A fast, top‑down arena: One streamer, many zombies. Loot treasure, survive the horde, and rack up a high score.</div>
      <div class="cta">
        <button class="btn-xl primary" id="ctaStreamer">Play as Streamer</button>
        <button class="btn-xl secondary" id="ctaZombie">Join as Zombie</button>
      </div>
    </div>
    <button id="scrollDown" class="down-cta" aria-label="Scroll to How To Play">
      <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    <div class="cards">
      <div class="card hero-card"><div class="card-title">20Hz Server</div><div class="tip">Authoritative sim with fair hits and clean rollback for inputs.</div></div>
      <div class="card hero-card"><div class="card-title">Relentless Pressure</div><div class="tip">Loot treasure to raise your score while dodging the swarm.</div></div>
      <div class="card hero-card"><div class="card-title">Chat vs. You</div><div class="tip">Hundreds of slow zombies, simple inputs, and satisfying chaos.</div></div>
    </div>
  </div>

  <div id="howto" class="cards" style="max-width:1100px; margin:0 auto 60px;">
    <div class="card hero-card">
      <div class="card-title">How To Play — Streamer</div>
      <div class="tip" style="line-height:1.7">
        <div><strong>Move:</strong> WASD · <strong>Aim:</strong> Mouse · <strong>Shoot:</strong> Left‑click</div>
        <div><strong>Melee (bat):</strong> Right‑click or Q/E · short arc</div>
        <div><strong>Weapons:</strong> 1=Pistol · 2=SMG · 3=Shotgun</div>
          <div><strong>Dash:</strong> Space (1s CD) · brief burst</div>
          <div><strong>Scoring:</strong> Treasure adds <em>Score</em>. Dying clears unbanked points.</div>
      </div>
    </div>
    <div class="card hero-card">
      <div class="card-title">How To Play — Zombie</div>
      <div class="tip" style="line-height:1.7">
        <div><strong>Move:</strong> WASD · <strong>Aim:</strong> Mouse</div>
        <div><strong>Ability (all classes):</strong> Left‑click</div>
        <div style="margin-top:6px"><strong>Classes:</strong></div>
        <div>• <span style="color:#64b5f6">Runner</span>: 1.6× speed, 0.6× HP. Left‑click = short sprint burst.</div>
        <div>• <span style="color:#ffa726">Brute</span>: 0.7× speed, 2× HP. Left‑click = charge toward cursor (strong knockback on hit).</div>
        <div>• <span style="color:#ba68c8">Spitter</span>: normal speed/HP. Left‑click = spit a slow purple glob (damage + slow). Also spits automatically in range.</div>
        <div style="margin-top:6px">Touching the streamer deals damage; coordinate to pin and overwhelm.</div>
      </div>
    </div>
  </div>

  <div class="cards" style="max-width:1100px; margin:0 auto 80px; grid-template-columns: 1fr;">
    <div class="card hero-card">
      <div class="card-title">Legend & Tips</div>
      <div class="tip" style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
        <div>
          <div><strong>Flow:</strong> Treasure increases score. Dying resets current score.</div>
          <div><strong>Minimap:</strong> Bottom‑right, zoomed to your position.</div>
        </div>
        <div>
          <div style="margin-bottom:4px"><strong>Zombie Class Rings:</strong></div>
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px"><span style="width:12px;height:12px;border-radius:999px;border:2px solid #64b5f6;display:inline-block"></span> Runner</div>
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px"><span style="width:12px;height:12px;border-radius:999px;border:3px solid #ffa726;display:inline-block"></span> Brute</div>
          <div style="display:flex; align-items:center; gap:8px"><span style="width:12px;height:12px;border-radius:999px;border:2px solid #ba68c8;display:inline-block"></span> Spitter</div>
        </div>
      </div>
    </div>
  </div>


  <!-- Role selection modal -->
  <div id="roleModal" class="modal hidden">
    <div class="sheet">
      <div class="hd"><span id="roleTitle">Play</span></div>
      <div class="bd" id="roleBody"></div>
      <div class="ft">
        <button id="roleCancel">Back</button>
        <button id="rolePlay" class="primary">Play</button>
      </div>
    </div>
  </div>
</body>
</html>
</file>

<file path="public/common.js">
export function connect(roomId) {
  let url;
  if (typeof window !== 'undefined' && window.WORKER_ORIGIN) {
    try {
      const u = new URL(`/ws/${roomId}`, window.WORKER_ORIGIN);
      u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
      url = u.href;
    } catch {
      // Fallback to same-origin if WORKER_ORIGIN is malformed
    }
  }
  if (!url) {
    const proto = location.protocol === "https:" ? "wss" : "ws";
    url = `${proto}://${location.host}/ws/${roomId}`;
  }
  return new WebSocket(url);
}

export function nameStorage() {
  return {
    get() { return localStorage.getItem("name") || ""; },
    set(n) { localStorage.setItem("name", n); }
  };
}

export function minimalCanvas(w, h) {
  const c = document.createElement("canvas");
  c.className = "arena";

  let stage = document.querySelector('.stage');
  if (!stage) { stage = document.createElement('div'); stage.className = 'stage'; document.body.appendChild(stage); }
  stage.appendChild(c);
  const ctx = c.getContext("2d");

  // DPI-aware internal resolution
  const resize = () => {
    // Fit canvas to parent (stage) while maintaining aspect ratio and avoiding overflow
    const parent = c.parentElement || document.body;
    const prect = parent.getBoundingClientRect();
    const targetAR = w / h;
    let cssW = prect.width;
    let cssH = cssW / targetAR;
    if (cssH > prect.height) {
      cssH = prect.height;
      cssW = cssH * targetAR;
    }
    c.style.width = cssW + 'px';
    c.style.height = cssH + 'px';

    const rect = c.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const targetW = Math.max(1, Math.floor(rect.width * dpr));
    const targetH = Math.max(1, Math.floor(rect.height * dpr));
    if (c.width !== targetW || c.height !== targetH) {
      c.width = targetW; c.height = targetH;
    }
  };
  const roCanvas = new ResizeObserver(() => resize());
  const roParent = new ResizeObserver(() => resize());
  roCanvas.observe(c);
  roParent.observe(stage);
  window.addEventListener('orientationchange', resize);
  resize();

  // Capture keyboard focus so Space/Arrows don't trigger buttons/scroll
  c.tabIndex = 0;
  setTimeout(() => c.focus(), 0);
  c.addEventListener('pointerdown', () => c.focus());
  return { c, ctx };
}

export function inputController(opts={ mouse:true }) {
  const state = { up:false,down:false,left:false,right:false,shoot:false,melee:false,dash:false,aimX:0,aimY:0 };
  addEventListener("keydown", e => { if (e.repeat) return; if (e.key==="w"||e.key==="ArrowUp") state.up=true;
    if (e.key==="s"||e.key==="ArrowDown") state.down=true; if (e.key==="a"||e.key==="ArrowLeft") state.left=true; if (e.key==="d"||e.key==="ArrowRight") state.right=true; if (e.key==="q"||e.key==="e") state.melee=true; if (e.code==="Space") state.dash=true; });
  addEventListener("keyup", e => { if (e.key==="w"||e.key==="ArrowUp") state.up=false;
    if (e.key==="s"||e.key==="ArrowDown") state.down=false; if (e.key==="a"||e.key==="ArrowLeft") state.left=false; if (e.key==="d"||e.key==="ArrowRight") state.right=false; if (e.key==="q"||e.key==="e") state.melee=false; if (e.code==="Space") state.dash=false; });
  if (opts.mouse) {
    addEventListener("mousemove", e => { const rect = document.querySelector("canvas.arena").getBoundingClientRect(); state.aimX = e.clientX - rect.left; state.aimY = e.clientY - rect.top; });
    // Pointer/mouse shooting handling
    addEventListener("mousedown", (e) => { if (e.button===0) state.shoot = true; if (e.button===2) { state.melee = true; e.preventDefault(); } });
    addEventListener("mouseup", (e) => { if (e.button===0) state.shoot = false; if (e.button===2) { state.melee = false; e.preventDefault(); } });
    // prevent context menu on canvas for right-click melee
    document.addEventListener('contextmenu', (e) => {
      const c = document.querySelector('canvas.arena');
      if (c && c.contains(e.target)) e.preventDefault();
    });
    // Touch support (basic)
    addEventListener("touchstart", (e) => { const t=e.touches[0]; const rect = document.querySelector("canvas.arena").getBoundingClientRect(); state.aimX=t.clientX-rect.left; state.aimY=t.clientY-rect.top; state.shoot=true; }, { passive:true });
    addEventListener("touchend", () => { state.shoot=false; }, { passive:true });
  }
  const resetAll = () => { state.up=false; state.down=false; state.left=false; state.right=false; state.shoot=false; state.melee=false; state.dash=false; };
  addEventListener("blur", () => { resetAll(); });
  document.addEventListener("visibilitychange", () => { if (document.hidden) resetAll(); });
  return state;
}

// Prevent browser defaults (scrolling / button activation) for game keys
export function suppressPageHotkeys() {
  window.addEventListener('keydown', (e) => {
    const code = e.code;
    const isGameKey = code === 'Space' || code === 'ArrowUp' || code === 'ArrowDown' || code === 'ArrowLeft' || code === 'ArrowRight' || e.key === ' ';
    const tag = (document.activeElement && document.activeElement.tagName) || '';
    const typing = tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (document.activeElement && document.activeElement.getAttribute && document.activeElement.getAttribute('contenteditable') === 'true');
    if (isGameKey && !typing) {
      e.preventDefault();
    }
  }, { capture: true });
}

// Client-side prediction for movement
export function createPredictionSystem() {
  let predictedPos = { x: 0, y: 0 };
  let lastServerPos = { x: 0, y: 0 };
  let lastServerTime = 0;
  let inputHistory = [];
  
  return {
    // Predict movement locally
    predictMovement(input, dt) {
      const speed = 200; // pixels per second
      const dx = (input.right ? 1 : 0) - (input.left ? 1 : 0);
      const dy = (input.down ? 1 : 0) - (input.up ? 1 : 0);
      
      // Normalize diagonal movement
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len > 0) {
        predictedPos.x += (dx / len) * speed * dt;
        predictedPos.y += (dy / len) * speed * dt;
      }
      
      // Store input for reconciliation
      inputHistory.push({
        input: { ...input },
        timestamp: performance.now(),
        predictedPos: { ...predictedPos }
      });
      
      // Keep only recent history (1 second)
      const cutoff = performance.now() - 1000;
      inputHistory = inputHistory.filter(h => h.timestamp > cutoff);
      
      return { ...predictedPos };
    },
    
    // Reconcile with server state
    reconcile(serverPos, serverTime) {
      lastServerPos = { ...serverPos };
      lastServerTime = serverTime;
      
      // Find inputs that happened after server state
      const replayInputs = inputHistory.filter(h => h.timestamp > serverTime);
      
      // Reset to server position and replay inputs
      predictedPos = { ...serverPos };
      for (const h of replayInputs) {
        const dt = 0.05; // Assume 50ms intervals
        const speed = 200;
        const dx = (h.input.right ? 1 : 0) - (h.input.left ? 1 : 0);
        const dy = (h.input.down ? 1 : 0) - (h.input.up ? 1 : 0);
        
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
          predictedPos.x += (dx / len) * speed * dt;
          predictedPos.y += (dy / len) * speed * dt;
        }
      }
      
      return { ...predictedPos };
    },
    
    getCurrentPos() {
      return { ...predictedPos };
    },
    
    setPos(pos) {
      predictedPos = { ...pos };
    }
  };
}

// Connection quality monitoring
export function createLatencyMonitor(ws) {
  let pingHistory = [];
  let lastPingTime = 0;
  
  return {
    sendPing() {
      const now = performance.now();
      lastPingTime = now;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'ping', timestamp: now }));
      }
    },
    
    handlePong(serverTimestamp) {
      const now = performance.now();
      const rtt = now - serverTimestamp;
      pingHistory.push({ rtt, timestamp: now });
      
      // Keep only recent pings (30 seconds)
      const cutoff = now - 30000;
      pingHistory = pingHistory.filter(p => p.timestamp > cutoff);
      
      return rtt;
    },
    
    getAverageLatency() {
      if (pingHistory.length === 0) return 0;
      const sum = pingHistory.reduce((acc, p) => acc + p.rtt, 0);
      return sum / pingHistory.length;
    },
    
    getLatencyStats() {
      if (pingHistory.length === 0) return { avg: 0, min: 0, max: 0, jitter: 0 };
      
      const rtts = pingHistory.map(p => p.rtt);
      const avg = rtts.reduce((a, b) => a + b) / rtts.length;
      const min = Math.min(...rtts);
      const max = Math.max(...rtts);
      
      // Calculate jitter (standard deviation)
      const variance = rtts.reduce((acc, rtt) => acc + Math.pow(rtt - avg, 2), 0) / rtts.length;
      const jitter = Math.sqrt(variance);
      
      return { avg, min, max, jitter };
    }
  };
}

// Minimal toast helper
export function toast(msg, ms=5000) { // time = 5000ms = 5s
  let t = document.querySelector('.toast');
  if (!t) { t = document.createElement('div'); t.className='toast'; document.body.appendChild(t); }
  t.textContent = msg; t.classList.add('show');
  clearTimeout(t._hide);
  t._hide = setTimeout(()=>t.classList.remove('show'), ms);
}
</file>

<file path="public/styles.css">
:root {
  color-scheme: dark;
  --bg: #0a0b0f;
  --bg-2: #0b0c10;
  --panel: #121418;
  --panel-2: #161920;
  --border: #252a33;
  --muted: #98a2b3;
  --text: #e7eaee;

  /* Accent palette */
  --green: #4caf50;
  --red: #ef5350;
  --blue: #60a5fa;
  --amber: #ffd54f;
  --orange: #ffa726;
  --teal: #2dd4bf;
  --pink: #f472b6;

  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
}

* { box-sizing: border-box; }
html, body { height: 100dvh; }
body {
  margin: 0;
  min-height: 100dvh;
  background:
    radial-gradient(1200px 600px at 20% -10%, rgba(45,212,191,.12), transparent 60%),
    radial-gradient(1000px 600px at 110% 10%, rgba(244,114,182,.10), transparent 60%),
    linear-gradient(180deg, var(--bg) 0%, #090a0e 65%, #08090c 100%);
  color: var(--text);
  letter-spacing: .2px;
}

/* ——— Topbar ——— */
.topbar {
  position: fixed;
  inset: 0 0 auto 0;
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: 12px;
  align-items: center;
  padding: 10px 14px;
  background:
    linear-gradient(180deg, rgba(12,14,18,.75), rgba(12,14,18,.45) 60%, rgba(12,14,18,0));
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(255,255,255,.04);
  z-index: 10;
}
.brand {
  font-weight: 700;
  font-size: 15px;
  letter-spacing: .3px;
  background: linear-gradient(90deg, #fff, #9db2ff 40%, #9ef1d1 80%);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  opacity: .9;
}
.middle-controls { display: flex; gap: 8px; align-items: center; justify-content: center; flex-wrap: wrap; }
.right-controls { display: flex; gap: 8px; align-items: center; }

/* ——— App Layout ——— */
.app {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 300px;
  gap: 16px;
  padding: 72px 20px 12px; /* match fixed topbar height space */
  height: calc(100dvh - 72px);
  overflow: hidden;
  align-items: start;
}
.main { min-width: 0; height: 100%; }
.stage { height: 100%; }
.sidebar { display: flex; flex-direction: column; gap: 12px; min-width: 0; height: 100%; overflow: auto; }

@media (max-width: 1100px) {
  .app { grid-template-columns: 1fr; }
  .sidebar { order: -1; }
}

/* ——— Cards ——— */
.card {
  background: linear-gradient(180deg, var(--panel), var(--panel-2));
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 12px;
  box-shadow: 0 6px 18px rgba(0,0,0,.25);
}
.card-title {
  display: flex; align-items: center; justify-content: space-between;
  font-size: 12px; text-transform: uppercase; letter-spacing: .8px; color: var(--muted);
  margin-bottom: 8px;
}

/* ——— Panels / rows ——— */
.row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.row.small { font-size: 12px; opacity: .9; }
.tip { opacity: .75; }

/* Utility */
.hidden { display: none !important; }

/* ——— Nerd stats overlay ——— */
#nerdPanel.nerd-panel {
  position: fixed;
  bottom: 12px;
  left: 12px;
  z-index: 1000;
  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: linear-gradient(180deg, var(--panel), var(--panel-2));
  box-shadow: 0 8px 18px rgba(0,0,0,.28);
  font-size: 12px;
  color: var(--muted);
  pointer-events: none;
  white-space: nowrap;
}
.right-controls #nerdToggle.active { color: var(--teal); border-color: color-mix(in oklab, var(--teal) 35%, transparent); }

/* ——— Chat + Emotes ——— */
#chatInput { width: 100%; }
.chat-messages {
  width: 100%;
  max-height: 200px;
  min-height: 120px;
  overflow-y: auto;
  padding: 8px 10px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.14));
  box-shadow: 0 1px 0 rgba(255,255,255,.04) inset;
}
#emotes { gap: 4px; }
#emotes .emote {
  padding: 4px 8px;
  font-size: 16px;
  line-height: 1;
  border-radius: 8px;
}

/* New emote bar id for redesigned layout */
#emoteBar { display: flex; flex-wrap: wrap; gap: 6px; }
#emoteBar .emote {
  padding: 6px 10px;
  font-size: 18px;
  line-height: 1;
  border-radius: 8px;
}

/* ——— Lists ——— */
.pill-list { display: flex; flex-wrap: wrap; gap: 6px; }

/* ——— Inputs / buttons ——— */
button, input {
  padding: 9px 12px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.08));
  color: var(--text);
  outline: none;
}
input { background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.12)); }
.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; width: 100%; }

button {
  cursor: pointer;
  transition: transform .06s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease;
  box-shadow: 0 1px 0 rgba(255,255,255,.06) inset, 0 8px 18px rgba(0,0,0,.28);
}
button:hover {
  border-color: rgba(255,255,255,.18);
  box-shadow: 0 1px 0 rgba(255,255,255,.08) inset, 0 10px 22px rgba(0,0,0,.3), 0 0 0 3px rgba(158, 241, 209, .08);
}
button:active { transform: translateY(1px); }
button[disabled] { opacity: .5; cursor: default; }

/* Weapon state styles */
.weapon { opacity: .95; }
.weapon.equipped { border-color: color-mix(in oklab, var(--teal) 35%, transparent); color: var(--teal); }
.weapon.owned { border-color: rgba(255,255,255,.18); }
.weapon.locked { opacity: .6; }

/* ——— Badges / pills ——— */
.badge {
  padding: 5px 9px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.14));
  color: var(--muted);
}
#status[data-state="connected"] { color: var(--teal); border-color: color-mix(in oklab, var(--teal) 35%, transparent); }
#status[data-state="disconnected"] { color: #c3c7d1; opacity: .85; }

.pill {
  position: relative;
  padding: 4px 10px 4px 22px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.12));
}
.pill::before {
  content: "";
  position: absolute;
  left: 8px; top: 50%; transform: translateY(-50%);
  width: 8px; height: 8px; border-radius: 999px;
  background: #888;
  box-shadow: 0 0 0 2px rgba(255,255,255,.06) inset;
}
.pill.streamer { color: var(--green); border-color: color-mix(in oklab, var(--green) 35%, transparent); }
.pill.streamer::before { background: var(--green); }
.pill.zombie   { color: var(--red); border-color: color-mix(in oklab, var(--red) 35%, transparent); }
.pill.zombie::before { background: var(--red); }

/* ——— Canvas / stage ——— */
.stage { display: grid; place-items: center; padding: 0; }
.stage { display: grid; place-items: center; padding: 0; }
canvas.arena {
  position: relative;
  /* size is controlled by JS to fit container while preserving AR */
  outline: 1px solid rgba(255,255,255,.04);
  border-radius: 18px;
  background:
    radial-gradient(transparent 0 7px, rgba(255,255,255,.06) 8px 8px) 0 0 / 32px 32px,
    linear-gradient(180deg, #1a1f27, #11161c);
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.03),
    0 12px 36px rgba(0,0,0,.55);
  animation: grid-pan 26s linear infinite;
}
/* Hide system cursor when hovering the game canvas */
canvas.arena:hover { cursor: none; }
canvas.arena:focus { outline: none; }
canvas.arena::after {
  content: "";
  position: absolute; inset: 0;
  border-radius: inherit;
  pointer-events: none;
  background:
    radial-gradient(80% 60% at 50% 40%, transparent, rgba(0,0,0,.22)),
    radial-gradient(circle at 50% 50%, rgba(255,255,255,.06), transparent 40%);
  mix-blend-mode: overlay;
  opacity: .8;
}
@keyframes grid-pan {
  0%   { background-position: 0 0, 0 0; }
  100% { background-position: 64px 64px, 0 0; }
}

body.connected canvas.arena {
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.03),
    0 12px 36px rgba(0,0,0,.55),
    0 0 22px rgba(45,212,191,.22);
}

/* ——— Hit flash / toast ——— */
.hit-flash { position: fixed; inset: 0; pointer-events: none;
  background:
    radial-gradient(circle at center, rgba(239,83,80,.18), transparent 60%);
  opacity: 0; transition: opacity .22s ease;
}
.hit-flash.show { opacity: 1; }

.toast {
  position: fixed; bottom: 18px; left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.18));
  color: var(--text);
  padding: 10px 14px;
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.4);
  opacity: 0; pointer-events: none;
  transition: opacity .2s ease, transform .2s ease;
}
.toast.show { opacity: 1; transform: translateX(-50%) translateY(-4px); }
/* Limit scrolling only on gameplay pages */
body.game { overflow: hidden; }
</file>

<file path="public/join.html">
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arena Shooter — Join as Zombie</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="game">
  <div class="topbar">
    <div class="brand">Arena Shooter</div>
    <div class="middle-controls">
      <span class="badge" id="status" data-state="disconnected">disconnected</span>
    </div>
    <div class="right-controls">
      <button id="fullscreen">Fullscreen</button>
      <button id="nerdToggle">Nerd Stats</button>
    </div>
  </div>

  <div class="app">
    <div class="main">
      <div class="stage"></div>
    </div>
    <aside class="sidebar">
      <div class="card">
        <div class="card-title">Join</div>
        <div class="row">
          <label for="name" class="badge">Name</label>
          <input id="name" />
        </div>
        <div class="row">
          <button id="shuffle">Random</button>
          <button id="join">Join</button>
          <span class="badge" id="timer">Time: --</span>
        </div>
        <div class="tip">WASD to move. You are a slow zombie; touch the streamer to drain their score.</div>
      </div>

      <div class="card">
        <div class="card-title">Emotes</div>
        <div id="emoteBar">
          <button class="emote">🧟</button>
          <button class="emote">💀</button>
          <button class="emote">🔥</button>
          <button class="emote">😂</button>
          <button class="emote">❤️</button>
          <button class="emote">💢</button>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Players</div>
        <div class="pill-list" id="players"></div>
      </div>

      <div class="card">
        <div class="card-title">Chat</div>
        <div id="chatMessages" class="chat-messages"></div>
        <div class="row"><input id="chatInput" placeholder="Chat..." /></div>
      </div>
    </aside>
  </div>

  <script type="module">
    import { connect, nameStorage, minimalCanvas, suppressPageHotkeys, inputController, createLatencyMonitor } from '/common.js';

    const params = new URLSearchParams(location.search);
    let roomId = params.get('room') || '';

    const { c, ctx } = minimalCanvas(1440, 810);
    suppressPageHotkeys();
    let ws, playerId, arena={w:960,h:540};
    let state = { players:[], bullets:[], arena, remainingTime: 0 };
    let gameMap = null; // {w,h,size,theme,tiles:Uint8Array, props, lights}
    const input = inputController({ mouse:true });
    const effects = [];
    // Smoothing for 20Hz -> 60fps render
    const smooth = new Map(); // id -> {x,y}
    const SMOOTH_TAU = 90; // ms
    function getSmoothedPos(id, tx, ty, dt){
      let s = smooth.get(id);
      if (!s) { s = { x: tx, y: ty }; smooth.set(id, s); return { x: tx, y: ty }; }
      const alpha = 1 - Math.exp(-dt / Math.max(1, SMOOTH_TAU));
      s.x += (tx - s.x) * alpha;
      s.y += (ty - s.y) * alpha;
      return { x: s.x, y: s.y };
    }
    // Dash trails for streamer visibility from zombie clients
    const trails = new Map(); // id -> Array<{x:number,y:number,t:number}>
    const TRAIL_TTL = 260; const TRAIL_MAX = 22;
    let prevBulletPos = new Map();

    const status = document.getElementById('status');
    const playersEl = document.getElementById('players');
    const nameEl = document.getElementById('name');
    const joinBtn = document.getElementById('join');
    // Join URL / code input
    const roomUrlInput = document.createElement('input');
    roomUrlInput.id = 'roomUrl';
    roomUrlInput.className = 'mono';
    roomUrlInput.placeholder = 'Room URL or code';
    // Insert into the Join card under name row
    const joinCard = document.querySelector('.sidebar .card');
    if (joinCard) {
      const row = document.createElement('div'); row.className = 'row'; row.appendChild(roomUrlInput);
      joinCard.insertBefore(row, joinCard.children[2]);
    }
    if (roomId) roomUrlInput.value = `${location.origin}/join.html?room=${roomId}`;
    roomUrlInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') joinBtn.click(); });
    const shuffleBtn = document.getElementById('shuffle');
    const timerEl = document.getElementById('timer');
    const emoteBar = document.getElementById('emoteBar');
    const chatInput = document.getElementById('chatInput');
    const chatMessagesEl = document.getElementById('chatMessages');
    const nerdToggleBtn = document.getElementById('nerdToggle');
    // Nerd panel overlay element
    const nerdPanel = document.createElement('div');
    nerdPanel.id = 'nerdPanel';
    nerdPanel.className = 'nerd-panel hidden mono';
    document.body.appendChild(nerdPanel);

    let nerdOn = localStorage.getItem('nerdStats') === '1';
    function setNerd(on){
      nerdOn = !!on;
      localStorage.setItem('nerdStats', nerdOn ? '1' : '0');
      nerdPanel.classList.toggle('hidden', !nerdOn);
      nerdToggleBtn.classList.toggle('active', nerdOn);
    }
    setNerd(nerdOn);
    nerdToggleBtn.onclick = () => setNerd(!nerdOn);

    // preload name
    nameEl.value = nameStorage().get() || '';

    function randomName(){
      const pool = ("KibaRogue,WoodsScav,ShorelineRat,FactoryGhost,LabsRunner,InterchangeChad,DormsGoblin,ReserveMole,FleaFlipper,TetrizHoarder,LedXHunter,SlickSeeker,RSASSEnjoyer,M995Enjoyer,GrenadierGoon,SanitarStan,KillaChaser,TagillaTapper,GluharGuy,ShturmanScout,KnightWatcher,RogueRaider,USECFriend,BEARBuddy,JaegerPal,FenceFella,TherapistAlly,RagmanRigger,SkierSlinger,PraporPatron,MechanicMain,PeacekeeperPro,LabsRat,MarkedRoomMole,StashGremlin,MoonshineMax,ScavJunkie,OmComEnjoyer,SJ6Sprinter,AltynAddict,ThermalAndy,GreenBatteryGuy,DormsKeyKing,GPUGoblin,AmmoArbiter,WaffleFilter").split(",");
      return pool[Math.floor(Math.random()*pool.length)];
    }

    document.getElementById('shuffle').onclick = (ev) => { nameEl.value = randomName(); if (ev.currentTarget && ev.currentTarget.blur) ev.currentTarget.blur(); };

    function sendChat(msg) {
      if (ws && ws.readyState===1) ws.send(JSON.stringify({ type:'chat', message: msg }));
    }

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && chatInput.value.trim()) {
        sendChat(chatInput.value.trim());
        chatInput.value = '';
      }
    });

    function appendChat(from, message) {
      chatMessagesEl.innerHTML += `<div>${from}: ${message}</div>`;
      while (chatMessagesEl.children.length > 10) {
        chatMessagesEl.removeChild(chatMessagesEl.firstChild);
      }
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    let sendNeutralHandler = null; let visHandler = null; let inputIv = null;
    let pingIv = null; let latency = null; let stateMsgCount = 0; let statesPerSec = 0; let lastStateRateAt = performance.now();
    function leave(){
      if (ws) { try { if (ws.readyState===1) ws.close(1000,'leave'); } catch{} ws=null; }
      status.textContent = 'disconnected';
      status.dataset.state = 'disconnected';
      document.body.classList.remove('connected');
      joinBtn.textContent = 'Join';
      nameEl.disabled = false; shuffleBtn.disabled = false;
      if (inputIv) { clearInterval(inputIv); inputIv = null; }
      if (pingIv) { clearInterval(pingIv); pingIv = null; }
      if (sendNeutralHandler) { window.removeEventListener('blur', sendNeutralHandler); sendNeutralHandler=null; }
      if (visHandler) { document.removeEventListener('visibilitychange', visHandler); visHandler=null; }
    }

    function extractRoomId(val){
      const s = String(val||'').trim();
      if (!s) return '';
      try {
        const u = new URL(s);
        const q = u.searchParams.get('room');
        if (q) return q;
      } catch {}
      // fallback: treat as code
      return s;
    }

    joinBtn.onclick = (ev) => {
      if (ws && ws.readyState===1) { leave(); return; }
      const provided = extractRoomId(roomUrlInput.value);
      if (provided) roomId = provided;
      if (!roomId) { alert('Missing room id'); return; }
      const name = (nameEl.value||'').slice(0,20);
      nameStorage().set(name);
      if (ev.currentTarget && ev.currentTarget.blur) ev.currentTarget.blur();
      ws = connect(roomId);
      ws.addEventListener('open', () => {
        status.textContent = 'connected';
        status.dataset.state = 'connected';
        document.body.classList.add('connected');
        ws.send(JSON.stringify({ type:'join_room', role:'zombie', name }));
        joinBtn.textContent = 'Leave';
        nameEl.disabled = true; shuffleBtn.disabled = true;
      });
      latency = createLatencyMonitor(ws);
      if (pingIv) { clearInterval(pingIv); pingIv = null; }
      pingIv = setInterval(() => { try { latency.sendPing(); } catch {} }, 1000);
      ws.addEventListener('message', (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'map') {
          try {
            const m = msg.map; const bin = atob(m.tilesBase64);
            const u8 = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
            gameMap = { w:m.w, h:m.h, size:m.size, theme:m.theme, tiles:u8, props:m.props||[], lights:m.lights||[] };
          } catch {}
        }
        if (msg.type === 'joined') { arena = msg.arena; playerId = msg.playerId; }
        if (msg.type === 'state') {
          stateMsgCount++;
          // impact effects
          const curMap = new Map(msg.bullets.map(b=>[b.id,{x:b.x,y:b.y}]));
          for (const [id,pos] of prevBulletPos){ if (!curMap.has(id)) effects.push({x:pos.x,y:pos.y,ttl:220}); }
          prevBulletPos = curMap;

          state = msg; const ping = Math.max(0, Date.now() - (msg.t||Date.now()));
          status.textContent = `connected • ${ping} ms • players: ${msg.players.length}`; 
          status.dataset.state = 'connected';
          state.remainingTime = msg.remainingTime;
          updateTimer(state.remainingTime);
          updatePlayerList(msg.players);
          // Respect chat enabled/disabled from server
          if (typeof msg.chatEnabled === 'boolean') {
            chatInput.disabled = !msg.chatEnabled;
            chatInput.placeholder = msg.chatEnabled ? 'Chat...' : 'Chat disabled by streamer';
            const chatCard = chatMessagesEl.closest('.card');
          if (chatCard) chatCard.classList.toggle('hidden', !msg.chatEnabled);
          }
        }
        if (msg.type === 'pong') {
          if (latency) latency.handlePong(Number(msg.timestamp)||0);
        }
        if (msg.type === 'chat') {
          appendChat(msg.from, msg.message);
        }
        if (msg.type === 'notice') {
          appendChat('System', msg.message);
        }
      });
      // Send continuous movement state for smooth input like streamer
      inputIv = setInterval(() => {
        if (ws && ws.readyState===1) {
          const { up,down,left,right,shoot } = input;
          const aimWX = camX + (input.aimX / zoom);
          const aimWY = camY + (input.aimY / zoom);
          ws.send(JSON.stringify({ type:'input', up, down, left, right, shoot, melee:false, dash:false, aimX:aimWX, aimY:aimWY }));
        }
      }, 50);

      // If the tab loses focus while holding a key, send a neutral input
      sendNeutralHandler = () => { if (ws && ws.readyState===1) ws.send(JSON.stringify({ type:'input', up:false, down:false, left:false, right:false, shoot:false, melee:false, dash:false, aimX:0, aimY:0 })); };
      visHandler = () => { if (document.hidden) sendNeutralHandler(); };
      window.addEventListener('blur', sendNeutralHandler);
      document.addEventListener('visibilitychange', visHandler);

      ws.addEventListener('close', () => { leave(); }, { once: true });
    };

    // Emote palette: send selected emoji to server (zombies only)
    emoteBar.addEventListener('click', (e) => {
      const target = e.target;
      if (!target || !(target instanceof HTMLElement) || !target.classList.contains('emote')) return;
      const symbol = target.textContent || '';
      if (!ws || ws.readyState !== 1) return;
      ws.send(JSON.stringify({ type: 'emote', symbol }));
    });

    // Simple camera for zombies: follow self
    let camX = 0, camY = 0;
    const zoom = 2.4; // match streamer view
    function draw(dt=16){
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
      const rect = c.getBoundingClientRect();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,c.width,c.height);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      // Fill background with dungeon-themed dark color in CSS px
      ctx.fillStyle = "#0a0c0f";
      ctx.fillRect(0,0,rect.width,rect.height);
      // Update camera target (follow me)
      let meRaw = state.players.find(p=>p.id===playerId);
      if (!meRaw && state.players && state.players.length) {
        meRaw = state.players.find(p=>p.role==='zombie') || state.players[0];
      }
      const meCam = meRaw ? getSmoothedPos(meRaw.id, meRaw.x, meRaw.y, dt) : null;
      if (meCam) {
        const viewW = rect.width / zoom, viewH = rect.height / zoom;
        const targetX = Math.min(Math.max(0, meCam.x - viewW/2), Math.max(0, arena.w - viewW));
        const targetY = Math.min(Math.max(0, meCam.y - viewH/2), Math.max(0, arena.h - viewH));
        const k = Math.min(1, (dt/16) * 0.12);
        camX = camX + (targetX - camX) * k;
        camY = camY + (targetY - camY) * k;
      }

      // World transform
      ctx.save();
      ctx.scale(zoom, zoom);
      ctx.translate(-camX, -camY);
      // Tiles first
      if (gameMap) drawTiles(camX, camY, rect.width/zoom, rect.height/zoom);
      // Walls/rooms
      if (state.walls){
        ctx.fillStyle = '#2a2f36';
        for (const w of state.walls){ ctx.fillRect(w.x,w.y,w.w,w.h); }
      }
      // Extractions removed
      // Pickups
      if (state.pickups){
        for (const pk of state.pickups){
          ctx.save();
          ctx.shadowColor = 'rgba(255,255,255,.18)'; ctx.shadowBlur = 8;
          if (pk.type==='health'){
            ctx.strokeStyle = '#66bb6a'; ctx.lineWidth = 2; ctx.strokeRect(pk.x-8, pk.y-8, 16, 16);
            ctx.beginPath(); ctx.moveTo(pk.x-6, pk.y); ctx.lineTo(pk.x+6, pk.y); ctx.moveTo(pk.x, pk.y-6); ctx.lineTo(pk.x, pk.y+6); ctx.stroke();
          } else if (pk.type==='speed') {
            ctx.strokeStyle = '#64b5f6'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(pk.x-5, pk.y-8); ctx.lineTo(pk.x+2, pk.y-2); ctx.lineTo(pk.x-2, pk.y-2); ctx.lineTo(pk.x+5, pk.y+8); ctx.stroke();
          } else if (pk.type==='ammo') {
            ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2; ctx.strokeRect(pk.x-7, pk.y-5, 14, 10);
            ctx.beginPath(); ctx.moveTo(pk.x-4, pk.y+1); ctx.lineTo(pk.x-4, pk.y-1); ctx.moveTo(pk.x, pk.y+1); ctx.lineTo(pk.x, pk.y-1); ctx.moveTo(pk.x+4, pk.y+1); ctx.lineTo(pk.x+4, pk.y-1); ctx.stroke();
          } else if (pk.type==='weapon') {
            ctx.strokeStyle = '#ffa726'; ctx.beginPath(); ctx.moveTo(pk.x-6,pk.y); ctx.lineTo(pk.x,pk.y-8); ctx.lineTo(pk.x+2,pk.y-2); ctx.lineTo(pk.x+8,pk.y-2); ctx.lineTo(pk.x,pk.y+8); ctx.lineTo(pk.x+2,pk.y+2); ctx.lineTo(pk.x-6,pk.y); ctx.stroke();
          } else if (pk.type==='shield') {
            ctx.strokeStyle = '#26c6da'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(pk.x, pk.y, 9, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(pk.x, pk.y-6); ctx.lineTo(pk.x, pk.y+6); ctx.stroke();
          } else if (pk.type==='magnet') {
            ctx.strokeStyle = '#ab47bc'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pk.x-3, pk.y, 6, -Math.PI/2, Math.PI/2);
            ctx.arc(pk.x+3, pk.y, 6, Math.PI/2, -Math.PI/2);
            ctx.stroke();
          } else if (pk.type==='freeze') {
            ctx.strokeStyle = '#90caf9'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pk.x, pk.y-7); ctx.lineTo(pk.x, pk.y+7);
            ctx.moveTo(pk.x-7, pk.y); ctx.lineTo(pk.x+7, pk.y);
            ctx.moveTo(pk.x-5, pk.y-5); ctx.lineTo(pk.x+5, pk.y+5);
            ctx.moveTo(pk.x-5, pk.y+5); ctx.lineTo(pk.x+5, pk.y-5);
            ctx.stroke();
          } else if (pk.type==='blast') {
            ctx.strokeStyle = '#ff7043'; ctx.lineWidth = 2;
            for (let i=0;i<8;i++){ const a=i*Math.PI/4; ctx.beginPath(); ctx.moveTo(pk.x+Math.cos(a)*3, pk.y+Math.sin(a)*3); ctx.lineTo(pk.x+Math.cos(a)*10, pk.y+Math.sin(a)*10); ctx.stroke(); }
            ctx.beginPath(); ctx.arc(pk.x, pk.y, 3, 0, Math.PI*2); ctx.stroke();
          } else if (pk.type==='treasure') {
            ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2;
            ctx.strokeRect(pk.x-8, pk.y-6, 16, 12);
            ctx.beginPath(); ctx.moveTo(pk.x-8, pk.y-2); ctx.lineTo(pk.x+8, pk.y-2); ctx.stroke();
            ctx.beginPath(); ctx.arc(pk.x, pk.y+1, 2, 0, Math.PI*2); ctx.stroke();
          }
          // label under pickup
          ctx.font = '10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.save(); ctx.globalAlpha = 0.18; ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(pk.x, pk.y, 3, 0, Math.PI*2); ctx.fill(); ctx.restore();
          ctx.fillStyle = '#cfd8dc'; ctx.globalAlpha = 0.95;
          const labelMap = { health:'HEALTH', speed:'SPEED', ammo:'AMMO', weapon:'WEAPON', shield:'SHIELD', magnet:'MAGNET', freeze:'FREEZE', blast:'BLAST', treasure:'TREASURE', key:'KEY' };
          const lbl = labelMap[pk.type] || String(pk.type).toUpperCase();
          if (lbl) ctx.fillText(lbl, pk.x, pk.y + 14);
          ctx.restore();
        }
        ctx.lineWidth = 1;
      }
      // Bullets
      ctx.fillStyle = '#ffd54f';
      for (const b of state.bullets){
        ctx.save();
        ctx.shadowColor = 'rgba(255,213,79,.6)';
        ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
      // Spitter globs
      if (state.globs){
        ctx.fillStyle = '#ce93d8';
        for (const g of state.globs){
          ctx.save(); ctx.shadowColor='rgba(206,147,216,.6)'; ctx.shadowBlur=8; ctx.beginPath(); ctx.arc(g.x,g.y,4,0,Math.PI*2); ctx.fill(); ctx.restore();
        }
      }
      // Bullet impact effects
      for (let i=effects.length-1;i>=0;i--){ const e=effects[i]; e.ttl-=dt; if (e.ttl<=0){ effects.splice(i,1); continue; } ctx.save(); const a=Math.max(0,e.ttl/220); ctx.globalAlpha=a; ctx.strokeStyle='#ffd54f'; ctx.beginPath(); ctx.arc(e.x,e.y,(1-a)*12+2,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
      // Players' dash trails under characters
      const nowT = performance.now();
      if (state.players){
        for (const p of state.players){
          const sp = getSmoothedPos(p.id, p.x, p.y, 0);
          let arr = trails.get(p.id) || [];
          if (p.dashing){ arr.push({ x: sp.x, y: sp.y, t: nowT }); if (arr.length > TRAIL_MAX) arr.shift(); }
          arr = arr.filter(pt => nowT - pt.t <= TRAIL_TTL);
          trails.set(p.id, arr);
          if (arr.length >= 2){
            for (let i=0;i<arr.length;i++){
              const age = nowT - arr[i].t;
              const a = Math.max(0, 1 - (age / TRAIL_TTL));
              const r = 6 + 10 * a;
              ctx.save(); ctx.globalAlpha = 0.22 + 0.4*a; ctx.fillStyle='rgba(158,241,209,1)'; ctx.shadowColor='rgba(158,241,209,.7)'; ctx.shadowBlur=12*a; ctx.beginPath(); ctx.arc(arr[i].x,arr[i].y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
            }
          }
        }
      }

      // Players
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'center';
      for (const p of state.players){
        const sp = getSmoothedPos(p.id, p.x, p.y, dt);
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,.6)'; ctx.shadowBlur = 0;
        if (p.role==='streamer'){
          ctx.strokeStyle = '#4caf50';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(sp.x,sp.y,10,0,Math.PI*2); ctx.stroke();
          ctx.fillStyle = '#4caf50'; ctx.globalAlpha = .95; ctx.fillText(p.name, sp.x, sp.y - 16);
        } else {
          ctx.fillStyle = p.alive? '#ef5350' : 'rgba(239,83,80,.25)';
          ctx.beginPath(); ctx.arc(sp.x,sp.y,12,0,Math.PI*2); ctx.fill();
          // Class outline
          if (p.zClass === 'runner') { ctx.strokeStyle = '#64b5f6'; ctx.lineWidth = 1.5; }
          else if (p.zClass === 'brute') { ctx.strokeStyle = '#ffa726'; ctx.lineWidth = 3; }
          else if (p.zClass === 'spitter') { ctx.strokeStyle = '#ba68c8'; ctx.lineWidth = 2; }
          else { ctx.strokeStyle = '#e57373'; ctx.lineWidth = 1; }
          ctx.globalAlpha = .9; ctx.beginPath(); ctx.arc(sp.x,sp.y, (p.zClass==='brute')?14:13, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
          if (p.boosted){ ctx.strokeStyle = '#64b5f6'; ctx.globalAlpha=.8; ctx.beginPath(); ctx.arc(sp.x,sp.y,16,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
          ctx.fillStyle = '#e57373'; ctx.globalAlpha = .95; ctx.fillText(p.name, sp.x, sp.y - 16);
          // Emote above zombie head for 5s
          if (p.emote && (p.emoteUntil||0) > Date.now()){
            ctx.font = '18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
            ctx.globalAlpha = 1;
            ctx.fillText(p.emote, sp.x, sp.y - 32);
            ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          }
        }
        // Bat swing arc visual (short-lived)
        const swingAge = (state.t||Date.now()) - (p.meleeAt||0);
        if (swingAge >= 0 && swingAge < 220) {
          const alpha = 1 - (swingAge / 220);
          const ang = Math.atan2(p.meleeDirY||0, p.meleeDirX||1);
          const span = Math.PI / 1.8; // ~100°
          const r0 = 14, r1 = 34;
          ctx.save();
          ctx.globalAlpha = Math.max(0, alpha*0.9);
          ctx.fillStyle = 'rgba(255,213,79,0.35)';
          ctx.beginPath();
          ctx.moveTo(sp.x + Math.cos(ang - span/2)*r0, sp.y + Math.sin(ang - span/2)*r0);
          ctx.arc(sp.x, sp.y, r1, ang - span/2, ang + span/2);
          ctx.lineTo(sp.x + Math.cos(ang + span/2)*r0, sp.y + Math.sin(ang + span/2)*r0);
          ctx.arc(sp.x, sp.y, r0, ang + span/2, ang - span/2, true);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }

      ctx.restore();

      // Crosshair (screen-space, centered at aim cursor)
      {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
        ctx.setTransform(dpr,0,0,dpr,0,0);
        const cx = input.aimX || 0; const cy = input.aimY || 0;
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#cfd8dc';
        // Outer ring
        ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.stroke();
        // Gap cross
        const arm = 14, gap = 6, len = 9;
        // left
        ctx.beginPath(); ctx.moveTo(cx - arm, cy); ctx.lineTo(cx - gap, cy); ctx.stroke();
        // right
        ctx.beginPath(); ctx.moveTo(cx + gap, cy); ctx.lineTo(cx + arm, cy); ctx.stroke();
        // top
        ctx.beginPath(); ctx.moveTo(cx, cy - arm); ctx.lineTo(cx, cy - gap); ctx.stroke();
        // bottom
        ctx.beginPath(); ctx.moveTo(cx, cy + gap); ctx.lineTo(cx, cy + arm); ctx.stroke();
        // Subtle center dot
        ctx.globalAlpha = 0.7; ctx.fillStyle = '#cfd8dc'; ctx.beginPath(); ctx.arc(cx, cy, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // Extractions removed

      // Mini-map (bottom-right)
      drawMiniMap();

      // Screen border on top
      ctx.save(); ctx.lineWidth = 2; ctx.strokeStyle = '#808080'; ctx.strokeRect(1,1,rect.width-2,rect.height-2); ctx.restore();
      // Class legend (bottom-right above minimap)
      drawClassLegend();
    }

    function updatePlayerList(players){
      playersEl.innerHTML = players.map(p=>`<span class="pill ${p.role}">${p.role==='streamer'?'🟢':'🧟'} ${p.name}${p.role==='streamer'?' · '+p.score:''}</span>`).join(' ');
    }

    function updateTimer(seconds) {
      const min = Math.floor(seconds / 60);
      const sec = seconds % 60;
      timerEl.textContent = `Time: ${min}:${sec.toString().padStart(2, '0')}`;
    }

    // Animation loop + nerd stats
    let last = performance.now();
    const fpsSamples = [];
    const fpsWindow = 120; // ~2s at 60fps
    let lastNerdUpdate = 0;
    function loop(){
      const now=performance.now(); const dt=now-last; last=now; draw(dt);
      const fps = dt>0 ? 1000/dt : 0; fpsSamples.push(fps); if (fpsSamples.length>fpsWindow) fpsSamples.shift();
      if (now - lastStateRateAt >= 1000){ statesPerSec = stateMsgCount; stateMsgCount = 0; lastStateRateAt = now; }
      if (nerdOn && now - lastNerdUpdate > 250){
        const avgFps = fpsSamples.length ? (fpsSamples.reduce((a,b)=>a+b,0)/fpsSamples.length) : 0;
        const minFps = fpsSamples.length ? Math.min(...fpsSamples) : 0;
        const maxFps = fpsSamples.length ? Math.max(...fpsSamples) : 0;
        const lat = latency ? latency.getLatencyStats() : { avg:0, min:0, max:0, jitter:0 };
        const players = state.players?.length||0;
        const zombies = state.players?.filter(p=>p.role==='zombie').length||0;
        const bullets = state.bullets?.length||0;
        const pickups = state.pickups?.length||0;
        const walls = state.walls?.length||0;
        const wsBuf = ws && ws.bufferedAmount || 0;
        nerdPanel.innerHTML = `
          <div><strong>Nerd Stats</strong></div>
          <div>FPS: ${avgFps.toFixed(1)} (min ${minFps.toFixed(0)} max ${maxFps.toFixed(0)})</div>
          <div>Latency: ${lat.avg.toFixed(1)} ms (min ${lat.min.toFixed(0)} max ${lat.max.toFixed(0)}) jitter ${lat.jitter.toFixed(1)} ms</div>
          <div>States/s: ${statesPerSec.toFixed(0)}</div>
          <div>Entities: players ${players} (z ${zombies}) bullets ${bullets} pickups ${pickups} walls ${walls}</div>
          <div>WS buf: ${wsBuf}</div>
        `;
        lastNerdUpdate = now;
      }
      requestAnimationFrame(loop);
    }
    loop();

    // Fullscreen
    document.getElementById('fullscreen').onclick = async () => {
      if (!document.fullscreenElement) { await document.documentElement.requestFullscreen().catch(()=>{}); }
      else { await document.exitFullscreen().catch(()=>{}); }
    };

    function drawMiniMap(){
      const rect = c.getBoundingClientRect();
      const mmSize = 160; const pad = 12; const cx = rect.width - pad - mmSize/2; const cy = rect.height - pad - mmSize/2;
      const R = (mmSize/2) - 4;
      const W = (state.arena && state.arena.w) || 960; const H = (state.arena && state.arena.h) || 540;
      // Zoom in and center around local player for context
      const meMM = state.players && state.players.find(p=>p.id===playerId);
      const centerX = meMM ? meMM.x : W/2;
      const centerY = meMM ? meMM.y : H/2;
      const MM_ZOOM = 1.6;
      const scale = (2*R*MM_ZOOM) / Math.max(W, H);
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = 'rgba(18,20,24,.86)';
      ctx.beginPath(); ctx.arc(cx, cy, mmSize/2, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth = 2; ctx.stroke();
      ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.clip();
      if (state.walls) {
        ctx.strokeStyle = 'rgba(255,255,255,.25)'; ctx.lineWidth = 1;
        for (const w of state.walls){
          const x = cx + (w.x - centerX) * scale; const y = cy + (w.y - centerY) * scale;
          const ww = w.w * scale; const hh = w.h * scale;
          ctx.strokeRect(x, y, ww, hh);
        }
      }
      // Extractions removed
      if (state.players){
        for (const p of state.players){
          const px = cx + (p.x - centerX) * scale; const py = cy + (p.y - centerY) * scale;
          const r = p.role==='streamer' ? 3 : 2;
          ctx.beginPath();
          ctx.fillStyle = p.role==='streamer' ? '#4caf50' : (p.alive ? '#ef5350' : 'rgba(239,83,80,.4)');
          ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
          if (p.id === playerId) { ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1; ctx.stroke(); }
        }
      }
      ctx.restore(); ctx.restore();
    }

    function drawTiles(viewX, viewY, viewW, viewH){
      const m = gameMap; if (!m) return; const sz = m.size;
      const theme = m.theme||'dungeon';
      const pal = theme==='dungeon' ? {
        floor:'#0e1115', wall:'#2a2f36', pit:'#0b0d11', water:'#0d1b2a', edge:'#9aa4b2', propCrate:'#6d4c41', propPillar:'#b0bec5', propBone:'#8d6e63'
      } : theme==='cave' ? {
        floor:'#0d1113', wall:'#263238', pit:'#0a0e10', water:'#0b1f2d', edge:'#90a4ae', propCrate:'#546e7a', propPillar:'#90caf9', propBone:'#80cbc4'
      } : {
        floor:'#111416', wall:'#3c4148', pit:'#0b0c0d', water:'#14212e', edge:'#b0bec5', propCrate:'#90a4ae', propPillar:'#cfd8dc', propBone:'#b0bec5'
      };
      const sx = Math.max(0, Math.floor(viewX/sz)-1), sy = Math.max(0, Math.floor(viewY/sz)-1);
      const ex = Math.min(m.w-1, Math.ceil((viewX+viewW)/sz)+1), ey = Math.min(m.h-1, Math.ceil((viewY+viewH)/sz)+1);
      // Floor
      for (let y=sy;y<=ey;y++){
        for (let x=sx;x<=ex;x++){
          const id = m.tiles[y*m.w + x];
          if (id===0){ ctx.fillStyle = pal.floor; ctx.fillRect(x*sz, y*sz, sz, sz); ctx.globalAlpha=.06; ctx.fillStyle='#ffffff'; ctx.fillRect(x*sz+4,y*sz+4,3,3); ctx.globalAlpha=1; }
        }
      }
      // Pits/Water
      for (let y=sy;y<=ey;y++) for (let x=sx;x<=ex;x++){ const id=m.tiles[y*m.w+x]; if (id===2){ ctx.fillStyle='#101318'; ctx.fillRect(x*sz,y*sz,sz,sz);} if (id===3){ ctx.fillStyle='#0d1b2a'; ctx.fillRect(x*sz,y*sz,sz,sz);} }
      // Walls outline
      const isWall=(ix,iy)=> ix>=0&&iy>=0&&ix<m.w&&iy<m.h && m.tiles[iy*m.w+ix]===1;
      ctx.fillStyle = pal.wall;
      for (let y=sy;y<=ey;y++){
        for (let x=sx;x<=ex;x++){
          if (!isWall(x,y)) continue; const px=x*sz, py=y*sz; ctx.fillRect(px,py,sz,sz);
          ctx.strokeStyle=pal.edge; ctx.lineWidth=1; ctx.globalAlpha=.15;
          if (!isWall(x,y-1)){ ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px+sz,py); ctx.stroke(); }
          if (!isWall(x+1,y)){ ctx.beginPath(); ctx.moveTo(px+sz,py); ctx.lineTo(px+sz,py+sz); ctx.stroke(); }
          if (!isWall(x,y+1)){ ctx.beginPath(); ctx.moveTo(px,py+sz); ctx.lineTo(px+sz,py+sz); ctx.stroke(); }
          if (!isWall(x-1,y)){ ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px,py+sz); ctx.stroke(); }
          ctx.globalAlpha=1;
        }
      }
      // Props
      for (const p of (m.props||[])){
        const px=p.x*sz, py=p.y*sz; ctx.save(); ctx.globalAlpha=.9; ctx.fillStyle=p.type==='crate'?pal.propCrate:p.type==='pillar'?pal.propPillar:pal.propBone; ctx.fillRect(px+4,py+4,sz-8,sz-8); ctx.restore();
      }
      // Lights
      for (const l of (m.lights||[])){
        const cx=l.x*sz+sz/2, cy=l.y*sz+sz/2, rr=l.r*sz; const g=ctx.createRadialGradient(cx,cy,2,cx,cy,rr); g.addColorStop(0,`rgba(255,255,200,${0.35*l.a})`); g.addColorStop(1,'rgba(255,255,200,0)'); ctx.save(); ctx.fillStyle=g; ctx.fillRect(cx-rr,cy-rr,rr*2,rr*2); ctx.restore();
      }
    }

    // Simple lighting overlay for zombies — lighter than streamer
    function drawLighting(viewX, viewY, viewW, viewH, me){
      ctx.save(); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(viewX,viewY,viewW,viewH); ctx.globalCompositeOperation='destination-out';
      const add=(x,y,r,a=1)=>{ const g=ctx.createRadialGradient(x,y,2,x,y,r); g.addColorStop(0,`rgba(255,255,220,${0.6*a})`); g.addColorStop(1,'rgba(255,255,220,0)'); ctx.fillStyle=g; ctx.fillRect(x-r,y-r,r*2,r*2); };
      if (gameMap){ const sz=gameMap.size; for(const l of (gameMap.lights||[])) add(l.x*sz+sz/2,l.y*sz+sz/2,(l.r||6)*sz,l.a||0.2); }
      if (me) add(me.x, me.y, 110, 1);
      for (const b of (state.bullets||[])) add(b.x,b.y,22,.6);
      ctx.restore();
    }

    function drawClassLegend(){
      const rect = c.getBoundingClientRect();
      const pad = 12;
      const boxW = 160, boxH = 70;
      const x = rect.width - boxW - pad;
      const y = rect.height - 160 - boxH - pad;
      ctx.save();
      ctx.globalAlpha = .95; ctx.fillStyle = 'rgba(18,20,24,.86)'; ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.roundRect ? ctx.roundRect(x,y,boxW,boxH,10) : (ctx.moveTo(x+10,y),ctx.lineTo(x+boxW-10,y),ctx.quadraticCurveTo(x+boxW,y,x+boxW,y+10),ctx.lineTo(x+boxW,y+boxH-10),ctx.quadraticCurveTo(x+boxW,y+boxH,x+boxW-10,y+boxH),ctx.lineTo(x+10,y+boxH),ctx.quadraticCurveTo(x,y+boxH,x,y+boxH-10),ctx.lineTo(x,y+10),ctx.quadraticCurveTo(x,y,x+10,y));
      ctx.fill(); ctx.stroke();
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif'; ctx.fillStyle = '#cfd8dc';
      const rows = [
        { label: 'Runner', color: '#64b5f6', lw: 1.5 },
        { label: 'Brute', color: '#ffa726', lw: 3 },
        { label: 'Spitter', color: '#ba68c8', lw: 2 },
      ];
      let yy = y + 18;
      for (const r of rows){
        ctx.save(); ctx.strokeStyle = r.color; ctx.lineWidth = r.lw; ctx.beginPath(); ctx.arc(x+14, yy-4, 6, 0, Math.PI*2); ctx.stroke(); ctx.restore();
        ctx.fillText(r.label, x+28, yy-2);
        yy += 22;
      }
      ctx.restore();
    }
  </script>
</body>
</html>
</file>

<file path="public/streamer.html">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Arena Shooter â€” Streamer</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body class="game">
    <div class="topbar">
      <div class="brand">Arena Shooter</div>
      <div class="middle-controls">
        <span class="badge" id="status" data-state="disconnected"
          >disconnected</span
        >
      </div>
      <div class="right-controls">
        <button id="fullscreen">Fullscreen</button>
        <button id="nerdToggle">Nerd Stats</button>
      </div>
    </div>

    <div class="app">
      <div class="main">
        <div class="stage"></div>
      </div>
      <aside class="sidebar">
        <div class="card">
          <div class="card-title">Session</div>
          <div class="row">
            <button id="newRoom">Create Room</button>
            <button id="toggleChat" disabled>Disable Chat</button>
          </div>
          <div class="row">
            <input
              id="roomLink"
              class="mono"
              placeholder="Join link"
              readonly
            />
            <button id="copy" disabled>Copy Link</button>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Weapons</div>
          <div class="row">
            <button class="weapon" id="btnPistol" data-weapon="pistol">
              Pistol (1)
            </button>
            <button class="weapon" id="btnSmg" data-weapon="smg">
              SMG (2)
            </button>
            <button class="weapon" id="btnShotgun" data-weapon="shotgun">
              Shotgun (3)
            </button>
          </div>
          <div class="row">
            <button id="buyShotgun" title="Costs 300 banked" disabled>
              Unlock Shotgun (4) • 300
            </button>
            <button id="buySmg" title="Costs 300 banked" disabled>
              Unlock SMG (5) • 300
            </button>
          </div>
          <div class="tip">
            Right‑click or Q to swing bat. Pistol is free. Unlock SMG/Shotgun
            with banked (300 each). Use 1/2/3 to equip, 5/4 to buy.
          </div>
        </div>

        <div class="card">
          <div class="card-title">Stats</div>
          <div class="row">
            <span class="badge">Score: <span id="score">0</span></span>
            <span class="badge">Banked: <span id="banked">0</span></span>
            <span class="badge">HP: <span id="hp">100</span></span>
            <span class="badge">Weapon: <span id="weapon">pistol</span></span>
            <span class="badge">Ammo: <span id="ammo">0</span></span>
            <span class="badge" id="timer">Time: --</span>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Players</div>
          <div class="pill-list" id="players"></div>
        </div>

        <div class="card">
          <div class="card-title">Chat</div>
          <div id="chatMessages" class="chat-messages"></div>
          <div class="row"><input id="chatInput" placeholder="Chat..." /></div>
        </div>
      </aside>
    </div>
    <div class="hit-flash" id="flash"></div>

    <script type="module">
      import {
        connect,
        nameStorage,
        minimalCanvas,
        inputController,
        suppressPageHotkeys,
        toast,
        createLatencyMonitor,
      } from "/common.js";

      const urlParams = new URLSearchParams(location.search);
      const presetRoom = urlParams.get('room') || '';
      const create = async () => {
        if (presetRoom) return presetRoom;
        const res = await fetch("/create", { method: "POST" });
        const { roomId } = await res.json();
        return roomId;
      };

      const { c, ctx } = minimalCanvas(1440, 810);
      document.querySelector(".stage").appendChild(c);
      suppressPageHotkeys();
      const input = inputController();

      let ws,
        roomId,
        playerId,
        arena = { w: 960, h: 540 };
      let state = { players: [], bullets: [], arena, remainingTime: 0, aiZombies: [] };
      let gameMap = null; // {w,h,size,theme,tiles:Uint8Array, props, lights}
      let lastHp = 100;
      let lastStateTime = performance.now();
      let lastScore = 0;
      const effects = []; // bullet impacts etc {x,y,ttl}
      // Screen shake accumulator (reduced each frame)
      let shake = 0;
      let muzzleFlashes = [];
      let prevShoot = false;
      let lastMuzzleAt = 0;
      let prevBulletPos = new Map();
      // Dash trails: per-player history of recent positions while dashing
      const trails = new Map(); // id -> Array<{x:number,y:number,t:number}>
      const TRAIL_TTL = 260; // ms
      const TRAIL_MAX = 22;
      // Local melee feedback (client-side prediction so streamer sees instantly)
      let localMeleeAt = 0;
      let localMeleeDirX = 1;
      let localMeleeDirY = 0;
      let prevMelee = false;

      const link = document.getElementById("roomLink");
      const status = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const bankedEl = document.getElementById("banked");
      const hpEl = document.getElementById("hp");
      const ammoEl = document.getElementById("ammo");
      const weaponEl = document.getElementById("weapon");
      const playersEl = document.getElementById("players");
      const buyShotgunBtn = document.getElementById("buyShotgun");
      const buySmgBtn = document.getElementById("buySmg");
      const btnPistol = document.getElementById("btnPistol");
      const btnSmg = document.getElementById("btnSmg");
      const btnShotgun = document.getElementById("btnShotgun");
      const flashEl = document.getElementById("flash");
      const newBtn = document.getElementById("newRoom");
      const copyBtn = document.getElementById("copy");
      const timerEl = document.getElementById("timer");
      const chatMessagesEl = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const toggleChatBtn = document.getElementById("toggleChat");
      const nerdToggleBtn = document.getElementById("nerdToggle");
      // Nerd panel overlay element
      const nerdPanel = document.createElement("div");
      nerdPanel.id = "nerdPanel";
      nerdPanel.className = "nerd-panel hidden mono";
      document.body.appendChild(nerdPanel);

      let nerdOn = localStorage.getItem("nerdStats") === "1";
      function setNerd(on) {
        nerdOn = !!on;
        localStorage.setItem("nerdStats", nerdOn ? "1" : "0");
        nerdPanel.classList.toggle("hidden", !nerdOn);
        nerdToggleBtn.classList.toggle("active", nerdOn);
      }
      setNerd(nerdOn);
      nerdToggleBtn.onclick = () => setNerd(!nerdOn);
      copyBtn.disabled = true;
      // Camera: smooth, mouse-biased, no manual control
      let camX = 0,
        camY = 0; // top-left of viewport in world space
      const zoom = 2.4; // hotline-miami style: a bit more zoomed-in
      const mouseBias = 110; // world px to bias toward aim
      const camLerpBase = 0.05; // smoothing factor per frame higher = faster

      let inputIv = null;
      let sendNeutralHandler = null;
      let visHandler = null;

      let pingIv = null;
      let latency = null;
      let stateMsgCount = 0;
      let statesPerSec = 0;
      let lastStateRateAt = performance.now();
      async function boot() {
        if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;
        roomId = await create();
        const url = `${location.origin}/join.html?room=${roomId}`;
        link.value = url;
        copyBtn.disabled = false;
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(url);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        };

        ws = connect(roomId);
        ws.addEventListener("open", () => {
          status.textContent = "connected";
          status.dataset.state = "connected";
          document.body.classList.add("connected");
          const name = nameStorage().get() || "Marine";
          ws.send(
            JSON.stringify({ type: "join_room", role: "streamer", name })
          );
          newBtn.textContent = "End Session";
          toggleChatBtn.disabled = false;
        });
        latency = createLatencyMonitor(ws);
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        pingIv = setInterval(() => {
          try {
            latency.sendPing();
          } catch {}
        }, 1000);

        ws.addEventListener("message", (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === "map") {
            try {
              const m = msg.map;
              const bin = atob(m.tilesBase64);
              const u8 = new Uint8Array(bin.length);
              for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
              gameMap = {
                w: m.w,
                h: m.h,
                size: m.size,
                theme: m.theme,
                tiles: u8,
                props: m.props || [],
                lights: m.lights || [],
              };
            } catch {}
          }
          if (msg.type === "joined") {
            playerId = msg.playerId;
            arena = msg.arena;
          }
          if (msg.type === "state") {
            stateMsgCount++;
            // detect removed bullets for small impact effect
            const curMap = new Map(
              msg.bullets.map((b) => [b.id, { x: b.x, y: b.y }])
            );
            for (const [id, pos] of prevBulletPos) {
              if (!curMap.has(id)) {
                effects.push({ x: pos.x, y: pos.y, ttl: 220 });
                shake += 2;
              }
            }
            prevBulletPos = curMap;

            state = msg;
            const me = msg.players.find((p) => p.id === playerId);
            if (me) {
              scoreEl.textContent = me.score;
              bankedEl.textContent = me.banked ?? 0;
              hpEl.textContent = me.hp ?? 0;
              const w = me.weapon || "pistol";
              weaponEl.textContent = w;
              let ammo = 0;
              if (w === "pistol") ammo = me.pistolAmmo ?? 0;
              else if (w === "smg") ammo = me.smgAmmo ?? 0;
              else if (w === "shotgun") ammo = me.shotgunAmmo ?? 0;
              else ammo = 0;
              ammoEl.textContent = ammo;
              // Ownership inference
              const hasSmg = (me.smgAmmo ?? 0) > 0 || w === "smg";
              const hasShotgun = (me.shotgunAmmo ?? 0) > 0 || w === "shotgun";
              // Button states
              if (btnPistol) {
                btnPistol.classList.toggle("equipped", w === "pistol");
                btnPistol.classList.add("owned");
              }
              if (btnSmg) {
                btnSmg.classList.toggle("equipped", w === "smg");
                btnSmg.classList.toggle("owned", hasSmg);
                btnSmg.classList.toggle("locked", !hasSmg);
              }
              if (btnShotgun) {
                btnShotgun.classList.toggle("equipped", w === "shotgun");
                btnShotgun.classList.toggle("owned", hasShotgun);
                btnShotgun.classList.toggle("locked", !hasShotgun);
              }
              // Enable/disable shotgun purchase
              if (buyShotgunBtn) {
                const canBuy = (me.banked || 0) >= 300 && !hasShotgun;
                buyShotgunBtn.disabled = !canBuy;
                buyShotgunBtn.textContent = "Unlock Shotgun (4) • 300";
                buyShotgunBtn.title = canBuy
                  ? "Press 4 to purchase"
                  : "Need 300 banked or already unlocked";
              }
              // Enable/disable SMG purchase
              if (buySmgBtn) {
                const canBuySmg = (me.banked || 0) >= 300 && !hasSmg;
                buySmgBtn.disabled = !canBuySmg;
                buySmgBtn.textContent = "Unlock SMG (5) • 300";
                buySmgBtn.title = canBuySmg
                  ? "Press 5 to purchase"
                  : "Need 300 banked or already unlocked";
              }
            }
            const ping = Math.max(0, Date.now() - (msg.t || Date.now()));
            status.textContent = `connected • ${ping} ms • players: ${msg.players.length}`;
            status.dataset.state = "connected";
            state.remainingTime = msg.remainingTime;
            updateTimer(state.remainingTime);
            updatePlayerList(msg.players);
            // Update chat toggle button label from state
            if (typeof msg.chatEnabled === "boolean") {
              toggleChatBtn.textContent = msg.chatEnabled
                ? "Disable Chat"
                : "Enable Chat";
              // Hide chat card and disable input when chat is disabled
              chatInput.disabled = !msg.chatEnabled;
              chatInput.placeholder = msg.chatEnabled
                ? "Chat..."
                : "Chat disabled by streamer";
              const chatCard = chatMessagesEl.closest(".card");
              if (chatCard)
                chatCard.classList.toggle("hidden", !msg.chatEnabled);
            }
            if (me && (me.hp ?? 0) < lastHp) {
              flash();
            }
            lastScore = me ? me.score : lastScore;
            lastHp = me ? me.hp ?? lastHp : lastHp;
            lastStateTime = performance.now();
          }
          if (msg.type === "pong") {
            if (latency) latency.handlePong(Number(msg.timestamp) || 0);
          }
          if (msg.type === "chat") {
            appendChat(msg.from, msg.message);
          }
          if (msg.type === "notice") {
            try {
              toast(msg.message);
            } catch {}
            appendChat("System", msg.message);
          }
        });
        inputIv = setInterval(() => {
          if (ws && ws.readyState === 1) {
            // Convert screen aim to world coordinates via camera + zoom
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: input.up,
                down: input.down,
                left: input.left,
                right: input.right,
                shoot: input.shoot,
                melee: input.melee,
                dash: input.dash,
                aimX: aimWX,
                aimY: aimWY,
              })
            );

            // Spawn a local muzzle flash near the player's muzzle for immediate feedback
            const meNow = state.players.find((p) => p.id === playerId);
            if (meNow) {
              const now = performance.now();
              const wantFlash =
                input.shoot && (!prevShoot || now - lastMuzzleAt > 110);
              if (wantFlash) {
                const dx = aimWX - meNow.x;
                const dy = aimWY - meNow.y;
                const d = Math.hypot(dx, dy) || 1;
                const muzzleOffset = 16; // distance from player center to muzzle
                const fx = meNow.x + (dx / d) * muzzleOffset;
                const fy = meNow.y + (dy / d) * muzzleOffset;
                muzzleFlashes.push({ x: fx, y: fy, ttl: 90 });
                lastMuzzleAt = now;
              }
              prevShoot = input.shoot;
            }
          }
        }, 50);

        // If focus is lost, immediately send a neutral input (interval covers it, but faster feedback helps)
        sendNeutralHandler = () => {
          if (ws && ws.readyState === 1) {
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: false,
                down: false,
                left: false,
                right: false,
                shoot: false,
                melee: false,
                dash: false,
                aimX: aimWX,
                aimY: aimWY,
              })
            );
          }
        };
        visHandler = () => {
          if (document.hidden) sendNeutralHandler();
        };
        window.addEventListener("blur", sendNeutralHandler);
        document.addEventListener("visibilitychange", visHandler);

        const onClose = () => {
          leaveRoom(false);
        };
        ws.addEventListener("close", onClose, { once: true });
      }

      function leaveRoom(manual = true) {
        if (inputIv) {
          clearInterval(inputIv);
          inputIv = null;
        }
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        if (sendNeutralHandler) {
          window.removeEventListener("blur", sendNeutralHandler);
          sendNeutralHandler = null;
        }
        if (visHandler) {
          document.removeEventListener("visibilitychange", visHandler);
          visHandler = null;
        }
        if (ws) {
          try {
            if (manual && ws.readyState === 1) ws.close(1000, "leave");
          } catch {}
          ws = null;
        }
        status.textContent = "disconnected";
        status.dataset.state = "disconnected";
        document.body.classList.remove("connected");
        newBtn.textContent = "Create Room";
        copyBtn.disabled = true;
        link.value = "";
        toggleChatBtn.disabled = true;
        toggleChatBtn.textContent = "Disable Chat";
        playerId = null;
        prevBulletPos = new Map();
        effects.length = 0;
        muzzleFlashes.length = 0;
        lastScore = 0;
        lastHp = 100;
        state = { players: [], bullets: [], arena };
        updatePlayerList([]);
      }

      // Smoothing map for positions (reduces 20Hz stutter)
      const smooth = new Map(); // id -> {x,y}
      const SMOOTH_TAU = 90; // ms time constant
      function getSmoothedPos(id, tx, ty, dt) {
        let s = smooth.get(id);
        if (!s) {
          s = { x: tx, y: ty };
          smooth.set(id, s);
          return { x: tx, y: ty };
        }
        const alpha = 1 - Math.exp(-dt / Math.max(1, SMOOTH_TAU));
        s.x += (tx - s.x) * alpha;
        s.y += (ty - s.y) * alpha;
        return { x: s.x, y: s.y };
      }

      function draw(dt = 16) {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const rect = c.getBoundingClientRect();
        // Reset and clear in device pixels
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, c.width, c.height);
        // Base transform to CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // Fill background with dungeon-themed dark color in CSS px
        ctx.fillStyle = "#0a0c0f";
        ctx.fillRect(0, 0, rect.width, rect.height);
        // Update camera target (follow player with slight mouse bias)
        const meRawForCam = state.players.find((p) => p.id === playerId);
        const meCam = meRawForCam
          ? getSmoothedPos(meRawForCam.id, meRawForCam.x, meRawForCam.y, dt)
          : null;
        if (meCam) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          const dx = aimWX - meCam.x,
            dy = aimWY - meCam.y;
          const d = Math.hypot(dx, dy) || 1;
          const offX = (dx / d) * mouseBias,
            offY = (dy / d) * mouseBias;
          const viewW = rect.width / zoom,
            viewH = rect.height / zoom;
          const targetX = Math.min(
            Math.max(0, meCam.x + offX - viewW / 2),
            Math.max(0, arena.w - viewW)
          );
          const targetY = Math.min(
            Math.max(0, meCam.y + offY - viewH / 2),
            Math.max(0, arena.h - viewH)
          );
          const k = Math.min(1, (dt / 16) * camLerpBase);
          camX = camX + (targetX - camX) * k;
          camY = camY + (targetY - camY) * k;
        }
        // Begin world transform
        ctx.save();
        ctx.scale(zoom, zoom);
        // Screen shake
        const sAmt = Math.max(0, shake);
        shake = Math.max(0, shake * 0.9 - 0.2);
        const sdx = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        const sdy = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        ctx.translate(-camX + sdx, -camY + sdy);
        // Tile layer
        if (gameMap)
          drawTiles(camX, camY, rect.width / zoom, rect.height / zoom);
        // Walls/rooms
        if (state.walls) {
          ctx.fillStyle = "#2a2f36";
          for (const w of state.walls) {
            ctx.fillRect(w.x, w.y, w.w, w.h);
          }
        }
        // Extractions removed
        // Pickups
        if (state.pickups) {
          for (const pk of state.pickups) {
            ctx.save();
            ctx.shadowColor = "rgba(255,255,255,.16)";
            ctx.shadowBlur = 8;
            if (pk.type === "health") {
              ctx.strokeStyle = "#66bb6a";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 8, 16, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x + 6, pk.y);
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "speed") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x - 5, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x - 2, pk.y - 2);
              ctx.lineTo(pk.x + 5, pk.y + 8);
              ctx.stroke();
            } else if (pk.type === "ammo") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 7, pk.y - 5, 14, 10);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y + 1);
              ctx.lineTo(pk.x - 4, pk.y - 1);
              ctx.moveTo(pk.x, pk.y + 1);
              ctx.lineTo(pk.x, pk.y - 1);
              ctx.moveTo(pk.x + 4, pk.y + 1);
              ctx.lineTo(pk.x + 4, pk.y - 1);
              ctx.stroke();
            } else if (pk.type === "weapon") {
              ctx.strokeStyle = "#ffa726";
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x - 6, pk.y);
              ctx.stroke();
            } else if (pk.type === "shield") {
              ctx.strokeStyle = "#26c6da";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 9, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "magnet") {
              ctx.strokeStyle = "#ab47bc";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x - 3, pk.y, 6, -Math.PI / 2, Math.PI / 2);
              ctx.arc(pk.x + 3, pk.y, 6, Math.PI / 2, -Math.PI / 2);
              ctx.stroke();
            } else if (pk.type === "freeze") {
              ctx.strokeStyle = "#90caf9";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x, pk.y + 7);
              ctx.moveTo(pk.x - 7, pk.y);
              ctx.lineTo(pk.x + 7, pk.y);
              ctx.moveTo(pk.x - 5, pk.y - 5);
              ctx.lineTo(pk.x + 5, pk.y + 5);
              ctx.moveTo(pk.x - 5, pk.y + 5);
              ctx.lineTo(pk.x + 5, pk.y - 5);
              ctx.stroke();
            } else if (pk.type === "blast") {
              ctx.strokeStyle = "#ff7043";
              ctx.lineWidth = 2;
              for (let i = 0; i < 8; i++) {
                const a = (i * Math.PI) / 4;
                ctx.beginPath();
                ctx.moveTo(pk.x + Math.cos(a) * 3, pk.y + Math.sin(a) * 3);
                ctx.lineTo(pk.x + Math.cos(a) * 10, pk.y + Math.sin(a) * 10);
                ctx.stroke();
              }
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 3, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "treasure") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x, pk.y + 1, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "coin") {
              ctx.strokeStyle = "#ffc107";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 6, 0, Math.PI * 2);
              ctx.stroke();
              ctx.fillStyle = "#ffc107";
              ctx.globalAlpha = 0.3;
              ctx.fill();
            } else if (pk.type === "gem") {
              ctx.strokeStyle = "#e91e63";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x - 5, pk.y - 2);
              ctx.lineTo(pk.x - 3, pk.y + 7);
              ctx.lineTo(pk.x + 3, pk.y + 7);
              ctx.lineTo(pk.x + 5, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "crystal") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#9c27b0";
              ctx.shadowBlur = 6;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x - 4, pk.y - 2);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.lineTo(pk.x + 4, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "orb") {
              ctx.strokeStyle = "#2196f3";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#2196f3";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 7, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x - 2, pk.y - 2, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "relic") {
              ctx.strokeStyle = "#795548";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#795548";
              ctx.shadowBlur = 6;
              ctx.strokeRect(pk.x - 6, pk.y - 8, 12, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y - 4);
              ctx.moveTo(pk.x - 2, pk.y);
              ctx.lineTo(pk.x + 2, pk.y);
              ctx.stroke();
            } else if (pk.type === "artifact") {
              ctx.strokeStyle = "#607d8b";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#607d8b";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y - 2, 6, 0, Math.PI);
              ctx.stroke();
              ctx.strokeRect(pk.x - 4, pk.y - 2, 8, 8);
            } else if (pk.type === "medallion") {
              ctx.strokeStyle = "#ff9800";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#ff9800";
              ctx.shadowBlur = 10;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 8, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.moveTo(pk.x + 4, pk.y - 4);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.stroke();
            } else if (pk.type === "scroll") {
              ctx.strokeStyle = "#8bc34a";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#8bc34a";
              ctx.shadowBlur = 12;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y - 2);
              ctx.lineTo(pk.x + 6, pk.y - 2);
              ctx.moveTo(pk.x - 6, pk.y + 2);
              ctx.lineTo(pk.x + 6, pk.y + 2);
              ctx.stroke();
            } else if (pk.type === "crown") {
              ctx.strokeStyle = "#ffd700";
              ctx.lineWidth = 4;
              ctx.shadowColor = "#ffd700";
              ctx.shadowBlur = 15;
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y + 4);
              ctx.lineTo(pk.x - 4, pk.y - 6);
              ctx.lineTo(pk.x - 2, pk.y + 2);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x + 4, pk.y - 6);
              ctx.lineTo(pk.x + 8, pk.y + 4);
              ctx.lineTo(pk.x - 8, pk.y + 4);
              ctx.stroke();
            }
            // label under pickup
            ctx.font =
              "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.fillStyle = "#cfd8dc";
            ctx.globalAlpha = 0.95;
            const labelMap = {
              health: "HEALTH",
              speed: "SPEED",
              ammo: "AMMO",
              weapon: "WEAPON",
              shield: "SHIELD",
              magnet: "MAGNET",
              freeze: "FREEZE",
              blast: "BLAST",
              treasure: "TREASURE",
              key: "KEY",
              coin: "COIN (10)",
              gem: "GEM (25)",
              crystal: "CRYSTAL (50)",
              orb: "ORB (75)",
              relic: "RELIC (100)",
              artifact: "ARTIFACT (150)",
              medallion: "MEDALLION (250)",
              scroll: "SCROLL (400)",
              crown: "CROWN (1000)",
            };
            const lbl = labelMap[pk.type] || String(pk.type).toUpperCase();
            if (lbl) ctx.fillText(lbl, pk.x, pk.y + 14);
            ctx.restore();
          }
          ctx.lineWidth = 1;
        }
        // Bullets
        ctx.fillStyle = "#ffd54f";
        for (const b of state.bullets) {
          ctx.save();
          ctx.shadowColor = "rgba(255,213,79,.6)";
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        // Spitter globs (enemy projectiles)
        if (state.globs) {
          ctx.fillStyle = "#ce93d8";
          for (const g of state.globs) {
            ctx.save();
            ctx.shadowColor = "rgba(206,147,216,.6)";
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(g.x, g.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }
        // Bullet impact effects
        for (let i = effects.length - 1; i >= 0; i--) {
          const e = effects[i];
          e.ttl -= dt;
          if (e.ttl <= 0) {
            effects.splice(i, 1);
            continue;
          }
          ctx.save();
          const a = Math.max(0, e.ttl / 220);
          ctx.globalAlpha = a;
          ctx.strokeStyle = "#ffd54f";
          ctx.beginPath();
          ctx.arc(e.x, e.y, (1 - a) * 12 + 2, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        // AI Zombies
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            ctx.save();
            
            // Main zombie body
            ctx.fillStyle = "#ef5350";
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Class outline
            if (zombie.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (zombie.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (zombie.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else {
              ctx.strokeStyle = "#e57373";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, zombie.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            
            // State indicator
            if (zombie.state === "chasing") {
              ctx.strokeStyle = "#ff5722";
              ctx.lineWidth = 2;
              ctx.globalAlpha = 0.8;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 18, 0, Math.PI * 2);
              ctx.stroke();
            } else if (zombie.state === "attacking") {
              ctx.strokeStyle = "#d32f2f";
              ctx.lineWidth = 3;
              ctx.globalAlpha = 1;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 20, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Detection range indicator (when idle or chasing)
            if (zombie.state !== "attacking") {
              ctx.strokeStyle = "rgba(255, 87, 34, 0.15)";
              ctx.lineWidth = 1;
              ctx.globalAlpha = 0.3;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, zombie.detectionRange, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // HP bar
            const barWidth = 24;
            const barHeight = 4;
            const barX = zombie.x - barWidth / 2;
            const barY = zombie.y - 20;
            const hpRatio = zombie.hp / zombie.maxHp;
            
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = hpRatio > 0.6 ? "#4caf50" : hpRatio > 0.3 ? "#ff9800" : "#f44336";
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
            
            // Name/class label
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.font = "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(`AI ${zombie.zClass}`, zombie.x, zombie.y + 25);
            
            ctx.restore();
          }
        }

        // Players
        ctx.font =
          "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.textAlign = "center";
        let me = state.players.find((p) => p.id === playerId);
        // Detect local melee edge and record for immediate visuals
        if (me) {
          if (input.melee && !prevMelee) {
            const aimWX_forMelee = camX + input.aimX / zoom;
            const aimWY_forMelee = camY + input.aimY / zoom;
            const dx = aimWX_forMelee - me.x,
              dy = aimWY_forMelee - me.y;
            const d = Math.hypot(dx, dy) || 1;
            localMeleeDirX = dx / d;
            localMeleeDirY = dy / d;
            localMeleeAt = performance.now();
          }
          prevMelee = input.melee;
        }
        // Update and draw dash trails (under players)
        const nowT = performance.now();
        if (state.players) {
          for (const p of state.players) {
            const sp = getSmoothedPos(p.id, p.x, p.y, 0); // position for trail sampling
            let arr = trails.get(p.id) || [];
            // Append when dashing
            if (p.dashing) {
              arr.push({ x: sp.x, y: sp.y, t: nowT });
              if (arr.length > TRAIL_MAX) arr.shift();
            }
            // Prune old
            arr = arr.filter((pt) => nowT - pt.t <= TRAIL_TTL);
            trails.set(p.id, arr);
            // Draw trail
            if (arr.length >= 2) {
              for (let i = 0; i < arr.length; i++) {
                const age = nowT - arr[i].t;
                const a = Math.max(0, 1 - age / TRAIL_TTL);
                const r = 6 + 10 * a;
                ctx.save();
                // teal-ish trail with soft glow
                ctx.globalAlpha = 0.25 + 0.45 * a;
                ctx.fillStyle = "rgba(158,241,209,1)";
                ctx.shadowColor = "rgba(158,241,209,.8)";
                ctx.shadowBlur = 14 * a;
                ctx.beginPath();
                ctx.arc(arr[i].x, arr[i].y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              }
            }
          }
        }

        for (const p of state.players) {
          const sp = getSmoothedPos(p.id, p.x, p.y, dt);
          ctx.save();
          if (p.role === "streamer") {
            ctx.strokeStyle = "#4caf50";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 10, 0, Math.PI * 2);
            ctx.stroke();
            if (p.weaponed) {
              ctx.strokeStyle = "#ffa726";
              ctx.globalAlpha = 0.6;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 14, 0, Math.PI * 2);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }
            ctx.fillStyle = "#4caf50";
            ctx.globalAlpha = 0.95;
            ctx.fillText(p.name, sp.x, sp.y - 16);
          } else {
            ctx.fillStyle = p.alive ? "#ef5350" : "rgba(239,83,80,.25)";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 12, 0, Math.PI * 2);
            ctx.fill();
            // Class outline
            if (p.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (p.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (p.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else {
              ctx.strokeStyle = "#e57373";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, p.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            if (p.boosted) {
              ctx.strokeStyle = "#64b5f6";
              ctx.globalAlpha = 0.7;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 16, 0, Math.PI * 2);
              ctx.stroke();
            }
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.fillText(p.name, sp.x, sp.y - 16);
            // Emote above zombie head for 5s
            if (p.emote && (p.emoteUntil || 0) > Date.now()) {
              ctx.font =
                "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
              ctx.globalAlpha = 1;
              ctx.fillText(p.emote, sp.x, sp.y - 32);
              ctx.font =
                "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            }
          }
          // Bat swing arc visual (short-lived)
          const swingAge = (state.t || Date.now()) - (p.meleeAt || 0);
          if (swingAge >= 0 && swingAge < 220) {
            const alpha = 1 - swingAge / 220;
            const ang = Math.atan2(p.meleeDirY || 0, p.meleeDirX || 1);
            const span = Math.PI / 1.8; // ~100Â°
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              sp.x + Math.cos(ang - span / 2) * r0,
              sp.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              sp.x + Math.cos(ang + span / 2) * r0,
              sp.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
          ctx.restore();
        }

        // Crosshair for local player (world coordinates)
        me = state.players.find((p) => p.id === playerId);
        if (me) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,.5)";
          ctx.beginPath();
          ctx.arc(aimWX, aimWY, 6, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(aimWX - 8, aimWY);
          ctx.lineTo(aimWX + 8, aimWY);
          ctx.moveTo(aimWX, aimWY - 8);
          ctx.lineTo(aimWX, aimWY + 8);
          ctx.stroke();
          ctx.restore();
          // Muzzle flashes rendering
          for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
            const mf = muzzleFlashes[i];
            mf.ttl -= dt;
            if (mf.ttl <= 0) {
              muzzleFlashes.splice(i, 1);
              continue;
            }
            const a = Math.max(0, mf.ttl / 90);
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            ctx.globalAlpha = a;
            const g = ctx.createRadialGradient(mf.x, mf.y, 0, mf.x, mf.y, 18);
            g.addColorStop(0, "rgba(255,220,160,0.9)");
            g.addColorStop(1, "rgba(255,220,160,0)");
            ctx.fillStyle = g;
            ctx.fillRect(mf.x - 20, mf.y - 20, 40, 40);
            ctx.restore();
          }

          // Local predicted bat swing arc so streamer sees swing instantly
          const age = performance.now() - localMeleeAt;
          if (age >= 0 && age < 220) {
            const alpha = 1 - age / 220;
            const ang = Math.atan2(localMeleeDirY, localMeleeDirX);
            const span = Math.PI / 1.8; // ~100Â°
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }

          // Also render server-synced swing for local player (fallback)
          const swingAgeSrv = (state.t || Date.now()) - (me.meleeAt || 0);
          if (swingAgeSrv >= 0 && swingAgeSrv < 220) {
            const alpha = 1 - swingAgeSrv / 220;
            const ang = Math.atan2(me.meleeDirY || 0, me.meleeDirX || 1);
            const span = Math.PI / 1.8;
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
        }

        // End world transform
        // Darkness/lighting overlay in world space
        drawLighting(camX, camY, rect.width / zoom, rect.height / zoom);
        ctx.restore();

        // In-game HUD (top-right): Score, Ammo
        const meHud = state.players.find((p) => p.id === playerId);
        const weapon = (meHud && (meHud.weapon || "pistol")) || "pistol";
        let ammo = 0;
        if (meHud) {
          if (weapon === "pistol") ammo = meHud.pistolAmmo || 0;
          else if (weapon === "smg") ammo = meHud.smgAmmo || 0;
          else if (weapon === "shotgun") ammo = meHud.shotgunAmmo || 0;
        }
        const hudLines = [`Score: ${meHud ? meHud.score : 0}  Banked: ${meHud ? meHud.banked : 0}`];
        const pad = 8;
        const lineH = 16;
        const boxW = 220;
        const boxH = pad * 2 + hudLines.length * lineH;
        const x0 = rect.width - boxW - 12;
        const y0 = 12;
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(18,20,24,.86)";
        ctx.strokeStyle = "rgba(255,255,255,.08)";
        ctx.lineWidth = 1.5;
        roundRect(ctx, x0, y0, boxW, boxH, 10, true, true);
        ctx.fillStyle = "#cfd8dc";
        ctx.font =
          "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        for (let i = 0; i < hudLines.length; i++) {
          ctx.fillText(hudLines[i], x0 + 10, y0 + pad + (i + 1) * lineH - 4);
        }
        ctx.restore();

        // Dash cooldown indicator (bottom-center) — doubled size
        if (meHud) {
          const readyAt = meHud.dashReadyAt || 0;
          const lastAt = meHud.lastDashAt || 0;
          const nowMs = Date.now();
          const total = Math.max(1, readyAt - lastAt);
          const remain = Math.max(0, readyAt - nowMs);
          const frac = 1 - Math.min(1, remain / total);
          const meterPad = 24; // padding from bottom
          const r2 = 24; // doubled radius
          const cx2 = rect.width / 2;
          const cy2 = rect.height - meterPad - 52; // push up to fit bigger meter
          ctx.save();
          // backdrop behind the meter
          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(18,20,24,.86)";
          ctx.strokeStyle = "rgba(255,255,255,.08)";
          ctx.lineWidth = 2;
          roundRect(ctx, cx2 - 52, cy2 - 52, 104, 110, 28, true, true);
          // background circle
          ctx.beginPath();
          ctx.strokeStyle = "rgba(255,255,255,.18)";
          ctx.lineWidth = 6;
          ctx.arc(cx2, cy2, r2, 0, Math.PI * 2);
          ctx.stroke();
          // progress arc
          ctx.beginPath();
          ctx.strokeStyle = remain <= 0 ? "#2dd4bf" : "#90caf9";
          ctx.lineWidth = 7;
          ctx.arc(
            cx2,
            cy2,
            r2,
            -Math.PI / 2,
            -Math.PI / 2 + Math.PI * 2 * frac
          );
          ctx.stroke();
          // label below meter
          ctx.fillStyle = "#cfd8dc";
          ctx.font =
            "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Dash", cx2, cy2 + 48);
          ctx.restore();
        }

        // Weapon/Ammo (bottom-left) — doubled size
        if (meHud) {
          const padBL = 12;
          const boxW2 = 340,
            boxH2 = 80;
          const xBL = padBL,
            yBL = rect.height - boxH2 - padBL;
          ctx.save();
          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(18,20,24,.86)";
          ctx.strokeStyle = "rgba(255,255,255,.08)";
          ctx.lineWidth = 2;
          roundRect(ctx, xBL, yBL, boxW2, boxH2, 24, true, true);
          ctx.fillStyle = "#cfd8dc";
          ctx.font =
            "20px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
          ctx.fillText(`Weapon: ${weapon}`, xBL + 20, yBL + 32);
          ctx.fillText(`Ammo: ${ammo}`, xBL + 20, yBL + 64);
          ctx.restore();
        }

        // Mini-map (bottom-right, circular)
        drawMiniMap();

        // Class legend (bottom-right above minimap)
        drawClassLegend();

        // AI Zombie legend (top-left)
        drawAIZombieLegend();

        // Screen-space border overlay
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#808080";
        ctx.strokeRect(1, 1, rect.width - 2, rect.height - 2);
      }

      // small util for rounded rects on HUD
      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (typeof r === "number") r = { tl: r, tr: r, br: r, bl: r };
        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        ctx.quadraticCurveTo(x, y, x + r.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      function drawMiniMap() {
        const rect = c.getBoundingClientRect();
        const mmSize = 160;
        const pad = 12;
        const cx = rect.width - pad - mmSize / 2;
        const cy = rect.height - pad - mmSize / 2;
        const R = mmSize / 2 - 4;
        const W = (state.arena && state.arena.w) || 960;
        const H = (state.arena && state.arena.h) || 540;
        // Zoom in a bit and center around the local player if available
        const meMM =
          state.players && state.players.find((p) => p.id === playerId);
        const centerX = meMM ? meMM.x : W / 2;
        const centerY = meMM ? meMM.y : H / 2;
        const MM_ZOOM = 1.6; // >1 zooms in
        const scale = (2 * R * MM_ZOOM) / Math.max(W, H);
        // frame
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(18,20,24,.86)";
        ctx.beginPath();
        ctx.arc(cx, cy, mmSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.08)";
        ctx.lineWidth = 2;
        ctx.stroke();
        // clip to circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, Math.PI * 2);
        ctx.clip();
        // walls
        if (state.walls) {
          ctx.strokeStyle = "rgba(255,255,255,.25)";
          ctx.lineWidth = 1;
          for (const w of state.walls) {
            const x = cx + (w.x - centerX) * scale;
            const y = cy + (w.y - centerY) * scale;
            const ww = w.w * scale;
            const hh = w.h * scale;
            ctx.strokeRect(x, y, ww, hh);
          }
        }
        // extractions removed
        // players
        if (state.players) {
          for (const p of state.players) {
            const px = cx + (p.x - centerX) * scale;
            const py = cy + (p.y - centerY) * scale;
            const r = p.role === "streamer" ? 3 : 2;
            ctx.beginPath();
            ctx.fillStyle =
              p.role === "streamer"
                ? "#4caf50"
                : p.alive
                ? "#ef5350"
                : "rgba(239,83,80,.4)";
            ctx.arc(px, py, r, 0, Math.PI * 2);
            ctx.fill();
            if (p.id === playerId) {
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        
        // AI zombies on minimap
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            const px = cx + (zombie.x - centerX) * scale;
            const py = cy + (zombie.y - centerY) * scale;
            ctx.beginPath();
            ctx.fillStyle = zombie.state === "chasing" ? "#ff5722" : zombie.state === "attacking" ? "#d32f2f" : "#ef5350";
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Small state indicator
            if (zombie.state === "chasing" || zombie.state === "attacking") {
              ctx.strokeStyle = zombie.state === "attacking" ? "#d32f2f" : "#ff5722";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        ctx.restore(); // unclip
        ctx.restore();
      }

      function drawTiles(viewX, viewY, viewW, viewH) {
        const m = gameMap;
        if (!m) return;
        const sz = m.size;
        const theme = m.theme || "dungeon";
        const pal =
          theme === "dungeon"
            ? {
                floor: "#0e1115",
                wall: "#2a2f36",
                pit: "#0b0d11",
                water: "#0d1b2a",
                edge: "#9aa4b2",
                propCrate: "#6d4c41",
                propPillar: "#b0bec5",
                propBone: "#8d6e63",
              }
            : theme === "cave"
            ? {
                floor: "#0d1113",
                wall: "#263238",
                pit: "#0a0e10",
                water: "#0b1f2d",
                edge: "#90a4ae",
                propCrate: "#546e7a",
                propPillar: "#90caf9",
                propBone: "#80cbc4",
              }
            : {
                floor: "#111416",
                wall: "#3c4148",
                pit: "#0b0c0d",
                water: "#14212e",
                edge: "#b0bec5",
                propCrate: "#90a4ae",
                propPillar: "#cfd8dc",
                propBone: "#b0bec5",
              };
        const sx = Math.max(0, Math.floor(viewX / sz) - 1),
          sy = Math.max(0, Math.floor(viewY / sz) - 1);
        const ex = Math.min(m.w - 1, Math.ceil((viewX + viewW) / sz) + 1),
          ey = Math.min(m.h - 1, Math.ceil((viewY + viewH) / sz) + 1);
        // Floor
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 0) {
              // floor
              ctx.fillStyle = pal.floor;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Pits/Water
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 2) {
              ctx.fillStyle = pal.pit;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
            if (id === 3) {
              ctx.fillStyle = pal.water;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Walls autotile outline
        const isWall = (ix, iy) =>
          ix >= 0 &&
          iy >= 0 &&
          ix < m.w &&
          iy < m.h &&
          m.tiles[iy * m.w + ix] === 1;
        ctx.fillStyle = pal.wall;
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            if (!isWall(x, y)) continue;
            const px = x * sz,
              py = y * sz;
            ctx.fillRect(px, py, sz, sz);
            ctx.strokeStyle = pal.edge;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.15;
            if (!isWall(x, y - 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px + sz, py);
              ctx.stroke();
            }
            if (!isWall(x + 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px + sz, py);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x, y + 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py + sz);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x - 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px, py + sz);
              ctx.stroke();
            }
            ctx.globalAlpha = 1;
          }
        }
        // Props
        for (const p of m.props || []) {
          const px = p.x * sz,
            py = p.y * sz;
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle =
            p.type === "crate"
              ? pal.propCrate
              : p.type === "pillar"
              ? pal.propPillar
              : pal.propBone;
          ctx.fillRect(px + 4, py + 4, sz - 8, sz - 8);
          ctx.restore();
        }
        // Lights (simple ambient blit)
        for (const l of m.lights || []) {
          const cx = l.x * sz + sz / 2,
            cy = l.y * sz + sz / 2;
          const rr = l.r * sz;
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rr);
          g.addColorStop(0, `rgba(255,255,200,${0.35 * l.a})`);
          g.addColorStop(1, "rgba(255,255,200,0)");
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = g;
          ctx.fillRect(cx - rr, cy - rr, rr * 2, rr * 2);
          ctx.restore();
        }
      }

      function drawClassLegend() {
        const rect = c.getBoundingClientRect();
        const pad = 12;
        const boxW = 160,
          boxH = 70;
        const x = rect.width - boxW - pad;
        const y = rect.height - 160 - boxH - pad;
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(18,20,24,.86)";
        ctx.strokeStyle = "rgba(255,255,255,.08)";
        ctx.lineWidth = 1.5;
        roundRect(ctx, x, y, boxW, boxH, 10, true, true);
        ctx.font =
          "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillStyle = "#cfd8dc";
        const rows = [
          { label: "Runner", color: "#64b5f6", lw: 1.5 },
          { label: "Brute", color: "#ffa726", lw: 3 },
          { label: "Spitter", color: "#ba68c8", lw: 2 },
        ];
        let yy = y + 18;
        for (const r of rows) {
          ctx.save();
          ctx.strokeStyle = r.color;
          ctx.lineWidth = r.lw;
          ctx.beginPath();
          ctx.arc(x + 14, yy - 4, 6, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
          ctx.fillText(r.label, x + 28, yy - 2);
          yy += 22;
        }
        ctx.restore();
      }

      function drawAIZombieLegend() {
        const rect = c.getBoundingClientRect();
        const pad = 12;
        const boxW = 180,
          boxH = 90;
        const x = pad;
        const y = pad + 60; // Below the HUD
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(18,20,24,.86)";
        ctx.strokeStyle = "rgba(255,255,255,.08)";
        ctx.lineWidth = 1.5;
        roundRect(ctx, x, y, boxW, boxH, 10, true, true);
        ctx.font =
          "11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillStyle = "#cfd8dc";
        ctx.textAlign = "left";
        
        // Title
        ctx.fillText("AI Zombies", x + 10, y + 16);
        
        const states = [
          { label: "Idle", color: "#ef5350", desc: "Patrolling" },
          { label: "Chasing", color: "#ff5722", desc: "Pursuing player" },
          { label: "Attacking", color: "#d32f2f", desc: "In combat" },
        ];
        
        let yy = y + 32;
        for (const s of states) {
          ctx.save();
          ctx.fillStyle = s.color;
          ctx.beginPath();
          ctx.arc(x + 12, yy - 2, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          ctx.fillText(`${s.label}: ${s.desc}`, x + 22, yy);
          yy += 16;
        }
        
        ctx.restore();
      }
      function drawLighting(viewX, viewY, viewW, viewH) {
        // Lighting system temporarily disabled to remove dots
        return;
      }

      function updatePlayerList(players) {
        playersEl.innerHTML = players
          .map(
            (p) =>
              `<span class="pill ${p.role}">${
                p.role === "streamer" ? "🟢" : "🧟"
              } ${p.name}${p.role === "streamer" ? " · " + p.score : ""}</span>`
          )
          .join(" ");
      }

      function flash() {
        flashEl.classList.add("show");
        setTimeout(() => flashEl.classList.remove("show"), 150);
      }

      function updateTimer(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = seconds % 60;
        timerEl.textContent = `Time: ${min}:${sec.toString().padStart(2, "0")}`;
      }

      function appendChat(from, message) {
        chatMessagesEl.innerHTML += `<div>${from}: ${message}</div>`;
        while (chatMessagesEl.children.length > 10) {
          chatMessagesEl.removeChild(chatMessagesEl.firstChild);
        }
      }

      function sendChat(msg) {
        if (ws && ws.readyState === 1)
          ws.send(JSON.stringify({ type: "chat", message: msg }));
      }

      // Animation loop for effects and smoother visuals
      let last = performance.now();
      const fpsSamples = [];
      const fpsWindow = 120; // ~2s at 60fps
      let lastNerdUpdate = 0;
      lastHp = 100;
      function loop() {
        const now = performance.now();
        const dt = now - last;
        last = now;
        draw(dt);
        // FPS tracking
        const fps = dt > 0 ? 1000 / dt : 0;
        fpsSamples.push(fps);
        if (fpsSamples.length > fpsWindow) fpsSamples.shift();
        // State messages per second
        if (now - lastStateRateAt >= 1000) {
          statesPerSec = stateMsgCount;
          stateMsgCount = 0;
          lastStateRateAt = now;
        }
        // Update nerd overlay at ~4Hz
        if (nerdOn && now - lastNerdUpdate > 250) {
          const avgFps = fpsSamples.length
            ? fpsSamples.reduce((a, b) => a + b, 0) / fpsSamples.length
            : 0;
          const minFps = fpsSamples.length ? Math.min(...fpsSamples) : 0;
          const maxFps = fpsSamples.length ? Math.max(...fpsSamples) : 0;
          const lat = latency
            ? latency.getLatencyStats()
            : { avg: 0, min: 0, max: 0, jitter: 0 };
          const players = state.players?.length || 0;
          const zombies =
            state.players?.filter((p) => p.role === "zombie").length || 0;
          const bullets = state.bullets?.length || 0;
          const pickups = state.pickups?.length || 0;
          const walls = state.walls?.length || 0;
          const wsBuf = (ws && ws.bufferedAmount) || 0;
          nerdPanel.innerHTML = `
          <div><strong>Nerd Stats</strong></div>
          <div>FPS: ${avgFps.toFixed(1)} (min ${minFps.toFixed(
            0
          )} max ${maxFps.toFixed(0)})</div>
          <div>Latency: ${lat.avg.toFixed(1)} ms (min ${lat.min.toFixed(
            0
          )} max ${lat.max.toFixed(0)}) jitter ${lat.jitter.toFixed(1)} ms</div>
          <div>States/s: ${statesPerSec.toFixed(0)}</div>
          <div>Entities: players ${players} (z ${zombies}) bullets ${bullets} pickups ${pickups} walls ${walls}</div>
          <div>WS buf: ${wsBuf}</div>
        `;
          lastNerdUpdate = now;
        }
        requestAnimationFrame(loop);
      }
      loop();

      // Weapon switching
      function sendSwitchWeapon(w) {
        if (ws && ws.readyState === 1)
          ws.send(JSON.stringify({ type: "switch_weapon", weapon: w }));
      }
      document.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        if (e.key === "1") sendSwitchWeapon("pistol");
        if (e.key === "2") sendSwitchWeapon("smg");
        if (e.key === "3") sendSwitchWeapon("shotgun");
        if (e.key === "4") {
          // Attempt shotgun purchase
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "shotgun" }));
        }
        if (e.key === "5") {
          // Attempt SMG purchase
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "smg" }));
        }
        // Extraction removed; X key unused
      });
      document.querySelectorAll(".weapon").forEach((btn) =>
        btn.addEventListener("click", (e) => {
          const el = e.currentTarget;
          const w = el && el.getAttribute("data-weapon");
          if (!w) return;
          // Guard against selecting locked weapons
          if (el.classList.contains("locked")) {
            try {
              import("/common.js").then(
                (m) => m.toast && m.toast("Locked: unlock with banked first")
              );
            } catch {}
            return;
          }
          sendSwitchWeapon(w);
        })
      );
      if (buyShotgunBtn) {
        buyShotgunBtn.addEventListener("click", () => {
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "shotgun" }));
        });
      }
      if (buySmgBtn) {
        buySmgBtn.addEventListener("click", () => {
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "smg" }));
        });
      }

      // Fullscreen toggle
      document.getElementById("fullscreen").onclick = async () => {
        if (!document.fullscreenElement) {
          await document.documentElement.requestFullscreen().catch(() => {});
        } else {
          await document.exitFullscreen().catch(() => {});
        }
      };

      newBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (ws && ws.readyState === 1) {
          leaveRoom(true);
        } else {
          boot();
        }
      };
      copyBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (!copyBtn.disabled && link.value) {
          navigator.clipboard.writeText(link.value);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        }
      };
      toggleChatBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (!ws || ws.readyState !== 1) return;
        // Flip desired state based on button label
        const enable = toggleChatBtn.textContent.includes("Enable");
        ws.send(JSON.stringify({ type: "toggle_chat", disabled: !enable }));
      };

      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && chatInput.value.trim()) {
          sendChat(chatInput.value.trim());
          chatInput.value = "";
        }
      });
    </script>
  </body>
</html>
</file>

<file path="src/room.ts">
// Minimal top-down arena shooter: one Streamer (fast marine) vs many Chat Zombies (slow).
// Server maintains authoritative positions and scores. 20Hz tick.

declare global {
  interface WebSocket {
    accept(): void;
  }
  interface ResponseInit {
    webSocket?: WebSocket;
  }
  class WebSocketPair {
    0: WebSocket;
    1: WebSocket;
  }
  interface DurableObjectState {
    // Define properties as needed
  }
}

export interface Env {
  TARKOV_NAMES: string;
}

type Vec = { x: number; y: number };

interface Input {
  up: boolean;
  down: boolean;
  left: boolean;
  right: boolean;
  shoot: boolean;
  aimX: number;
  aimY: number;
  melee?: boolean;
  dash?: boolean;
}

interface Player {
  id: string;
  role: "streamer" | "zombie";
  name: string;
  pos: Vec;
  vel: Vec;
  input: Input;
  ws?: WebSocket;
  score: number; // streamer uses; zombies optional
  banked?: number; // M1: extracted/banked score (streamer)
  alive: boolean;
  lastSeen: number;
  lastShotAt?: number;
  lastMeleeAt?: number;
  lastDashAt?: number;
  hp?: number; // streamer only
  maxHp?: number; // streamer only
  boostUntil?: number; // zombies temporary speed boost timestamp
  ammo?: number; // streamer ammo
  maxAmmo?: number; // streamer max ammo
  weaponBoostUntil?: number; // streamer temporary weapon buff
  emote?: string; // short emoji shown above head
  emoteUntil?: number; // expiry timestamp (ms)
  // Streamer weapons
  weapon?: "pistol" | "smg" | "shotgun" | "bat";
  pistolAmmo?: number;
  smgAmmo?: number;
  shotgunAmmo?: number;
  meleeDirX?: number;
  meleeDirY?: number;
  dashUntil?: number;
  // Lag compensation
  lagMs?: number;
  inputBuffer?: Array<{input: Input, timestamp: number}>;
  lastInputTime?: number;
  // Zombie class fields
  zClass?: "runner" | "brute" | "spitter";
  zHp?: number;
  zMaxHp?: number;
  nextSpitAt?: number;
  lastAbilityAt?: number;
  chargeUntil?: number;
  chargeDirX?: number;
  chargeDirY?: number;
}

interface Bullet {
  id: string;
  pos: Vec;
  vel: Vec;
  ownerId: string; // streamer only in this minimal build
  ttl: number; // ms
}

interface Rect { id: string; x: number; y: number; w: number; h: number }
  // Extractions removed
  interface Extraction { id: string; x: number; y: number; r: number; activeUntil?: number }
type PickupType = "health" | "speed" | "ammo" | "weapon" | "shield" | "magnet" | "freeze" | "blast" | "treasure" | "key" | "coin" | "gem" | "relic" | "artifact" | "crystal" | "orb" | "medallion" | "scroll" | "crown";
interface Pickup { id: string; type: PickupType; x: number; y: number }

// AI Zombie interface
interface AIZombie {
  id: string;
  pos: Vec;
  vel: Vec;
  hp: number;
  maxHp: number;
  zClass: "runner" | "brute" | "spitter";
  state: "idle" | "chasing" | "attacking";
  targetId?: string;
  lastSeen: number;
  lastAttack: number;
  detectionRange: number;
  chaseRange: number;
  roomId?: string;
  pathfindingCooldown: number;
  nextPathUpdate: number;
}

import { CONFIG, TileId, type GameConfig } from './config';

export class RoomDO {
  state: DurableObjectState;
  env: Env;

  // Config (per-room, overridable)
  cfg: GameConfig = JSON.parse(JSON.stringify(CONFIG));

  // Game space
  W = CONFIG.arena.width; // px (updated when cfg changes)
  H = CONFIG.arena.height; // px (updated when cfg changes)

  // Entities
  players = new Map<string, Player>();
  bullets: Bullet[] = [];
  // Spitter globs (enemy projectiles)
  spittles: Array<{ id: string; pos: Vec; vel: Vec; ttl: number } > = [];
  walls: Rect[] = [];
  pickups: Pickup[] = [];
  // M1: extractions and optional future zones
  extractions: Extraction[] = [];
  midSafeZones: Rect[] = [];
  // AI Zombie properties
  aiZombies: AIZombie[] = [];
  maxAIZombies = CONFIG.aiZombies.maxCount;
  aiZombieSpawnCooldown = CONFIG.aiZombies.spawnCooldownMs;
  lastAIZombieSpawn = 0;
  // Tilemap state
  map: { w:number; h:number; size:number; theme: 'dungeon'|'cave'|'lab'; tiles: Uint8Array; lights: {x:number;y:number;r:number;a:number}[]; props:{x:number;y:number;type:'crate'|'pillar'|'bonepile'}[]; rooms:{x:number;y:number;w:number;h:number}[] } | null = null;

  // Loop - Different tick rates for different systems
  tickMs = CONFIG.ticks.mainMs; // updated when cfg changes
  uiTickMs = 200; // 5Hz - UI updates
  pickupTickMs = CONFIG.ticks.pickupMs; // updated when cfg changes
  running = false;
  loopTimer: number | undefined;
  uiTimer: number | undefined;
  pickupTimer: number | undefined;
  FIRE_COOLDOWN_MS = 180; // legacy; specific cooldowns in CONFIG
  lastPickupSpawn = Date.now();
  pickupIntervalMs = CONFIG.pickups.spawnIntervalMs; // updated when cfg changes
  mapReady = false;
  roundEndTime: number | undefined;
  roundDurationMs = CONFIG.round.durationMs; // updated when cfg changes
    // Global effects
  zombieSlowUntil: number | undefined;
  chatEnabled = true;
  // Extraction rotation pacing from config

  // Metadata
  createdAt = Date.now();

  constructor(state: DurableObjectState, env: Env) {
    this.state = state;
    this.env = env;
  }

  async fetch(req: Request) {
    // Handle setup for per-room overrides before any WS connections
    if (req.headers.get("Upgrade") !== "websocket") {
      try {
        const url = new URL(req.url);
        if (req.method === 'POST' && url.pathname.includes('/setup')) {
          const body = await req.json().catch(() => ({}));
          const overrides = body?.overrides || body?.config || body || {};
          if (overrides && typeof overrides === 'object') {
            this.applyOverrides(overrides);
            // Persist to storage if available
            try { (this.state as any).storage?.put('config', JSON.stringify(this.cfg)); } catch {}
            return new Response(JSON.stringify({ ok: true }), { headers: { 'content-type': 'application/json' } });
          }
          return new Response(JSON.stringify({ ok: false, error: 'invalid overrides' }), { status: 400, headers: { 'content-type': 'application/json' } });
        }
      } catch {}
      return new Response("Expected WebSocket", { status: 426 });
    }

    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair) as [WebSocket, WebSocket];
    server.accept();

    // Assign a temporary id; role determined on join message
    const pid = crypto.randomUUID().slice(0, 8);

    // Track WS
    server.addEventListener("message", (ev) => this.onMessage(server, pid, ev));
    server.addEventListener("close", () => this.onClose(pid));

    // Kick off ping
    const pingIv = setInterval(() => {
      try { server.send(JSON.stringify({ type: "ping" })); } catch {}
    }, 15000);
    server.addEventListener("close", () => clearInterval(pingIv));

    // Start loop on demand
    if (!this.running) this.startLoop();
    if (!this.mapReady) this.generateTileMapAndWalls();

    return new Response(null, { status: 101, webSocket: client });
  }

  applyOverrides(partial: any) {
    const deepMerge = (t: any, s: any) => {
      if (!s || typeof s !== 'object') return t;
      for (const k of Object.keys(s)) {
        const sv = s[k];
        if (sv && typeof sv === 'object' && !Array.isArray(sv)) {
          t[k] = deepMerge(t[k] ?? {}, sv);
        } else {
          t[k] = sv;
        }
      }
      return t;
    };
    this.cfg = deepMerge(JSON.parse(JSON.stringify(this.cfg)), partial);
    // Update derived fields used elsewhere
    this.W = this.cfg.arena.width;
    this.H = this.cfg.arena.height;
    this.tickMs = this.cfg.ticks.mainMs;
    this.pickupTickMs = this.cfg.ticks.pickupMs;
    this.pickupIntervalMs = this.cfg.pickups.spawnIntervalMs;
    this.roundDurationMs = this.cfg.round.durationMs;
    this.maxAIZombies = this.cfg.aiZombies.maxCount;
    this.aiZombieSpawnCooldown = this.cfg.aiZombies.spawnCooldownMs;
    // Force map regeneration on next loop if tiles changed
    this.mapReady = false;
  }

  startLoop() {
    this.running = true;
    if (!this.roundEndTime) this.roundEndTime = Date.now() + this.roundDurationMs;
    
    // Main game loop - 20Hz (includes state broadcast for responsiveness)
    const step = () => {
      this.update();
      this.broadcastState();
      this.loopTimer = setTimeout(step, this.tickMs) as unknown as number;
    };
    this.loopTimer = setTimeout(step, this.tickMs) as unknown as number;
    
    // Pickup spawning - 2Hz (non-critical)
    const pickupStep = () => {
      this.checkPickupSpawning();
      this.pickupTimer = setTimeout(pickupStep, this.pickupTickMs) as unknown as number;
    };
    this.pickupTimer = setTimeout(pickupStep, this.pickupTickMs) as unknown as number;
  }

  stopLoop() {
    if (this.loopTimer) clearTimeout(this.loopTimer as unknown as number);
    if (this.pickupTimer) clearTimeout(this.pickupTimer as unknown as number);
    this.running = false;
  }

  // Separate pickup spawning logic for reduced tick rate
  checkPickupSpawning() {
    const now = Date.now();
    if (now - this.lastPickupSpawn > this.pickupIntervalMs) {
      this.lastPickupSpawn = now;
      const totalCap = this.cfg.pickups.totalCap;
      if (this.pickups.length < totalCap) {
        const caps = this.cfg.pickups.caps as Record<PickupType, number>;
        const counts = { health:0, speed:0, ammo:0, weapon:0, shield:0, magnet:0, freeze:0, blast:0, treasure:0 } as Record<PickupType, number>;
        for (const pk of this.pickups) counts[pk.type]++;
        const types: PickupType[] = ["health","speed","ammo","weapon","shield","magnet","freeze","blast","treasure"]; 
        // Weighted pick: prefer under-cap types
        const options: PickupType[] = [];
        for (const t of types){
          const room = Math.max(0, (caps[t]||0)-counts[t]);
          for (let i=0;i<room;i++) options.push(t);
        }
        if (options.length > 0) {
          const type = options[Math.floor(Math.random()*options.length)];
          const pos = this.randomFreePos(28);
          if (pos && this.okDistanceFromPickups(pos.x, pos.y, this.cfg.pickups.minDistance)) {
            this.pickups.push({ id: crypto.randomUUID().slice(0,6), type, x: pos.x, y: pos.y });
          }
        }
      }
    }
  }

  onMessage(ws: WebSocket, pid: string, ev: MessageEvent) {
    try {
      const msg = JSON.parse(String(ev.data));
      if (!msg || typeof msg !== "object") return;
      switch (msg.type) {
        case "join_room": {
          let role: "streamer" | "zombie" = msg.role === "streamer" ? "streamer" : "zombie";
          const name = this.sanitizeName(msg.name) || this.randomName();

          // Spawn positions
          const pos = role === "streamer" ? this.spawnInRandomRoom() : this.spawnZombiePos();

        const p: Player = {
          id: pid,
          role,
          name,
          pos,
          vel: { x: 0, y: 0 },
          input: { up: false, down: false, left: false, right: false, shoot: false, aimX: 0, aimY: 0, melee: false },
          ws,
          score: 0,
          alive: true,
          lastSeen: Date.now(),
          hp: role === "streamer" ? this.cfg.streamer.maxHp : undefined,
          maxHp: role === "streamer" ? this.cfg.streamer.maxHp : undefined,
          weapon: role === "streamer" ? "pistol" : undefined,
          pistolAmmo: role === "streamer" ? this.cfg.weapons.ammo.initial.pistol : undefined,
          smgAmmo: role === "streamer" ? 0 : undefined,
          shotgunAmmo: role === "streamer" ? 0 : undefined,
          banked: role === "streamer" ? 0 : undefined,
        };
        // Enforce single-streamer per room. Downgrade to zombie if already present.
        if (role === "streamer") {
          const hasStreamer = [...this.players.values()].some(pl => pl.role === "streamer");
          if (hasStreamer) {
            role = "zombie";
            p.role = "zombie";
            p.hp = undefined; p.maxHp = undefined; p.ammo = undefined; p.maxAmmo = undefined; p.weaponBoostUntil = undefined;
            p.weapon = undefined; p.pistolAmmo = undefined; p.smgAmmo = undefined; p.shotgunAmmo = undefined;
            p.pos = this.spawnZombiePos();
            try { ws.send(JSON.stringify({ type: "notice", message: "Streamer already active. You joined as a zombie." })); } catch {}
          }
        }
        // Assign class stats if zombie after potential downgrade
        if (p.role === 'zombie') {
          const zc = this.pickZombieClass();
          p.zClass = zc;
          const base = this.cfg.zombies.baseHp;
          p.zMaxHp = Math.max(1, Math.round(base * this.cfg.zombies.hpMul[zc]));
          p.zHp = p.zMaxHp;
          if (zc === 'spitter') {
            p.nextSpitAt = Date.now() + this.randRange(this.cfg.zombies.spitter.cooldownMsMin, this.cfg.zombies.spitter.cooldownMsMax);
          }
        }

        this.players.set(pid, p);

          ws.send(JSON.stringify({ type: "joined", playerId: pid, name, role, arena: { w: this.W, h: this.H } }));
          // Send map payload to the new client
          try {
            if (!this.map) this.generateTileMapAndWalls();
            if (this.map) {
              const base64 = this.u8ToBase64(this.map.tiles);
              ws.send(JSON.stringify({ type: 'map', map: { w: this.map.w, h: this.map.h, size: this.map.size, theme: this.map.theme, tilesBase64: base64, props: this.map.props, lights: this.map.lights } }));
            }
          } catch {}
          this.broadcast("players_update", { players: [...this.players.values()].map(this.publicPlayer) });
          break;
        }
        case "input": {
          const p = this.players.get(pid);
          if (!p) return;
          const now = Date.now();
          
          // Process input with lag compensation
          this.processInputWithLagCompensation(p, {
            up: !!msg.up,
            down: !!msg.down,
            left: !!msg.left,
            right: !!msg.right,
            shoot: !!msg.shoot,
            aimX: Number(msg.aimX) || 0,
            aimY: Number(msg.aimY) || 0,
            melee: !!msg.melee,
            dash: !!msg.dash,
          }, msg.timestamp || now);
          
          p.lastSeen = now;
          break;
        }
        case "ping": {
          const p = this.players.get(pid);
          if (!p) return;
          // Echo back ping for RTT measurement
          try {
            p.ws?.send(JSON.stringify({ type: 'pong', timestamp: msg.timestamp }));
          } catch {}
          break;
        }
        case "toggle_chat": {
          const p = this.players.get(pid);
          if (!p || p.role !== "streamer") return;
          // allow explicit boolean or toggle if omitted
          const desired = typeof msg.disabled === 'boolean' ? !msg.disabled : !this.chatEnabled;
          this.chatEnabled = desired;
          this.broadcast("notice", { message: this.chatEnabled ? "Chat enabled by streamer" : "Chat disabled by streamer" });
          break;
        }
        case "pong": {
          const p = this.players.get(pid); if (p) p.lastSeen = Date.now();
          break;
        }
        case "chat": {
          const p = this.players.get(pid);
          if (!p) return;
          if (!this.chatEnabled && p.role !== "streamer") return;
          this.broadcast("chat", { from: p.name, message: msg.message });
          break;
        }
        case "buy": {
          const p = this.players.get(pid);
          if (!p || p.role !== 'streamer') return;
          const item = String(msg.item||'');
          const cost = 300;
          const bank = p.banked || 0;
          if (item === 'shotgun') {
            if (bank >= cost) {
              p.banked = bank - cost;
              p.weapon = 'shotgun';
              p.shotgunAmmo = Math.max(p.shotgunAmmo||0, this.cfg.weapons.ammo.initial.shotgun);
              this.broadcast('notice', { message: `${p.name} purchased Shotgun! (-${cost} banked)` });
            } else {
              try { p.ws?.send(JSON.stringify({ type:'notice', message:`Not enough banked (need ${cost})` })); } catch {}
            }
          } else if (item === 'smg') {
            if (bank >= cost) {
              p.banked = bank - cost;
              p.weapon = 'smg';
              p.smgAmmo = Math.max(p.smgAmmo||0, this.cfg.weapons.ammo.initial.smg);
              this.broadcast('notice', { message: `${p.name} purchased SMG! (-${cost} banked)` });
            } else {
              try { p.ws?.send(JSON.stringify({ type:'notice', message:`Not enough banked (need ${cost})` })); } catch {}
            }
          }
          break;
        }
        case "emote": {
          const p = this.players.get(pid);
          if (!p || p.role !== "zombie") return;
          const symbol = typeof msg.symbol === 'string' ? msg.symbol : '';
          // Allow only a small curated set of emojis
          const allowed = new Set(["🧟","💀","🔥","😂","❤️","💢"]);
          if (!allowed.has(symbol)) return;
          const now = Date.now();
          p.emote = symbol;
          p.emoteUntil = now + 5000; // 5 seconds
          break;
        }
        case "switch_weapon": {
          const p = this.players.get(pid);
          if (!p || p.role !== "streamer") return;
          const w = String(msg.weapon || "");
          if (w === "pistol" || w === "smg" || w === "shotgun" || w === "bat") {
            p.weapon = w;
          }
          break;
        }
        // attempt_extract removed
      }
    } catch {}
  }

  onClose(pid: string) {
    const p = this.players.get(pid);
    if (!p) return;
    this.players.delete(pid);
    this.broadcast("players_update", { players: [...this.players.values()].map(this.publicPlayer) });
  }

  update() {
    const now = Date.now();

    // Drop stale sockets (missed heartbeats for 40s)
    for (const [id, p] of this.players) {
      if (now - p.lastSeen > 40000) {
        this.players.delete(id);
      }
    }

    // Extractions removed

    // Update AI Zombies
    this.updateAIZombies(now);

    // Spawn AI Zombies if needed
    this.spawnAIZombiesIfNeeded(now);

    // Integrate movement
    const dt = this.tickMs / 1000;
    for (const p of this.players.values()) {
      let baseSpeed = p.role === "streamer" ? this.cfg.speeds.streamer : this.cfg.speeds.zombie; // px/s
      if (p.role === 'zombie' && p.zClass) baseSpeed *= this.cfg.zombies.speedMul[p.zClass];
      if (p.role === "zombie" && (this.zombieSlowUntil || 0) > now) baseSpeed *= this.cfg.speeds.zombieSlowMultiplier; // global slow
      if (p.role === 'streamer' && ((p as any).gooSlowUntil || 0) > now) baseSpeed *= this.cfg.zombies.spitter.streamerSlowMul;
      const boosted = p.role === "zombie" && (p.boostUntil || 0) > now;
      let speed = boosted ? baseSpeed * this.cfg.speeds.zombieBoostMultiplier : baseSpeed;
      let vx = 0, vy = 0;
      if (p.input.up) vy -= 1;
      if (p.input.down) vy += 1;
      if (p.input.left) vx -= 1;
      if (p.input.right) vx += 1;
      // Zombie active abilities on left-click
      let useCharge = false; let chargeSpeed = 0;
      if (p.role === 'zombie' && p.zClass) {
        const nowMs = now;
        const since = nowMs - (p.lastAbilityAt || 0);
        if (p.zClass === 'runner') {
          if (p.input.shoot && since >= this.cfg.zombies.runnerAbility.cooldownMs) {
            p.boostUntil = nowMs + this.cfg.zombies.runnerAbility.durationMs;
            p.lastAbilityAt = nowMs;
          }
        } else if (p.zClass === 'brute') {
          if (p.input.shoot && since >= this.cfg.zombies.bruteAbility.cooldownMs) {
            const dirx = (p.input.aimX || p.pos.x) - p.pos.x;
            const diry = (p.input.aimY || p.pos.y) - p.pos.y;
            const d = Math.hypot(dirx, diry) || 1;
            p.chargeDirX = dirx / d; p.chargeDirY = diry / d;
            p.chargeUntil = nowMs + this.cfg.zombies.bruteAbility.durationMs;
            p.lastAbilityAt = nowMs;
          }
          if ((p.chargeUntil || 0) > nowMs) {
            useCharge = true; chargeSpeed = this.cfg.zombies.bruteAbility.speed;
            vx = p.chargeDirX || 0; vy = p.chargeDirY || 0;
          }
        } else if (p.zClass === 'spitter') {
          if (p.input.shoot && since >= this.cfg.zombies.spitter.manualCooldownMs) {
            const dx = (p.input.aimX || p.pos.x) - p.pos.x;
            const dy = (p.input.aimY || p.pos.y) - p.pos.y;
            const d = Math.hypot(dx, dy) || 1;
            const s = this.cfg.zombies.spitter.projectileSpeed;
            this.spittles.push({ id: crypto.randomUUID().slice(0,6), pos: { x: p.pos.x, y: p.pos.y }, vel: { x: (dx/d)*s, y: (dy/d)*s }, ttl: this.cfg.zombies.spitter.projectileTtl });
            p.lastAbilityAt = nowMs;
          }
        }
      }
      const len = Math.hypot(vx, vy) || 1;
      // Handle dash (streamer only)
      if (p.role === 'streamer') {
        // Trigger dash on key press if off cooldown
        const nowMs = Date.now();
        (p as any)._dashLatched = (p as any)._dashLatched || false;
        const ready = (nowMs - (p.lastDashAt || 0)) >= this.cfg.dash.cooldownMs;
        if (p.input.dash && ready && !(p as any)._dashLatched) {
          p.dashUntil = nowMs + this.cfg.dash.durationMs;
          p.lastDashAt = nowMs;
          (p as any)._dashLatched = true;
        }
        if (!p.input.dash && (p as any)._dashLatched) (p as any)._dashLatched = false;
        // Apply dash speed multiplier if active
        if ((p.dashUntil || 0) > nowMs) {
          speed *= this.cfg.dash.speedMultiplier;
        }
      }
      const moveSpeed = useCharge ? chargeSpeed : speed;
      p.vel.x = (vx / len) * moveSpeed;
      p.vel.y = (vy / len) * moveSpeed;
      // Intended new position
      let nx = p.pos.x + p.vel.x * dt;
      let ny = p.pos.y + p.vel.y * dt;
      // Tile semantics: solid, door, pit, slow
      if (this.map) {
        const sz = this.map.size;
        const ix = Math.max(0, Math.min(this.map.w-1, Math.floor(nx / sz)));
        const iy = Math.max(0, Math.min(this.map.h-1, Math.floor(ny / sz)));
        const t = this.map.tiles[iy*this.map.w + ix] as TileId;
        const isSolid = (tt:TileId)=> tt===1 || tt===4; // wall or doorClosed
        const isLethal = (tt:TileId)=> tt===2; // pit
        const isSlow = (tt:TileId)=> tt===3; // water/sludge
        
        // Door interaction feedback for streamer
        if (p.role === 'streamer' && t === 4) {
          const lastDoorToast = (p as any).lastDoorToast || 0;
          if (now - lastDoorToast > 3000) { // Throttle to every 3 seconds
            this.broadcast("notice", { message: "🚪 Closed door! Find a KEY pickup to open all doors" });
            (p as any).lastDoorToast = now;
          }
        }
        
        if (isSlow(t)) { 
          nx = p.pos.x + (p.vel.x * 0.6) * dt; 
          ny = p.pos.y + (p.vel.y * 0.6) * dt;
          // Water/sludge feedback for streamer
          if (p.role === 'streamer') {
            const lastSlowToast = (p as any).lastSlowToast || 0;
            if (now - lastSlowToast > 4000) {
              this.broadcast("notice", { message: "💧 Moving through water - slowed down!" });
              (p as any).lastSlowToast = now;
            }
          }
        }
        if (isSolid(t)) { nx = p.pos.x; ny = p.pos.y; }
        if (isLethal(t)) {
          if (p.role === 'streamer') {
            this.broadcast("notice", { message: "💀 Fell into a pit! Respawning..." });
            p.hp = 0;
            // simple respawn
            p.pos = this.spawnInRandomRoom();
            p.hp = p.maxHp ?? this.cfg.streamer.maxHp;
            nx = p.pos.x; ny = p.pos.y;
          } else {
            p.alive = false; const id=p.id; setTimeout(()=>{ const zp=this.players.get(id); if (zp) { zp.pos=this.spawnZombiePos(); zp.alive=true; } }, this.cfg.combat.respawnMs);
          }
        }
      }
      p.pos.x = Math.max(0, Math.min(this.W, nx));
      p.pos.y = Math.max(0, Math.min(this.H, ny));

      // Resolve collisions with walls (circle vs axis-aligned rectangles)
      const pr = p.role === "streamer" ? this.cfg.radii.streamer : this.cfg.radii.zombie;
      for (const rct of this.walls) {
        const nearestX = Math.max(rct.x, Math.min(p.pos.x, rct.x + rct.w));
        const nearestY = Math.max(rct.y, Math.min(p.pos.y, rct.y + rct.h));
        let dx = p.pos.x - nearestX; let dy = p.pos.y - nearestY; let dist = Math.hypot(dx, dy);
        if (dist < pr) {
          if (dist === 0) {
            // Center is inside rectangle; push out along smallest penetration axis
            const left = Math.abs(p.pos.x - rct.x);
            const right = Math.abs(rct.x + rct.w - p.pos.x);
            const top = Math.abs(p.pos.y - rct.y);
            const bottom = Math.abs(rct.y + rct.h - p.pos.y);
            const m = Math.min(left, right, top, bottom);
            if (m === left) p.pos.x = rct.x - pr;
            else if (m === right) p.pos.x = rct.x + rct.w + pr;
            else if (m === top) p.pos.y = rct.y - pr;
            else p.pos.y = rct.y + rct.h + pr;
          } else {
            const nx = dx / dist, ny = dy / dist;
            const push = (pr - dist) + 0.5;
            p.pos.x += nx * push; p.pos.y += ny * push;
          }
        }
      }

      // Shooting / attacking (streamer only)
      if (p.role === "streamer" && p.input.shoot) {
        const nowMs = Date.now();
        const boostedW = (p.weaponBoostUntil || 0) > nowMs;
        const weapon = p.weapon || "pistol";
        const dirx = p.input.aimX - p.pos.x;
        const diry = p.input.aimY - p.pos.y;
        const d = Math.hypot(dirx, diry) || 1;
        const nx = dirx / d, ny = diry / d;
        const since = nowMs - (p.lastShotAt || 0);
        if (weapon === "pistol") {
          // Single-click slow shot: fire once per mouse press
          const cd = boostedW ? this.cfg.weapons.cooldownMs.pistol.boosted : this.cfg.weapons.cooldownMs.pistol.base;
          // Latch: only fire once until shoot is released
          (p as any)._pistolLatched = (p as any)._pistolLatched || false;
          if (since >= cd && (p.pistolAmmo ?? 0) > 0 && !(p as any)._pistolLatched) {
            const speedB = boostedW ? this.cfg.weapons.projectile.pistol.speed * 1.166 : this.cfg.weapons.projectile.pistol.speed;
            this.bullets.push({ id: crypto.randomUUID().slice(0,6), pos:{x:p.pos.x,y:p.pos.y}, vel:{x:nx*speedB,y:ny*speedB}, ownerId:p.id, ttl: this.cfg.weapons.projectile.pistol.ttl });
            p.pistolAmmo = Math.max(0, (p.pistolAmmo ?? 0) - 1);
            p.lastShotAt = nowMs;
            (p as any)._pistolLatched = true;
          }
        } else if (weapon === "smg") {
          const cd = boostedW ? this.cfg.weapons.cooldownMs.smg.boosted : this.cfg.weapons.cooldownMs.smg.base;
          if (since >= cd && (p.smgAmmo ?? 0) > 0) {
            const speedB = boostedW ? this.cfg.weapons.projectile.smg.speed * 1.176 : this.cfg.weapons.projectile.smg.speed;
            const spread = (Math.random()-0.5) * 0.12; // radians
            const cs = Math.cos(spread), sn = Math.sin(spread);
            const vx = nx * cs - ny * sn; const vy = nx * sn + ny * cs;
            this.bullets.push({ id: crypto.randomUUID().slice(0,6), pos:{x:p.pos.x,y:p.pos.y}, vel:{x:vx*speedB,y:vy*speedB}, ownerId:p.id, ttl: this.cfg.weapons.projectile.smg.ttl });
            p.smgAmmo = Math.max(0, (p.smgAmmo ?? 0) - 1);
            p.lastShotAt = nowMs;
          }
        } else if (weapon === "shotgun") {
          const cd = boostedW ? this.cfg.weapons.cooldownMs.shotgun.boosted : this.cfg.weapons.cooldownMs.shotgun.base; // slower burst
          if (since >= cd && (p.shotgunAmmo ?? 0) > 0) {
            const speedB = boostedW ? this.cfg.weapons.projectile.shotgun.speed * 1.2 : this.cfg.weapons.projectile.shotgun.speed;
            const pellets = this.cfg.weapons.projectile.shotgun.pellets;
            for (let i=0;i<pellets;i++){
              const spread = (Math.random()-0.5) * 0.45; // radians
              const cs = Math.cos(spread), sn = Math.sin(spread);
              const vx = nx * cs - ny * sn; const vy = nx * sn + ny * cs;
              this.bullets.push({ id: crypto.randomUUID().slice(0,6), pos:{x:p.pos.x,y:p.pos.y}, vel:{x:vx*speedB,y:vy*speedB}, ownerId:p.id, ttl: this.cfg.weapons.projectile.shotgun.ttl });
            }
            p.shotgunAmmo = Math.max(0, (p.shotgunAmmo ?? 0) - 1);
            p.lastShotAt = nowMs;
          }
        }
      }
      // Always-available bat (melee) on separate input
      if (p.role === "streamer" && p.input.melee) {
        const nowMs = Date.now();
        const since = nowMs - (p.lastMeleeAt || 0);
        const cd = this.cfg.melee.cooldownMs;
        if (since >= cd) {
          const dirx = p.input.aimX - p.pos.x;
          const diry = p.input.aimY - p.pos.y;
          const d = Math.hypot(dirx, diry) || 1;
          const nx = dirx / d, ny = diry / d;
          p.meleeDirX = nx; p.meleeDirY = ny;
          const reach = this.cfg.melee.reach; // px
          for (const z of this.players.values()){
            if (z.role !== "zombie" || !z.alive) continue;
            const dx = z.pos.x - p.pos.x; const dy = z.pos.y - p.pos.y;
            const dist = Math.hypot(dx,dy);
            if (dist > reach) continue;
            const dot = (dx/dist||0)*nx + (dy/dist||0)*ny;
            if (dot > Math.cos(this.cfg.melee.arcRad)) {
              // Apply melee damage from config
              z.zHp = Math.max(0, (z.zHp ?? this.cfg.zombies.baseHp) - this.cfg.weapons.damage.melee);
              if ((z.zHp ?? 0) <= 0) {
                z.alive = false;
                // Drop ammo on zombie death
                this.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
                const id = z.id;
                setTimeout(() => { const zp = this.players.get(id); if (zp) { zp.pos = this.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, this.cfg.combat.respawnMs);
                p.score += 1;
              }
            }
          }
          p.lastMeleeAt = nowMs;
        }
      }
      // Reset pistol latch when trigger released
      if (p.role === "streamer" && !p.input.shoot) {
        if ((p as any)._pistolLatched) (p as any)._pistolLatched = false;
      }
    }

    // Update bullets
    const aliveBullets: Bullet[] = [];
    for (const b of this.bullets) {
      b.ttl -= this.tickMs;
      b.pos.x += b.vel.x * dt;
      b.pos.y += b.vel.y * dt;
      if (b.ttl <= 0) continue;
      if (b.pos.x < 0 || b.pos.x > this.W || b.pos.y < 0 || b.pos.y > this.H) continue;

      // Collision with walls: stop bullet if inside rect (with small margin)
      let blocked = false;
      for (const rct of this.walls) {
        const m = this.cfg.radii.bulletMargin; // bullet radius margin
        if (b.pos.x > rct.x - m && b.pos.x < rct.x + rct.w + m && b.pos.y > rct.y - m && b.pos.y < rct.y + rct.h + m) { blocked = true; break; }
      }
      if (blocked) continue;

      // Collision with zombies (class-based HP)
      let hit = false;
      for (const p of this.players.values()) {
        if (p.role !== "zombie" || !p.alive) continue;
        const r = this.cfg.radii.zombie; // zombie radius
        if (Math.hypot(p.pos.x - b.pos.x, p.pos.y - b.pos.y) < r) {
          const shooter = [...this.players.values()].find(p => p.id === b.ownerId);
          const weaponType = shooter?.weapon || 'pistol';
          const dmg = this.cfg.weapons.damage[weaponType as keyof typeof this.cfg.weapons.damage] || 0;
          p.zHp = Math.max(0, (p.zHp ?? this.cfg.zombies.baseHp) - dmg);
          if ((p.zHp ?? 0) <= 0) {
            p.alive = false;
            // Drop ammo on zombie death
            this.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: p.pos.x, y: p.pos.y });
            const id = p.id;
            setTimeout(() => { const zp = this.players.get(id); if (zp) { zp.pos = this.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, this.cfg.combat.respawnMs);
          }
          // Reward streamer
          const s = [...this.players.values()].find(q => q.id === b.ownerId);
          if (s) s.score += 1;
          hit = true; break;
        }
      }
      
      // Collision with AI zombies
      if (!hit) {
        for (const zombie of this.aiZombies) {
          const r = this.cfg.radii.zombie;
          if (Math.hypot(zombie.pos.x - b.pos.x, zombie.pos.y - b.pos.y) < r) {
            const dmg = 100;
            zombie.hp = Math.max(0, zombie.hp - dmg);
            // Reward streamer
            const s = [...this.players.values()].find(q => q.id === b.ownerId);
            if (s) s.score += 1;
            hit = true;
            break;
          }
        }
      }
      if (!hit) aliveBullets.push(b);
    }
    this.bullets = aliveBullets;

    // Find streamer at the start of the update
    const streamer = [...this.players.values()].find(p => p.role === "streamer");

    // Update spitter globs
    const aliveGlobs: typeof this.spittles = [];
    for (const g of this.spittles) {
      g.ttl -= this.tickMs;
      g.pos.x += g.vel.x * dt;
      g.pos.y += g.vel.y * dt;
      if (g.ttl <= 0) continue;
      if (g.pos.x < 0 || g.pos.x > this.W || g.pos.y < 0 || g.pos.y > this.H) continue;
      // collide with streamer
      if (streamer) {
        const r = this.cfg.radii.streamer + 2;
        if (Math.hypot(streamer.pos.x - g.pos.x, streamer.pos.y - g.pos.y) < r) {
          // apply slow and small damage
          (streamer as any).gooSlowUntil = now + this.cfg.zombies.spitter.slowMs;
          streamer.hp = Math.max(0, (streamer.hp ?? this.cfg.streamer.maxHp) - this.cfg.zombies.spitter.hitDamage);
          continue; // glob consumed
        }
      }
      aliveGlobs.push(g);
    }
    this.spittles = aliveGlobs;

    // Zombie damage to streamer
    if (streamer) {
      // Dash-kill pass: if streamer is dashing, kill non-brute zombies on contact
      if ((streamer.dashUntil || 0) > now) {
        for (const z of this.players.values()) {
          if (z.role !== 'zombie' || !z.alive) continue;
          const dist = Math.hypot(z.pos.x - streamer.pos.x, z.pos.y - streamer.pos.y);
          const thresh = this.cfg.radii.zombie + this.cfg.radii.streamer;
          if (dist <= thresh) {
            if (z.zClass === 'brute') {
              continue; // brutes resist dash kill
            }
            z.zHp = 0; z.alive = false;
            // Drop ammo on zombie death
            this.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
            const id = z.id;
            setTimeout(() => { const zp = this.players.get(id); if (zp) { zp.pos = this.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, this.cfg.combat.respawnMs);
            streamer.score += 1;
          }
        }
      }
      // Spitter AI: fire globs toward streamer
      for (const z of this.players.values()){
        if (z.role !== 'zombie' || !z.alive || z.zClass !== 'spitter') continue;
        const rng = this.cfg.zombies.spitter.range;
        const dx = streamer.pos.x - z.pos.x; const dy = streamer.pos.y - z.pos.y; const dist = Math.hypot(dx, dy);
        if (dist <= rng && (z.nextSpitAt || 0) <= now) {
          const s = this.cfg.zombies.spitter.projectileSpeed;
          const nx = (dx / (dist||1)); const ny = (dy / (dist||1));
          this.spittles.push({ id: crypto.randomUUID().slice(0,6), pos: { x: z.pos.x, y: z.pos.y }, vel: { x: nx * s, y: ny * s }, ttl: this.cfg.zombies.spitter.projectileTtl });
          z.nextSpitAt = now + this.randRange(this.cfg.zombies.spitter.cooldownMsMin, this.cfg.zombies.spitter.cooldownMsMax);
        }
      }
      for (const z of this.players.values()) {
        if (z.role !== "zombie" || !z.alive) continue;
        const dist = Math.hypot(z.pos.x - streamer.pos.x, z.pos.y - streamer.pos.y);
        if (dist < 16) {
          const shielded = ((streamer as any).shieldUntil || 0) > now;
          if (!shielded) {
            if ((streamer.hp ?? this.cfg.streamer.maxHp) > 0) {
              streamer.hp = Math.max(0, (streamer.hp ?? this.cfg.streamer.maxHp) - this.cfg.combat.zombieTouchDamage);
            }
            if ((streamer.hp ?? 0) <= 0) {
              // Respawn streamer; lose unbanked on death (keep banked)
              streamer.pos = this.spawnInRandomRoom();
              streamer.hp = streamer.maxHp ?? this.cfg.streamer.maxHp;
              streamer.score = 0;
            }
          }// Knockback streamer slightly
          const dx = streamer.pos.x - z.pos.x; const dy = streamer.pos.y - z.pos.y; const d = Math.hypot(dx, dy) || 1;
          const kbMul = (z.zClass === 'brute') ? this.cfg.zombies.brute.extraKnockbackMul : 1;
          streamer.pos.x = Math.max(0, Math.min(this.W, streamer.pos.x + (dx / d) * this.cfg.combat.knockbackStep * kbMul));
          streamer.pos.y = Math.max(0, Math.min(this.H, streamer.pos.y + (dy / d) * this.cfg.combat.knockbackStep * kbMul));
          // Teleport zombie to edge to avoid instant re-hit
          z.pos = this.spawnZombiePos();
        }
      }
    }

    // (duplicate spawning block removed; handled by checkPickupSpawning())

    // Pickup collection
    const remaining: Pickup[] = [];
    for (const p of this.pickups) {
      let taken = false;
      for (const pl of this.players.values()) {
        const pr = pl.role === "streamer" ? 10 : 12;
        const pickupR = (pl.role === "streamer" && (((pl as any).magnetUntil || 0) > now)) ? 26 : 10;
        if (Math.hypot(pl.pos.x - p.x, pl.pos.y - p.y) < pr + pickupR) { // pickup radius
          if (p.type === "health" && pl.role === "streamer") {
            pl.hp = Math.min(pl.maxHp ?? this.cfg.streamer.maxHp, (pl.hp ?? this.cfg.streamer.maxHp) + 20);
            this.broadcast("notice", { message: "❤️ Health restored!" });
            taken = true; break;
          }
          if (p.type === "speed" && pl.role === "zombie") {
            pl.boostUntil = now + this.cfg.effects.zombieBoostMs; // speed boost
            taken = true; break;
          }
          if (p.type === "ammo" && pl.role === "streamer") {
            pl.pistolAmmo = Math.min((pl.pistolAmmo ?? 0) + this.cfg.weapons.ammo.pickupGain.pistol, this.cfg.weapons.ammo.max.pistol);
            pl.smgAmmo = Math.min((pl.smgAmmo ?? 0) + this.cfg.weapons.ammo.pickupGain.smg, this.cfg.weapons.ammo.max.smg);
            pl.shotgunAmmo = Math.min((pl.shotgunAmmo ?? 0) + this.cfg.weapons.ammo.pickupGain.shotgun, this.cfg.weapons.ammo.max.shotgun);
            this.broadcast("notice", { message: "🔫 Ammo refilled for all weapons!" });
            taken = true; break;
          }
          if (p.type === "weapon" && pl.role === "streamer") {
            // If currently bat-only, grant pistol and some starter ammo; otherwise weapon boost
            if ((pl.weapon||'bat') === 'bat') {
              pl.weapon = 'pistol';
              pl.pistolAmmo = Math.max(pl.pistolAmmo||0, 30);
              this.broadcast("notice", { message: "🔫 Pistol unlocked with ammo!" });
            } else {
              this.broadcast("notice", { message: "⚡ Weapon boost activated!" });
            }
            pl.weaponBoostUntil = now + this.cfg.effects.weaponBoostMs; // better weapon
            taken = true; break;
          }
          if (p.type === "shield" && pl.role === "streamer") {
            (pl as any).shieldUntil = now + this.cfg.effects.shieldMs; // shield
            this.broadcast("notice", { message: "🛡️ Shield activated - temporary invulnerability!" });
            taken = true; break;
          }
          if (p.type === "magnet" && pl.role === "streamer") {
            (pl as any).magnetUntil = now + this.cfg.effects.magnetMs; // big pickup radius
            this.broadcast("notice", { message: "🧲 Magnet activated - larger pickup radius!" });
            taken = true; break;
          }
          if (p.type === "freeze" && pl.role === "streamer") {
            this.zombieSlowUntil = now + this.cfg.effects.freezeMs; // slow zombies globally
            this.broadcast("notice", { message: "❄️ Freeze activated - all zombies slowed!" });
            taken = true; break;
          }
          if (p.type === "blast" && pl.role === "streamer") {
            // Clear nearby zombies and score for each
            const radius = this.cfg.pickups.blastRadius;
            let zombiesHit = 0;
            for (const z of this.players.values()){
              if (z.role !== "zombie" || !z.alive) continue;
              if (Math.hypot(z.pos.x - pl.pos.x, z.pos.y - pl.pos.y) <= radius){
                z.zHp = Math.max(0, (z.zHp ?? this.cfg.zombies.baseHp) - 100);
                if ((z.zHp ?? 0) <= 0) {
                  z.alive = false;
                  zombiesHit++;
                  // Drop ammo on zombie death
                  this.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
                  const id = z.id;
                  setTimeout(() => { const zp = this.players.get(id); if (zp) { zp.pos = this.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, this.cfg.combat.respawnMs);
                  if (pl.role === "streamer") pl.score += 1;
                }
              }
            }
            this.broadcast("notice", { message: `💥 Blast killed ${zombiesHit} zombies!` });
            taken = true; break;
          }
          if (p.type === "treasure" && pl.role === "streamer") {
            pl.score += this.cfg.pickups.treasureScore;
            this.broadcast("notice", { message: `💎 Treasure found! +${this.cfg.pickups.treasureScore} points` });
            taken = true; break;
          }
          // Handle new treasure types
          const treasureValue = this.getTreasureValue(p.type);
          if (treasureValue > 0 && pl.role === "streamer") {
            pl.score += treasureValue;
            const treasureNames: Record<string, string> = {
              coin: "💰 Coin",
              gem: "💎 Gem", 
              crystal: "🔮 Crystal",
              orb: "🌟 Orb",
              relic: "🏺 Relic",
              artifact: "⚱️ Artifact",
              medallion: "🏅 Medallion",
              scroll: "📜 Scroll",
              crown: "👑 Crown"
            };
            const name = treasureNames[p.type] || "💎 Treasure";
            this.broadcast("notice", { message: `${name} found! +${treasureValue} points` });
            taken = true; break;
          }
          if (p.type === "key" && pl.role === "streamer") {
            // Open all doors: convert tile 4 (doorClosed) to 5 (doorOpen)
            if (this.map) {
              for (let i=0;i<this.map.tiles.length;i++) if (this.map.tiles[i]===4) this.map.tiles[i]=5;
              // Broadcast updated map to all clients
              const base64 = this.u8ToBase64(this.map.tiles);
              this.broadcast('map', { map: { w: this.map.w, h: this.map.h, size: this.map.size, theme: this.map.theme, tilesBase64: base64, props: this.map.props, lights: this.map.lights } });
            }
            this.broadcast("notice", { message: "🗝️ Key used! All doors are now open!" });
            taken = true; break;
          }
        }
      }
      if (!taken) remaining.push(p);
    }
    this.pickups = remaining;

    // Extractions removed

    const s = [...this.players.values()].find(p => p.role === "streamer");

    // Round timer: reset when time elapses
    if ((this.roundEndTime || 0) > 0 && now >= (this.roundEndTime as number)) {
      // On round end, just reset unbanked score (no extractions)
      if (s) { s.score = 0; }

      this.roundEndTime = now + this.roundDurationMs;
      this.bullets = [];
      this.pickups = [];
      // Extractions removed – no respawn/rotation
      // Optionally regenerate map each round (for variety)
      this.generateTileMapAndWalls();
      // Broadcast new map to all clients
      if (this.map) {
        const base64 = this.u8ToBase64(this.map.tiles);
        this.broadcast('map', { map: { w: this.map.w, h: this.map.h, size: this.map.size, theme: this.map.theme, tilesBase64: base64, props: this.map.props, lights: this.map.lights } });
      }
      for (const p of this.players.values()) {
        if (p.role === "streamer") {
          p.pos = { x: this.W / 2, y: this.H / 2 };
          p.alive = true;
          p.hp = p.maxHp ?? this.cfg.streamer.maxHp;
          p.weapon = "pistol";
          p.pistolAmmo = this.cfg.weapons.ammo.initial.pistol;
          p.smgAmmo = 0;
          p.shotgunAmmo = 0;
        } else {
          p.pos = this.spawnZombiePos();
          p.alive = true;
          p.boostUntil = undefined;
          p.zHp = p.zMaxHp;
        }
      }
      // Let clients know a new round started
      this.broadcast("notice", { message: "New round!" });
    }
  }

  // AI Zombie methods
  spawnAIZombiesIfNeeded(now: number) {
    if (now - this.lastAIZombieSpawn < this.aiZombieSpawnCooldown) return;
    if (this.aiZombies.length >= this.maxAIZombies) return;
    
    // Only spawn if there's a streamer
    const streamer = [...this.players.values()].find(p => p.role === "streamer");
    if (!streamer) return;
    
    const spawnPos = this.getAIZombieSpawnPosition(streamer.pos);
    if (!spawnPos) return;
    
    const zClass = this.pickZombieClass();
    const baseHp = this.cfg.zombies.baseHp;
    const maxHp = Math.max(1, Math.round(baseHp * this.cfg.zombies.hpMul[zClass]));
    
    const aiZombie: AIZombie = {
      id: crypto.randomUUID().slice(0, 8),
      pos: spawnPos,
      vel: { x: 0, y: 0 },
      hp: maxHp,
      maxHp: maxHp,
      zClass: zClass,
      state: "idle",
      lastSeen: 0,
      lastAttack: 0,
      detectionRange: this.cfg.zombies.detectionRange[zClass],
      chaseRange: this.cfg.zombies.chaseRange[zClass],
      pathfindingCooldown: 500, // ms between pathfinding updates
      nextPathUpdate: now
    };
    
    this.aiZombies.push(aiZombie);
    this.lastAIZombieSpawn = now;
  }
  
  getRandomZombieDrop(): PickupType | null {
    // First check if any drop should happen at all
    if (Math.random() > this.cfg.aiZombies.dropChance) {
      return null; // No drop
    }
    
    const rand = Math.random();
    
    // Use config values for drop chances (normalized since we already passed the drop check)
    const totalChance = this.cfg.aiZombies.ammoDropChance + this.cfg.aiZombies.treasureDropChance;
    const normalizedAmmoChance = this.cfg.aiZombies.ammoDropChance / totalChance;
    
    if (rand < normalizedAmmoChance) {
      return "ammo";
    }
    
    // Treasure drops with configurable rarities
    const treasureRoll = Math.random();
    const rates = this.cfg.aiZombies.treasureDropRates;
    
    let cumulative = 0;
    for (const [treasure, rate] of Object.entries(rates)) {
      cumulative += rate;
      if (treasureRoll < cumulative) {
        return treasure as PickupType;
      }
    }
    
    // Fallback to coin if something goes wrong
    return "coin";
  }

  getTreasureValue(type: PickupType): number {
    return this.cfg.aiZombies.treasureValues[type] || 0;
  }

  getAIZombieSpawnPosition(streamerPos: Vec): Vec | null {
    if (!this.map || !this.map.rooms) return null;
    
    // Try to spawn in a room that's not too close to the streamer
    const attempts = 20;
    for (let i = 0; i < attempts; i++) {
      const room = this.map.rooms[Math.floor(Math.random() * this.map.rooms.length)];
      
      // Find floor tiles in this room
      const candidates: Vec[] = [];
      for (let ty = room.y + 1; ty < room.y + room.h - 1; ty++) {
        for (let tx = room.x + 1; tx < room.x + room.w - 1; tx++) {
          if (tx >= 0 && tx < this.map.w && ty >= 0 && ty < this.map.h) {
            const tile = this.map.tiles[ty * this.map.w + tx];
            if (tile === 0) { // floor tile
              const worldX = tx * this.map.size + this.map.size / 2;
              const worldY = ty * this.map.size + this.map.size / 2;
              
              // Check distance from streamer (not too close, not too far)
              const dist = Math.hypot(worldX - streamerPos.x, worldY - streamerPos.y);
              if (dist > 150 && dist < 400) {
                candidates.push({ x: worldX, y: worldY });
              }
            }
          }
        }
      }
      
      if (candidates.length > 0) {
        return candidates[Math.floor(Math.random() * candidates.length)];
      }
    }
    
    return null;
  }
  
  updateAIZombies(now: number) {
    const streamer = [...this.players.values()].find(p => p.role === "streamer");
    const dt = this.tickMs / 1000;
    
    for (let i = this.aiZombies.length - 1; i >= 0; i--) {
      const zombie = this.aiZombies[i];
      
      // Remove dead zombies
      if (zombie.hp <= 0) {
        // Drop random pickup (ammo or treasure) - only if drop chance succeeds
        const dropType = this.getRandomZombieDrop();
        if (dropType) {
          this.pickups.push({ 
            id: crypto.randomUUID().slice(0, 6), 
            type: dropType, 
            x: zombie.pos.x, 
            y: zombie.pos.y 
          });
        }
        this.aiZombies.splice(i, 1);
        continue;
      }
      
      if (!streamer) {
        zombie.state = "idle";
        continue;
      }
      
      const distToStreamer = Math.hypot(zombie.pos.x - streamer.pos.x, zombie.pos.y - streamer.pos.y);
      const hasLineOfSight = this.hasLineOfSight(zombie.pos, streamer.pos);
      
      // State machine
      switch (zombie.state) {
        case "idle":
          if (distToStreamer <= zombie.detectionRange && hasLineOfSight) {
            zombie.state = "chasing";
            zombie.targetId = streamer.id;
            zombie.lastSeen = now;
          }
          break;
          
        case "chasing":
          if (distToStreamer > zombie.chaseRange) {
            zombie.state = "idle";
            zombie.targetId = undefined;
          } else if (distToStreamer <= 20) {
            zombie.state = "attacking";
            zombie.lastAttack = now;
          } else if (hasLineOfSight) {
            zombie.lastSeen = now;
          }
          break;
          
        case "attacking":
          if (distToStreamer > 30) {
            zombie.state = "chasing";
          } else if (now - zombie.lastAttack > 1000) { // Attack every second
            this.aiZombieAttackStreamer(zombie, streamer, now);
            zombie.lastAttack = now;
          }
          break;
      }
      
      // Movement AI
      this.updateAIZombieMovement(zombie, streamer, now, dt);
      
      // Apply movement with collision
      this.moveAIZombie(zombie, dt);
    }
  }
  
  hasLineOfSight(from: Vec, to: Vec): boolean {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const distance = Math.hypot(dx, dy);
    
    if (distance === 0) return true;
    
    const steps = Math.ceil(distance / 16); // Check every 16 pixels
    const stepX = dx / steps;
    const stepY = dy / steps;
    
    for (let i = 1; i < steps; i++) {
      const checkX = from.x + stepX * i;
      const checkY = from.y + stepY * i;
      
      // Check if this point intersects with walls
      for (const wall of this.walls) {
        if (checkX >= wall.x && checkX <= wall.x + wall.w &&
            checkY >= wall.y && checkY <= wall.y + wall.h) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  updateAIZombieMovement(zombie: AIZombie, streamer: Player, now: number, dt: number) {
    if (zombie.state === "idle") {
      zombie.vel.x = 0;
      zombie.vel.y = 0;
      return;
    }
    
    // Simple AI movement toward streamer
    const dx = streamer.pos.x - zombie.pos.x;
    const dy = streamer.pos.y - zombie.pos.y;
    const distance = Math.hypot(dx, dy);
    
    if (distance > 0) {
      const baseSpeed = this.cfg.speeds.zombie * this.cfg.zombies.speedMul[zombie.zClass];
      const speed = (this.zombieSlowUntil || 0) > now ? baseSpeed * this.cfg.speeds.zombieSlowMultiplier : baseSpeed;
      
      zombie.vel.x = (dx / distance) * speed;
      zombie.vel.y = (dy / distance) * speed;
    }
  }
  
  moveAIZombie(zombie: AIZombie, dt: number) {
    // Intended new position
    let nx = zombie.pos.x + zombie.vel.x * dt;
    let ny = zombie.pos.y + zombie.vel.y * dt;
    
    // Tile collision
    if (this.map) {
      const sz = this.map.size;
      const ix = Math.max(0, Math.min(this.map.w-1, Math.floor(nx / sz)));
      const iy = Math.max(0, Math.min(this.map.h-1, Math.floor(ny / sz)));
      const t = this.map.tiles[iy*this.map.w + ix] as TileId;
      
      const isSolid = (tt:TileId)=> tt===1 || tt===4; // wall or doorClosed
      const isLethal = (tt:TileId)=> tt===2; // pit
      const isSlow = (tt:TileId)=> tt===3; // water/sludge
      
      if (isSlow(t)) { 
        nx = zombie.pos.x + (zombie.vel.x * 0.6) * dt; 
        ny = zombie.pos.y + (zombie.vel.y * 0.6) * dt;
      }
      if (isSolid(t)) { 
        nx = zombie.pos.x; 
        ny = zombie.pos.y; 
      }
      if (isLethal(t)) {
        // Respawn zombie in a different location
        const newPos = this.getAIZombieSpawnPosition({ x: this.W/2, y: this.H/2 });
        if (newPos) {
          zombie.pos = newPos;
          return;
        }
      }
    }
    
    zombie.pos.x = Math.max(0, Math.min(this.W, nx));
    zombie.pos.y = Math.max(0, Math.min(this.H, ny));
    
    // Wall collision
    const pr = this.cfg.radii.zombie;
    for (const rct of this.walls) {
      const nearestX = Math.max(rct.x, Math.min(zombie.pos.x, rct.x + rct.w));
      const nearestY = Math.max(rct.y, Math.min(zombie.pos.y, rct.y + rct.h));
      let dx = zombie.pos.x - nearestX; 
      let dy = zombie.pos.y - nearestY; 
      let dist = Math.hypot(dx, dy);
      
      if (dist < pr) {
        if (dist === 0) {
          // Push out along smallest penetration axis
          const left = Math.abs(zombie.pos.x - rct.x);
          const right = Math.abs(rct.x + rct.w - zombie.pos.x);
          const top = Math.abs(zombie.pos.y - rct.y);
          const bottom = Math.abs(rct.y + rct.h - zombie.pos.y);
          const m = Math.min(left, right, top, bottom);
          if (m === left) zombie.pos.x = rct.x - pr;
          else if (m === right) zombie.pos.x = rct.x + rct.w + pr;
          else if (m === top) zombie.pos.y = rct.y - pr;
          else zombie.pos.y = rct.y + rct.h + pr;
        } else {
          const nx = dx / dist, ny = dy / dist;
          const push = (pr - dist) + 0.5;
          zombie.pos.x += nx * push; 
          zombie.pos.y += ny * push;
        }
      }
    }
  }
  
  aiZombieAttackStreamer(zombie: AIZombie, streamer: Player, now: number) {
    const shielded = ((streamer as any).shieldUntil || 0) > now;
    if (shielded) return;
    
    if ((streamer.hp ?? this.cfg.streamer.maxHp) > 0) {
      streamer.hp = Math.max(0, (streamer.hp ?? this.cfg.streamer.maxHp) - this.cfg.combat.zombieTouchDamage);
    }
    
    if ((streamer.hp ?? 0) <= 0) {
      // Respawn streamer; lose unbanked on death (keep banked)
      streamer.pos = this.spawnInRandomRoom();
      streamer.hp = streamer.maxHp ?? this.cfg.streamer.maxHp;
      streamer.score = 0;
    }
    
    // Knockback streamer slightly
    const dx = streamer.pos.x - zombie.pos.x; 
    const dy = streamer.pos.y - zombie.pos.y; 
    const d = Math.hypot(dx, dy) || 1;
    const kbMul = (zombie.zClass === 'brute') ? this.cfg.zombies.brute.extraKnockbackMul : 1;
    streamer.pos.x = Math.max(0, Math.min(this.W, streamer.pos.x + (dx / d) * this.cfg.combat.knockbackStep * kbMul));
    streamer.pos.y = Math.max(0, Math.min(this.H, streamer.pos.y + (dy / d) * this.cfg.combat.knockbackStep * kbMul));
  }

  broadcastState() {
    const snapshot = {
      type: "state",
      t: Date.now(),
      players: [...this.players.values()].map(this.publicPlayer),
      bullets: this.bullets.map(b => ({ id: b.id, x: b.pos.x, y: b.pos.y, ownerId: b.ownerId })),
      globs: this.spittles.map(g => ({ id: g.id, x: g.pos.x, y: g.pos.y })),
      walls: this.walls.map(o => ({ id: o.id, x: o.x, y: o.y, w: o.w, h: o.h })),
      pickups: this.pickups.map(pk => ({ id: pk.id, type: pk.type, x: pk.x, y: pk.y })),
            aiZombies: this.aiZombies.map(z => ({ 
        id: z.id, 
        x: z.pos.x, 
        y: z.pos.y, 
        hp: z.hp, 
        maxHp: z.maxHp, 
        zClass: z.zClass, 
        state: z.state,
        detectionRange: z.detectionRange,
        chaseRange: z.chaseRange
      })),
      arena: { w: this.W, h: this.H },
      remainingTime: Math.max(0, Math.floor(((this.roundEndTime || Date.now()) - Date.now()) / 1000)),
      chatEnabled: this.chatEnabled,
    };
    const msg = JSON.stringify(snapshot);
    for (const p of this.players.values()) {
      if (!p.ws) continue;
      try { p.ws.send(msg); } catch {}
    }
  }

  broadcast(type: string, payload: unknown) {
    const msg = JSON.stringify({ type, ...payload as any });
    for (const p of this.players.values()) {
      if (!p.ws) continue;
      try { p.ws.send(msg); } catch {}
    }
  }

  publicPlayer = (p: Player) => ({
    id: p.id,
    name: p.name,
    role: p.role,
    x: p.pos.x,
    y: p.pos.y,
    alive: p.alive,
    score: p.score,
    banked: p.banked ?? 0,
    hp: p.hp ?? 0,
    boosted: (p.boostUntil || 0) > Date.now(),
    ammo: p.ammo ?? 0,
    weaponed: (p.weaponBoostUntil || 0) > Date.now(),
    emote: p.emote || "",
    emoteUntil: p.emoteUntil || 0,
    weapon: p.weapon,
    pistolAmmo: p.pistolAmmo,
    smgAmmo: p.smgAmmo,
    shotgunAmmo: p.shotgunAmmo,
    meleeAt: p.lastMeleeAt || 0,
    meleeDirX: p.meleeDirX || 0,
    meleeDirY: p.meleeDirY || 0,
    // lightweight booleans for some visual hints (optional for clients)
    shielded: ((p as any).shieldUntil || 0) > Date.now(),
    magneted: ((p as any).magnetUntil || 0) > Date.now(),
    dashing: (p.dashUntil || 0) > Date.now(),
    lastDashAt: p.lastDashAt || 0,
    dashReadyAt: (p.lastDashAt || 0) + this.cfg.dash.cooldownMs,
    zClass: p.zClass || "",
  });

  sanitizeName(n: string) {
    if (!n) return "";
    const ok = n.replace(/[^a-zA-Z0-9 _-]/g, "").slice(0, 20);
    return ok.trim();
  }

  randomName() {
    const list = (this.env.TARKOV_NAMES || "").split(",").map(s => s.trim()).filter(Boolean);
    return list[Math.floor(Math.random() * list.length)] || "FactoryGhost";
  }

  spawnInRandomRoom(): Vec {
    // Spawn within a random room
    if (!this.map || this.map.rooms.length === 0) {
      // Fallback to center if no rooms available
      return { x: this.W / 2, y: this.H / 2 };
    }
    
    const room = this.map.rooms[Math.floor(Math.random() * this.map.rooms.length)];
    const tileSize = this.map.size;
    
    // Convert room coordinates to world coordinates and add some padding
    const padding = tileSize * 0.5; // Half tile padding from walls
    const worldX = (room.x + 1) * tileSize + padding + Math.random() * ((room.w - 2) * tileSize - padding * 2);
    const worldY = (room.y + 1) * tileSize + padding + Math.random() * ((room.h - 2) * tileSize - padding * 2);
    
    return { x: worldX, y: worldY };
  }

  spawnZombiePos(): Vec {
    return this.spawnInRandomRoom();
  }

  // Map generation and helpers
  generateTileMapAndWalls() {
    const size = this.cfg.tiles.size;
    const gw = Math.max(10, Math.floor(this.W / size));
    const gh = Math.max(8, Math.floor(this.H / size));
    const theme: 'dungeon'|'cave'|'lab' = this.cfg.tiles.theme || 'dungeon';
    const tiles = new Uint8Array(gw*gh);
    // Fill with walls (1)
    tiles.fill(1);
    // Carve simple BSP-like rooms and corridors
    const rooms: {x:number;y:number;w:number;h:number}[] = [];
    const carveRoom = (x:number,y:number,w:number,h:number)=>{
      for (let j=y; j<y+h; j++) for (let i=x; i<x+w; i++) if (i>0&&i<gw-1&&j>0&&j<gh-1) tiles[j*gw+i]=0;
      rooms.push({x,y,w,h});
    };
    // Generate many more rooms using grid-based layout
    const gridCellsX = Math.floor(gw / 20); // Cells of ~20 tiles each
    const gridCellsY = Math.floor(gh / 15);
    const cellWidth = Math.floor(gw / gridCellsX);
    const cellHeight = Math.floor(gh / gridCellsY);
    
    // Room types for variety
    const roomTypes = ['small', 'medium', 'large', 'hall', 'chamber', 'vault'];
    
    for (let gy = 0; gy < gridCellsY; gy++) {
      for (let gx = 0; gx < gridCellsX; gx++) {
        // 70% chance to place a room in each grid cell
        if (Math.random() < 0.7) {
          const baseX = gx * cellWidth;
          const baseY = gy * cellHeight;
          const roomType = roomTypes[Math.floor(Math.random() * roomTypes.length)];
          
          let rw, rh;
          switch(roomType) {
            case 'small':
              rw = 5 + Math.floor(Math.random() * 4); // 5-8
              rh = 4 + Math.floor(Math.random() * 3); // 4-6
              break;
            case 'medium':
              rw = 8 + Math.floor(Math.random() * 5); // 8-12
              rh = 6 + Math.floor(Math.random() * 4); // 6-9
              break;
            case 'large':
              rw = 12 + Math.floor(Math.random() * 6); // 12-17
              rh = 8 + Math.floor(Math.random() * 5); // 8-12
              break;
            case 'hall':
              rw = 15 + Math.floor(Math.random() * 8); // 15-22 (long halls)
              rh = 4 + Math.floor(Math.random() * 2); // 4-5 (narrow)
              break;
            case 'chamber':
              rw = 10 + Math.floor(Math.random() * 4); // 10-13 (square-ish)
              rh = 9 + Math.floor(Math.random() * 4); // 9-12
              break;
            case 'vault':
              rw = 6 + Math.floor(Math.random() * 3); // 6-8 (small but important)
              rh = 5 + Math.floor(Math.random() * 2); // 5-6
              break;
            default:
              rw = 8 + Math.floor(Math.random() * 4);
              rh = 6 + Math.floor(Math.random() * 3);
          }
          
          // Ensure room fits in grid cell with margin
          rw = Math.min(rw, cellWidth - 2);
          rh = Math.min(rh, cellHeight - 2);
          
          const rx = baseX + 1 + Math.floor(Math.random() * Math.max(1, cellWidth - rw - 2));
          const ry = baseY + 1 + Math.floor(Math.random() * Math.max(1, cellHeight - rh - 2));
          
          // Ensure room is within bounds
          if (rx + rw < gw - 1 && ry + rh < gh - 1) {
            carveRoom(rx, ry, rw, rh);
          }
        }
      }
    }
    // Create extensive corridor network to connect rooms
    // First, connect adjacent rooms in grid for guaranteed connectivity
    for (let gy = 0; gy < gridCellsY; gy++) {
      for (let gx = 0; gx < gridCellsX; gx++) {
        const currentRooms = rooms.filter(r => 
          r.x >= gx * cellWidth && r.x < (gx + 1) * cellWidth &&
          r.y >= gy * cellHeight && r.y < (gy + 1) * cellHeight
        );
        
        if (currentRooms.length === 0) continue;
        const currentRoom = currentRooms[0];
        
        // Connect to right neighbor
        if (gx < gridCellsX - 1) {
          const rightRooms = rooms.filter(r => 
            r.x >= (gx + 1) * cellWidth && r.x < (gx + 2) * cellWidth &&
            r.y >= gy * cellHeight && r.y < (gy + 1) * cellHeight
          );
          
          if (rightRooms.length > 0) {
            const rightRoom = rightRooms[0];
            const corridorY = Math.floor((currentRoom.y + currentRoom.h/2 + rightRoom.y + rightRoom.h/2) / 2);
            const corridorWidth = 2 + Math.floor(Math.random() * 2);
            
            for (let offset = -Math.floor(corridorWidth/2); offset <= Math.floor(corridorWidth/2); offset++) {
              const cy = corridorY + offset;
              if (cy > 0 && cy < gh - 1) {
                for (let cx = currentRoom.x + currentRoom.w; cx < rightRoom.x; cx++) {
                  if (cx > 0 && cx < gw - 1) tiles[cy * gw + cx] = 0;
                }
              }
            }
          }
        }
        
        // Connect to bottom neighbor
        if (gy < gridCellsY - 1) {
          const bottomRooms = rooms.filter(r => 
            r.x >= gx * cellWidth && r.x < (gx + 1) * cellWidth &&
            r.y >= (gy + 1) * cellHeight && r.y < (gy + 2) * cellHeight
          );
          
          if (bottomRooms.length > 0) {
            const bottomRoom = bottomRooms[0];
            const corridorX = Math.floor((currentRoom.x + currentRoom.w/2 + bottomRoom.x + bottomRoom.w/2) / 2);
            const corridorWidth = 2 + Math.floor(Math.random() * 2);
            
            for (let offset = -Math.floor(corridorWidth/2); offset <= Math.floor(corridorWidth/2); offset++) {
              const cx = corridorX + offset;
              if (cx > 0 && cx < gw - 1) {
                for (let cy = currentRoom.y + currentRoom.h; cy < bottomRoom.y; cy++) {
                  if (cy > 0 && cy < gh - 1) tiles[cy * gw + cx] = 0;
                }
              }
            }
          }
        }
      }
    }
    
    // Add random long-distance connections for shortcuts and loops
    const numLongConnections = Math.floor(rooms.length * 0.15); // 15% of rooms get long connections
    for (let i = 0; i < numLongConnections; i++) {
      const roomA = rooms[Math.floor(Math.random() * rooms.length)];
      const roomB = rooms[Math.floor(Math.random() * rooms.length)];
      
      if (roomA === roomB) continue;
      
      const ax = Math.floor(roomA.x + roomA.w/2);
      const ay = Math.floor(roomA.y + roomA.h/2);
      const bx = Math.floor(roomB.x + roomB.w/2);
      const by = Math.floor(roomB.y + roomB.h/2);
      
      // Create L-shaped corridor
      const corridorWidth = 2;
      
      // Horizontal segment
      const minx = Math.min(ax, bx);
      const maxx = Math.max(ax, bx);
      for (let offset = -Math.floor(corridorWidth/2); offset <= Math.floor(corridorWidth/2); offset++) {
        const cy = ay + offset;
        if (cy > 0 && cy < gh - 1) {
          for (let cx = minx; cx <= maxx; cx++) {
            if (cx > 0 && cx < gw - 1) tiles[cy * gw + cx] = 0;
          }
        }
      }
      
      // Vertical segment
      const miny = Math.min(ay, by);
      const maxy = Math.max(ay, by);
      for (let offset = -Math.floor(corridorWidth/2); offset <= Math.floor(corridorWidth/2); offset++) {
        const cx = bx + offset;
        if (cx > 0 && cx < gw - 1) {
          for (let cy = miny; cy <= maxy; cy++) {
            if (cy > 0 && cy < gh - 1) tiles[cy * gw + cx] = 0;
          }
        }
      }
    }
    
    // Add environmental variety
    // Water/sludge areas (slow movement)
    const numWaterAreas = Math.floor(rooms.length * 0.08);
    for (let i = 0; i < numWaterAreas; i++) {
      const wx = 3 + Math.floor(Math.random() * (gw - 10));
      const wy = 3 + Math.floor(Math.random() * (gh - 8));
      const ww = 3 + Math.floor(Math.random() * 6);
      const wh = 2 + Math.floor(Math.random() * 5);
      
      for (let j = wy; j < wy + wh && j < gh - 1; j++) {
        for (let i = wx; i < wx + ww && i < gw - 1; i++) {
          if (tiles[j * gw + i] === 0) { // Only replace floor tiles
            tiles[j * gw + i] = 3; // Water/sludge
          }
        }
      }
    }
    
    // Pit traps (lethal)
    const numPits = Math.floor(rooms.length * 0.05);
    for (let i = 0; i < numPits; i++) {
      const px = 2 + Math.floor(Math.random() * (gw - 6));
      const py = 2 + Math.floor(Math.random() * (gh - 6));
      
      if (tiles[py * gw + px] === 0) {
        tiles[py * gw + px] = 2; // Pit
        // Sometimes create larger pit areas
        if (Math.random() < 0.4) {
          const pitSize = 1 + Math.floor(Math.random() * 2);
          for (let dy = 0; dy <= pitSize && py + dy < gh - 1; dy++) {
            for (let dx = 0; dx <= pitSize && px + dx < gw - 1; dx++) {
              if (tiles[(py + dy) * gw + (px + dx)] === 0) {
                tiles[(py + dy) * gw + (px + dx)] = 2;
              }
            }
          }
        }
      }
    }
    // Add border walls kept
    // Props/Lights - Scale with map size for immersive exploration
    const props: {x:number;y:number;type:'crate'|'pillar'|'bonepile'}[] = [];
    const lights: {x:number;y:number;r:number;a:number}[] = [];
    
    // Scale props with map size - aim for 1 prop per ~300 tiles
    const numProps = Math.floor((gw * gh) / 300);
    for (let k = 0; k < numProps; k++){
      props.push({ 
        x: 2 + Math.floor(Math.random() * (gw - 4)), 
        y: 2 + Math.floor(Math.random() * (gh - 4)), 
        type: (['crate','pillar','bonepile'] as const)[Math.floor(Math.random() * 3)] 
      });
    }
    
    // Scale lights with map size - more atmospheric lighting for exploration
    const numLights = Math.floor((gw * gh) / 500);
    for (let k = 0; k < numLights; k++){
      lights.push({ 
        x: 2 + Math.floor(Math.random() * (gw - 4)), 
        y: 2 + Math.floor(Math.random() * (gh - 4)), 
        r: 3 + Math.floor(Math.random() * 8), 
        a: 0.08 + Math.random() * 0.25 
      });
    }
    this.map = { w: gw, h: gh, size, theme, tiles, props, lights, rooms };
    // Derive collision rects from wall tiles via greedy merge
    this.walls = this.greedyRectsFromTiles(tiles, gw, gh, size);
    this.mapReady = true;
  }

  greedyRectsFromTiles(tiles: Uint8Array, gw:number, gh:number, size:number): Rect[] {
    const used = new Uint8Array(gw*gh);
    const rects: Rect[] = [];
    const isWall = (x:number,y:number)=> x>=0&&y>=0&&x<gw&&y<gh && tiles[y*gw+x]===1;
    for (let y=0;y<gh;y++){
      for (let x=0;x<gw;x++){
        const idx=y*gw+x;
        if (used[idx]) continue;
        if (!isWall(x,y)) continue;
        // grow width
        let w=1;
        while (isWall(x+w,y) && !used[y*gw + (x+w)]) w++;
        // grow height while full row of width
        let h=1; outer: while (y+h<gh){
          for (let xx=0; xx<w; xx++){ if (!isWall(x+xx,y+h) || used[(y+h)*gw+(x+xx)]) break outer; }
          h++;
        }
        for (let yy=0; yy<h; yy++) for (let xx=0; xx<w; xx++) used[(y+yy)*gw+(x+xx)]=1;
        rects.push({ id: crypto.randomUUID().slice(0,6), x: x*size, y: y*size, w: w*size, h: h*size });
      }
    }
    return rects;
  }

  u8ToBase64(u8: Uint8Array){
    // Convert to base64 without Buffer
    let s='';
    for (let i=0;i<u8.length;i++) s += String.fromCharCode(u8[i]);
    // @ts-ignore
    if (typeof btoa === 'function') return btoa(s);
    // Fallback simple base64
    // minimal polyfill
    // This is a light path; environment should have btoa.
    return (globalThis as any).Buffer ? (globalThis as any).Buffer.from(u8).toString('base64') : s;
  }

  randomFreePos(buffer = 24): Vec | null {
    for (let tries = 0; tries < 40; tries++) {
      const x = buffer + Math.random() * (this.W - buffer * 2);
      const y = buffer + Math.random() * (this.H - buffer * 2);
      // Not too close to center spawn
      if (Math.hypot(x - this.W/2, y - this.H/2) < 60) continue;
      let ok = true;
      for (const rct of this.walls) {
        const margin = 18;
        if (x > rct.x - margin && x < rct.x + rct.w + margin && y > rct.y - margin && y < rct.y + rct.h + margin) { ok = false; break; }
      }
      if (!ok) continue;
      return { x, y };
    }
    return null;
  }

  // Lag compensation method
  processInputWithLagCompensation(player: Player, input: Input, timestamp: number) {
    const now = Date.now();
    
    // Calculate lag
    if (player.lastInputTime) {
      const timeDiff = now - player.lastInputTime;
      player.lagMs = Math.max(0, Math.min(500, timeDiff)); // Cap at 500ms
    }
    
    // Store input in buffer for potential rollback
    if (!player.inputBuffer) player.inputBuffer = [];
    player.inputBuffer.push({ input: { ...input }, timestamp });
    
    // Keep only recent inputs (1 second)
    const cutoff = now - 1000;
    player.inputBuffer = player.inputBuffer.filter(i => i.timestamp > cutoff);
    
    // Apply input immediately (server authoritative)
    player.input = input;
    player.lastInputTime = now;
  }

  circleIntersectsAnyWall(x:number,y:number,r:number){
    for (const w of this.walls){
      const nx = Math.max(w.x, Math.min(x, w.x+w.w));
      const ny = Math.max(w.y, Math.min(y, w.y+w.h));
      if (Math.hypot(x-nx,y-ny) < r) return true;
    }
    return false;
  }

  okDistanceFromPickups(x:number,y:number,minD:number){
    for (const p of this.pickups){ if (Math.hypot(x-p.x,y-p.y) < minD) return false; }
    return true;
  }

  pickZombieClass(): "runner" | "brute" | "spitter" {
    const w = this.cfg.zombies.weights;
    const bag: Array<"runner"|"brute"|"spitter"> = [];
    for (let i=0;i<w.runner;i++) bag.push('runner');
    for (let i=0;i<w.brute;i++) bag.push('brute');
    for (let i=0;i<w.spitter;i++) bag.push('spitter');
    return bag[Math.floor(Math.random()*bag.length)] || 'runner';
  }

  randRange(a:number,b:number){ return a + Math.floor(Math.random()*(b-a+1)); }

  // Extractions removed
  spawnExtractions() { /* no-op */ }

  // Get all rooms accessible from a starting tile position
  getAccessibleRooms(startX: number, startY: number): Array<{x: number; y: number; w: number; h: number}> {
    if (!this.map || !this.map.rooms) return [];
    
    // Use flood fill to find all reachable tiles
    const reachable = new Set<string>();
    const queue: Array<[number, number]> = [[startX, startY]];
    const visited = new Set<string>();
    
    const isWalkable = (x: number, y: number): boolean => {
      if (x < 0 || x >= this.map!.w || y < 0 || y >= this.map!.h) return false;
      const tile = this.map!.tiles[y * this.map!.w + x];
      return tile === 0; // Only floor tiles (no doors since we removed them)
    };
    
    while (queue.length > 0) {
      const [x, y] = queue.shift()!;
      const key = `${x},${y}`;
      
      if (visited.has(key)) continue;
      visited.add(key);
      
      if (!isWalkable(x, y)) continue;
      
      reachable.add(key);
      
      // Add adjacent tiles
      const neighbors = [[x+1,y], [x-1,y], [x,y+1], [x,y-1]];
      for (const [nx, ny] of neighbors) {
        const nKey = `${nx},${ny}`;
        if (!visited.has(nKey)) {
          queue.push([nx, ny]);
        }
      }
    }
    
    // Find which rooms contain reachable tiles
    const accessibleRooms: Array<{x: number; y: number; w: number; h: number}> = [];
    
    for (const room of this.map.rooms) {
      let hasReachableTile = false;
      
      for (let ty = room.y; ty < room.y + room.h && !hasReachableTile; ty++) {
        for (let tx = room.x; tx < room.x + room.w && !hasReachableTile; tx++) {
          if (reachable.has(`${tx},${ty}`)) {
            hasReachableTile = true;
          }
        }
      }
      
      if (hasReachableTile) {
        accessibleRooms.push(room);
      }
    }
    
    return accessibleRooms;
  }

  // Flood fill to find all tiles reachable from starting position
  getReachableTiles(startX: number, startY: number): Set<string> {
    if (!this.map) return new Set();
    
    const reachable = new Set<string>();
    const queue: Array<[number, number]> = [[startX, startY]];
    const visited = new Set<string>();
    
    const isWalkable = (x: number, y: number): boolean => {
      if (x < 0 || x >= this.map!.w || y < 0 || y >= this.map!.h) return false;
      const tile = this.map!.tiles[y * this.map!.w + x];
      return tile === 0 || tile === 5; // floor or doorOpen
    };
    
    while (queue.length > 0) {
      const [x, y] = queue.shift()!;
      const key = `${x},${y}`;
      
      if (visited.has(key)) continue;
      visited.add(key);
      
      if (!isWalkable(x, y)) continue;
      
      reachable.add(key);
      
      // Add adjacent tiles to queue
      const neighbors = [[x+1,y], [x-1,y], [x,y+1], [x,y-1]];
      for (const [nx, ny] of neighbors) {
        const nKey = `${nx},${ny}`;
        if (!visited.has(nKey)) {
          queue.push([nx, ny]);
        }
      }
    }
    
    return reachable;
  }

  rotateExtractionIfNeeded(nowMs: number) { /* no-op */ }
}
</file>

</files>
