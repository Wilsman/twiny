This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: */old-working/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
AGENTS.md
package.json
public/common.js
public/index.html
public/join.html
public/streamer.html
public/styles.css
README.md
src/config.ts
src/room.ts
src/room/index.ts
src/room/room-types.ts
src/room/systems/ai-zombies.ts
src/room/systems/bosses.ts
src/room/systems/broadcast.ts
src/room/systems/combat.ts
src/room/systems/input.ts
src/room/systems/map.ts
src/room/systems/pickups.ts
src/room/systems/stats.ts
src/room/systems/update.ts
src/room/systems/upgrades.ts
src/room/systems/zombie-abilities.ts
src/room/utils/names.ts
src/types.ts
src/upgrades.ts
src/worker.ts
wrangler.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="package.json">
{
  "devDependencies": {
    "wrangler": "^4.35.0"
  }
}
</file>

<file path="README.md">
# Cloudflare Arena Shooter (Streamer vs. Chat Zombies)

Ultra-minimal top-down arena where the **streamer** moves fast and shoots; **chat** joins via a link and plays slow **zombies**. Built on **Cloudflare Workers + Durable Objects** with raw **WebSockets**. Static HTML served by Pages (or any static host).

## Features
- Rooms keyed by URL (e.g. `/ws/abcd12`) with one DO instance per room.
- Streamer: WASD + mouse aim + click to shoot.
- Chat: WASD movement as slow zombies; on touch, streamer loses 1 score.
- Server-authoritative positions; 20Hz snapshots.

## Run locally
```bash
npm create cloudflare@latest . # or `npm i -D wrangler`
wrangler dev
```
Open `http://127.0.0.1:8787/streamer.html` and click **Create Room**. Share the generated `join.html?room=XXXXXX` link.

> If serving static files from another host (e.g. Pages), ensure the Worker is reachable at the same domain (or adjust `public/*.html` to point to your Worker origin).

## Deploy
1. `wrangler deploy`
2. Host `/public` with Cloudflare Pages **or** serve them elsewhere.
3. Point your domain routes to the Worker (`/ws/*`, `/create`).

## Notes
- This is intentionally minimal: no authentication, no persistence beyond DO lifetime.
- For cost/scale, consider Durable Object WebSocket hibernation and backoff reconnects.
- Security: names are sanitized; inputs are rate-limited implicitly by tick; add explicit token bucket if you expect abuse.

## Customize
- Speeds, radii, arena size in `src/room.ts`.
- Add scoreboard UI, streamer-only control panel, zombie cosmetics, etc.
</file>

<file path="src/room/index.ts">
// Minimal top-down arena shooter: one Streamer (fast marine) vs many Chat Zombies (slow).
// Server maintains authoritative positions and scores. 20Hz tick.

declare global {
  interface WebSocket {
    accept(): void;
  }
  interface ResponseInit {
    webSocket?: WebSocket;
  }
  class WebSocketPair {
    0: WebSocket;
    1: WebSocket;
  }
  interface DurableObjectState {
    // Define properties as needed
  }
}

export interface Env {
  TARKOV_NAMES: string;
}

import { XP_THRESHOLDS, MOD_INDEX, statsFor } from '../upgrades';
import type { ActiveBullet, BulletSpawnSpec, Boss, BossMinion, PoisonField, BossType, ModId } from '../types';
import type { Vec, Input, Player, Rect, Pickup, PickupType, AIZombie } from './room-types';

type Bullet = ActiveBullet;

import { CONFIG, TileId, type GameConfig } from '../config';
import { checkPickupSpawning as checkPickupSpawningImpl, getRandomZombieDrop as getRandomZombieDropImpl, getTreasureValue as getTreasureValueImpl } from './systems/pickups';
import { processUpgradeEffects as processUpgradeEffectsImpl, offerUpgrades as offerUpgradesImpl, applyUpgrade as applyUpgradeImpl } from './systems/upgrades';
import { createExplosion as createExplosionImpl, spawnSmallExplosion as spawnSmallExplosionImpl, addDamageNumber as addDamageNumberImpl, processDotEffects as processDotEffectsImpl, refundAmmoOnKill as refundAmmoOnKillImpl, applyChainDamage as applyChainDamageImpl } from './systems/combat';
import { processZombieAbilities as processZombieAbilitiesImpl, bomberExplode as bomberExplodeImpl, bomberExplodeAI as bomberExplodeAIImpl } from './systems/zombie-abilities';
import { spawnAIZombiesIfNeeded as spawnAIZombiesIfNeededImpl, updateAIZombies as updateAIZombiesImpl, getAIZombieSpawnPosition as getAIZombieSpawnPositionImpl, updateAIZombieMovement as updateAIZombieMovementImpl, moveAIZombie as moveAIZombieImpl, aiZombieAttackStreamer as aiZombieAttackStreamerImpl, hasLineOfSight as hasLineOfSightImpl } from './systems/ai-zombies';
import { update as updateImpl } from './systems/update';
import { generateTileMapAndWalls as generateTileMapAndWallsImpl, spawnInRandomRoom as spawnInRandomRoomImpl, spawnZombiePos as spawnZombiePosImpl, randomFreePos as randomFreePosImpl } from './systems/map';
import { processInputWithLagCompensation as processInputWithLagCompensationImpl } from './systems/input';
import { updateBossSystem as updateBossSystemImpl, spawnRandomBoss as spawnRandomBossImpl, updateBoss as updateBossImpl, processBossAbilities as processBossAbilitiesImpl, necromancerSummon as necromancerSummonImpl, necromancerTeleport as necromancerTeleportImpl, necromancerPoisonField as necromancerPoisonFieldImpl, bruteKingCharge as bruteKingChargeImpl, bruteKingGroundSlam as bruteKingGroundSlamImpl, shadowLordPhase as shadowLordPhaseImpl, shadowLordClones as shadowLordClonesImpl, shadowLordLifeDrain as shadowLordLifeDrainImpl, updateBossMinions as updateBossMinionsImpl, updatePoisonFields as updatePoisonFieldsImpl, onBossDeath as onBossDeathImpl, generateBossLoot as generateBossLootImpl, publicBoss as publicBossImpl } from './systems/bosses';
import { initRaidStats as initRaidStatsImpl, trackEnemyKill as trackEnemyKillImpl, trackBossKill as trackBossKillImpl, trackBulletFired as trackBulletFiredImpl, trackBulletHit as trackBulletHitImpl, trackDamageDealt as trackDamageDealtImpl, trackDamageTaken as trackDamageTakenImpl, trackPickupTaken as trackPickupTakenImpl, trackXPGained as trackXPGainedImpl } from './systems/stats';
import { broadcastState as broadcastStateImpl } from './systems/broadcast';
import { sanitizeName as sanitizeNameImpl, randomName as randomNameImpl } from './utils/names';


export class RoomDO {
  state: DurableObjectState;
  env: Env;

  // Config (per-room, overridable)
  cfg: GameConfig = JSON.parse(JSON.stringify(CONFIG));

  // Game space
  W = CONFIG.arena.width; // px (updated when cfg changes)
  H = CONFIG.arena.height; // px (updated when cfg changes)

  // Entities
  players = new Map<string, Player>();
  bullets: Bullet[] = [];
  // Spitter globs (enemy projectiles)
  spittles: Array<{ id: string; pos: Vec; vel: Vec; ttl: number } > = [];
  walls: Rect[] = [];
  pickups: Pickup[] = [];
  // M1: extractions and optional future zones
  extractions: Extraction[] = [];
  midSafeZones: Rect[] = [];
  // AI Zombie properties
  aiZombies: AIZombie[] = [];
  maxAIZombies = CONFIG.aiZombies.maxCount;
  aiZombieSpawnCooldown = CONFIG.aiZombies.spawnCooldownMs;
  lastAIZombieSpawn = 0;
  // Boss system properties
  bosses: Boss[] = [];
  bossMinions: BossMinion[] = [];
  poisonFields: PoisonField[] = [];
  lastBossSpawn = 0;
  nextBossAnnouncement?: number;
  bossSpawnCooldown = CONFIG.bosses.spawnIntervalMs;
  // Damage numbers for visual feedback
  damageNumbers: Array<{id: string; x: number; y: number; damage: number; isCrit: boolean; isDot: boolean; timestamp: number}> = [];
  // Tilemap state
  map: { w:number; h:number; size:number; theme: 'dungeon'|'cave'|'lab'; tiles: Uint8Array; lights: {x:number;y:number;r:number;a:number}[]; props:{x:number;y:number;type:'crate'|'pillar'|'bonepile'}[]; rooms:{x:number;y:number;w:number;h:number}[] } | null = null;

  // Loop - Different tick rates for different systems
  tickMs = CONFIG.ticks.mainMs; // updated when cfg changes
  uiTickMs = 200; // 5Hz - UI updates
  pickupTickMs = CONFIG.ticks.pickupMs; // updated when cfg changes
  running = false;
  loopTimer: number | undefined;
  uiTimer: number | undefined;
  pickupTimer: number | undefined;
  FIRE_COOLDOWN_MS = 180; // legacy; specific cooldowns in CONFIG
  lastPickupSpawn = Date.now();
  pickupIntervalMs = CONFIG.pickups.spawnIntervalMs; // updated when cfg changes
  mapReady = false;
  roundEndTime: number | undefined;
  roundDurationMs = CONFIG.round.durationMs; // updated when cfg changes
    // Global effects
  zombieSlowUntil: number | undefined;
  chatEnabled = true;
  // Extraction rotation pacing from config

  // Metadata
  createdAt = Date.now();

  constructor(state: DurableObjectState, env: Env) {
    this.state = state;
    this.env = env;
  }

  async fetch(req: Request) {
    // Handle setup for per-room overrides before any WS connections
    if (req.headers.get("Upgrade") !== "websocket") {
      try {
        const url = new URL(req.url);
        if (req.method === 'POST' && url.pathname.includes('/setup')) {
          const body = await req.json().catch(() => ({}));
          const overrides = body?.overrides || body?.config || body || {};
          if (overrides && typeof overrides === 'object') {
            this.applyOverrides(overrides);
            // Persist to storage if available
            try { (this.state as any).storage?.put('config', JSON.stringify(this.cfg)); } catch {}
            return new Response(JSON.stringify({ ok: true }), { headers: { 'content-type': 'application/json' } });
          }
          return new Response(JSON.stringify({ ok: false, error: 'invalid overrides' }), { status: 400, headers: { 'content-type': 'application/json' } });
        }
      } catch {}
      return new Response("Expected WebSocket", { status: 426 });
    }

    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair) as [WebSocket, WebSocket];
    server.accept();

    // Assign a temporary id; role determined on join message
    const pid = crypto.randomUUID().slice(0, 8);

    // Track WS
    server.addEventListener("message", (ev) => this.onMessage(server, pid, ev));
    server.addEventListener("close", () => this.onClose(pid));

    // Kick off ping
    const pingIv = setInterval(() => {
      try { server.send(JSON.stringify({ type: "ping" })); } catch {}
    }, 15000);
    server.addEventListener("close", () => clearInterval(pingIv));

    // Start loop on demand
    if (!this.running) this.startLoop();
    if (!this.mapReady) this.generateTileMapAndWalls();

    return new Response(null, { status: 101, webSocket: client });
  }

  applyOverrides(partial: any) {
    const deepMerge = (t: any, s: any) => {
      if (!s || typeof s !== 'object') return t;
      for (const k of Object.keys(s)) {
        const sv = s[k];
        if (sv && typeof sv === 'object' && !Array.isArray(sv)) {
          t[k] = deepMerge(t[k] ?? {}, sv);
        } else {
          t[k] = sv;
        }
      }
      return t;
    };
    this.cfg = deepMerge(JSON.parse(JSON.stringify(this.cfg)), partial);
    // Update derived fields used elsewhere
    this.W = this.cfg.arena.width;
    this.H = this.cfg.arena.height;
    this.tickMs = this.cfg.ticks.mainMs;
    this.pickupTickMs = this.cfg.ticks.pickupMs;
    this.pickupIntervalMs = this.cfg.pickups.spawnIntervalMs;
    this.roundDurationMs = this.cfg.round.durationMs;
    this.maxAIZombies = this.cfg.aiZombies.maxCount;
    this.aiZombieSpawnCooldown = this.cfg.aiZombies.spawnCooldownMs;
    // Force map regeneration on next loop if tiles changed
    this.mapReady = false;
  }

  startLoop() {
    this.running = true;
    if (!this.roundEndTime) this.roundEndTime = Date.now() + this.roundDurationMs;
    
    // Main game loop - 20Hz (includes state broadcast for responsiveness)
    const step = () => {
      this.update();
      this.broadcastState();
      this.loopTimer = setTimeout(step, this.tickMs) as unknown as number;
    };
    this.loopTimer = setTimeout(step, this.tickMs) as unknown as number;
    
    // Pickup spawning - 2Hz (non-critical)
    const pickupStep = () => {
      this.checkPickupSpawning();
      this.pickupTimer = setTimeout(pickupStep, this.pickupTickMs) as unknown as number;
    };
    this.pickupTimer = setTimeout(pickupStep, this.pickupTickMs) as unknown as number;
  }

  stopLoop() {
    if (this.loopTimer) clearTimeout(this.loopTimer as unknown as number);
    if (this.pickupTimer) clearTimeout(this.pickupTimer as unknown as number);
    this.running = false;
  }

  // Separate pickup spawning logic for reduced tick rate
  checkPickupSpawning() {
    return checkPickupSpawningImpl(this);
  }


  onMessage(ws: WebSocket, pid: string, ev: MessageEvent) {
    try {
      const msg = JSON.parse(String(ev.data));
      if (!msg || typeof msg !== "object") return;
      switch (msg.type) {
        case "join_room": {
          let role: "streamer" | "zombie" = msg.role === "streamer" ? "streamer" : "zombie";
          const name = this.sanitizeName(msg.name) || this.randomName();

          // Spawn positions
          const pos = role === "streamer" ? this.spawnInRandomRoom() : this.spawnZombiePos();

        const p: Player = {
          id: pid,
          role,
          name,
          pos,
          vel: { x: 0, y: 0 },
          input: { up: false, down: false, left: false, right: false, shoot: false, aimX: 0, aimY: 0, melee: false },
          ws,
          score: 0,
          alive: true,
          lastSeen: Date.now(),
          hp: role === "streamer" ? this.cfg.streamer.maxHp : undefined,
          maxHp: role === "streamer" ? this.cfg.streamer.maxHp : undefined,
          weapon: role === "streamer" ? "pistol" : undefined,
          pistolAmmo: role === "streamer" ? this.cfg.weapons.ammo.initial.pistol : undefined,
          smgAmmo: role === "streamer" ? 0 : undefined,
          shotgunAmmo: role === "streamer" ? 0 : undefined,
          banked: role === "streamer" ? 0 : undefined,
        };
        // Enforce single-streamer per room. Downgrade to zombie if already present.
        if (role === "streamer") {
          p.level = 0; p.xp = 0; p.mods = {};
          // Initialize raid stats
          this.initRaidStats(p);
          const hasStreamer = [...this.players.values()].some(pl => pl.role === "streamer");
          if (hasStreamer) {
            role = "zombie";
            p.role = "zombie";
            p.hp = undefined; p.maxHp = undefined; p.ammo = undefined; p.maxAmmo = undefined; p.weaponBoostUntil = undefined;
            p.weapon = undefined; p.pistolAmmo = undefined; p.smgAmmo = undefined; p.shotgunAmmo = undefined;
            p.pos = this.spawnZombiePos();
            try { ws.send(JSON.stringify({ type: "notice", message: "Streamer already active. You joined as a zombie." })); } catch {}
          }
        }
        // Assign class stats if zombie after potential downgrade
        if (p.role === 'zombie') {
          const zc = this.pickZombieClass();
          p.zClass = zc;
          const base = this.cfg.zombies.baseHp;
          p.zMaxHp = Math.max(1, Math.round(base * this.cfg.zombies.hpMul[zc]));
          p.zHp = p.zMaxHp;
          if (zc === 'spitter') {
            p.nextSpitAt = Date.now() + this.randRange(this.cfg.zombies.spitter.cooldownMsMin, this.cfg.zombies.spitter.cooldownMsMax);
          }
        }

        this.players.set(pid, p);

          ws.send(JSON.stringify({ type: "joined", playerId: pid, name, role, arena: { w: this.W, h: this.H } }));
          // Send map payload to the new client
          try {
            if (!this.map) this.generateTileMapAndWalls();
            if (this.map) {
              const base64 = this.u8ToBase64(this.map.tiles);
              ws.send(JSON.stringify({ type: 'map', map: { w: this.map.w, h: this.map.h, size: this.map.size, theme: this.map.theme, tilesBase64: base64, props: this.map.props, lights: this.map.lights } }));
            }
          } catch {}
          this.broadcast("players_update", { players: [...this.players.values()].map(this.publicPlayer) });
          break;
        }
        case "input": {
          const p = this.players.get(pid);
          if (!p) return;
          const now = Date.now();
          
          // Process input with lag compensation
          this.processInputWithLagCompensation(p, {
            up: !!msg.up,
            down: !!msg.down,
            left: !!msg.left,
            right: !!msg.right,
            shoot: !!msg.shoot,
            aimX: Number(msg.aimX) || 0,
            aimY: Number(msg.aimY) || 0,
            melee: !!msg.melee,
            dash: !!msg.dash,
          }, msg.timestamp || now);
          
          p.lastSeen = now;
          break;
        }
        case "ping": {
          const p = this.players.get(pid);
          if (!p) return;
          // Echo back ping for RTT measurement
          try {
            p.ws?.send(JSON.stringify({ type: 'pong', timestamp: msg.timestamp }));
          } catch {}
          break;
        }
        case "toggle_chat": {
          const p = this.players.get(pid);
          if (!p || p.role !== "streamer") return;
          // allow explicit boolean or toggle if omitted
          const desired = typeof msg.disabled === 'boolean' ? !msg.disabled : !this.chatEnabled;
          this.chatEnabled = desired;
          this.broadcast("notice", { message: this.chatEnabled ? "Chat enabled by streamer" : "Chat disabled by streamer" });
          break;
        }
        case "pong": {
          const p = this.players.get(pid); if (p) p.lastSeen = Date.now();
          break;
        }
        case "chat": {
          const p = this.players.get(pid);
          if (!p) return;
          if (!this.chatEnabled && p.role !== "streamer") return;
          this.broadcast("chat", { from: p.name, message: msg.message });
          break;
        }
        case "buy": {
          const p = this.players.get(pid);
          if (!p || p.role !== 'streamer') return;
          const item = String(msg.item||'');
          const cost = 300;
          const bank = p.banked || 0;
          if (item === 'shotgun') {
            if (bank >= cost) {
              p.banked = bank - cost;
              p.weapon = 'shotgun';
              p.shotgunAmmo = Math.max(p.shotgunAmmo||0, this.cfg.weapons.ammo.initial.shotgun);
              this.broadcast('notice', { message: `${p.name} purchased Shotgun! (-${cost} banked)` });
            } else {
              try { p.ws?.send(JSON.stringify({ type:'notice', message:`Not enough banked (need ${cost})` })); } catch {}
            }
          } else if (item === 'smg') {
            if (bank >= cost) {
              p.banked = bank - cost;
              p.weapon = 'smg';
              p.smgAmmo = Math.max(p.smgAmmo||0, this.cfg.weapons.ammo.initial.smg);
              this.broadcast('notice', { message: `${p.name} purchased SMG! (-${cost} banked)` });
            } else {
              try { p.ws?.send(JSON.stringify({ type:'notice', message:`Not enough banked (need ${cost})` })); } catch {}
            }
          }
          break;
        }
        case 'choose_upgrade': {
          const p = this.players.get(pid);
          if (!p || p.role !== 'streamer') return;
          const id = String(msg.id||'');
          if (!MOD_INDEX[id as keyof typeof MOD_INDEX]) return;
          this.applyUpgrade(p.id, id as any);
          break;
        }
        case "emote": {
          const p = this.players.get(pid);
          if (!p || p.role !== "zombie") return;
          const symbol = typeof msg.symbol === 'string' ? msg.symbol : '';
          // Allow only a small curated set of emojis
          const allowed = new Set(["Zombie","Skull","Fire","Joy","Love","Anger"]);
          if (!allowed.has(symbol)) return;
          const now = Date.now();
          p.emote = symbol;
          p.emoteUntil = now + 5000; // 5 seconds
          break;
        }
        case "switch_weapon": {
          const p = this.players.get(pid);
          if (!p || p.role !== "streamer") return;
          const w = String(msg.weapon || "");
          if (w === "pistol" || w === "smg" || w === "shotgun" || w === "bat") {
            p.weapon = w;
          }
          break;
        }
        // attempt_extract removed
      }
    } catch {}
  }

  onClose(pid: string) {
    const p = this.players.get(pid);
    if (!p) return;
    // Handle explosive death upgrade
    if (p.role === 'streamer' && p.mods) {
      const { s } = statsFor(p);
      if (s.explosiveDeathDamage > 0) {
        this.createExplosion(p.pos.x, p.pos.y, s.explosiveDeathDamage, 60, p.id);
      }
    }
    this.players.delete(pid);
    this.broadcast("players_update", { players: [...this.players.values()].map(this.publicPlayer) });
  }

  processUpgradeEffects(now: number) {
    return processUpgradeEffectsImpl(this, now);
  }

  
  createExplosion(x: number, y: number, damage: number, radius: number, ownerId: string) {
    return createExplosionImpl(this, x, y, damage, radius, ownerId);
  }

  
  processZombieAbilities(now: number) {
    return processZombieAbilitiesImpl(this, now);
  }

  
  bomberExplode(bomber: Player, now: number) {
    return bomberExplodeImpl(this, bomber, now);
  }

  
  bomberExplodeAI(bomber: AIZombie, now: number) {
    return bomberExplodeAIImpl(this, bomber, now);
  }

  
  addDamageNumber(x: number, y: number, damage: number, isCrit: boolean = false, isDot: boolean = false) {
    return addDamageNumberImpl(this, x, y, damage, isCrit, isDot);
  }


  update() {
    return updateImpl(this);
  }


  // AI Zombie methods
  spawnAIZombiesIfNeeded(now: number) {
    return spawnAIZombiesIfNeededImpl(this, now);
  }

  
  getRandomZombieDrop(): PickupType | null {
    return getRandomZombieDropImpl(this);
  }


  getTreasureValue(type: PickupType): number {
    return getTreasureValueImpl(this, type);
  }


  getAIZombieSpawnPosition(streamerPos: Vec): Vec | null {
    return getAIZombieSpawnPositionImpl(this, streamerPos);
  }

  
  updateAIZombies(now: number) {
    return updateAIZombiesImpl(this, now);
  }

  
  hasLineOfSight(from: Vec, to: Vec): boolean {
    return hasLineOfSightImpl(this, from, to);
  }

  
  updateAIZombieMovement(zombie: AIZombie, streamer: Player, now: number, dt: number) {
    return updateAIZombieMovementImpl(this, zombie, streamer, now, dt);
  }

  
  moveAIZombie(zombie: AIZombie, dt: number) {
    return moveAIZombieImpl(this, zombie, dt);
  }

  
  aiZombieAttackStreamer(zombie: AIZombie, streamer: Player, now: number) {
    return aiZombieAttackStreamerImpl(this, zombie, streamer, now);
  }


  broadcastState() {
    return broadcastStateImpl(this);
  }


  broadcast(type: string, payload: unknown) {
    const msg = JSON.stringify({ type, ...payload as any });
    for (const p of this.players.values()) {
      if (!p.ws) continue;
      try { p.ws.send(msg); } catch {}
    }
  }

  offerUpgrades(playerId: string) {
    return offerUpgradesImpl(this, playerId);
  }


  applyUpgrade(playerId: string, id: ModId) {
    return applyUpgradeImpl(this, playerId, id);
  }


  publicPlayer = (p: Player) => ({
    id: p.id,
    name: p.name,
    role: p.role,
    x: p.pos.x,
    y: p.pos.y,
    alive: p.alive,
    score: p.score,
    banked: p.banked ?? 0,
    hp: p.hp ?? 0,
    maxHp: p.role === "streamer" ? (p.maxHp ?? this.cfg.streamer.maxHp) : p.maxHp,
    boosted: (p.boostUntil || 0) > Date.now(),
    ammo: p.ammo ?? 0,
    weaponed: (p.weaponBoostUntil || 0) > Date.now(),
    emote: p.emote || "",
    emoteUntil: p.emoteUntil || 0,
    weapon: p.weapon,
    pistolAmmo: p.pistolAmmo,
    smgAmmo: p.smgAmmo,
    shotgunAmmo: p.shotgunAmmo,
    meleeAt: p.lastMeleeAt || 0,
    meleeDirX: p.meleeDirX || 0,
    meleeDirY: p.meleeDirY || 0,
    // lightweight booleans for some visual hints (optional for clients)
    shielded: ((p as any).shieldUntil || 0) > Date.now(),
    magneted: ((p as any).magnetUntil || 0) > Date.now(),
    dashing: (p.dashUntil || 0) > Date.now(),
    lastDashAt: p.lastDashAt || 0,
    dashReadyAt: (p.lastDashAt || 0) + this.cfg.dash.cooldownMs,
    zClass: p.zClass || "",
    level: p.level || 0,
    xp: p.xp || 0,
    xpForNext: XP_THRESHOLDS(p.level || 0),
    mods: Object.entries(p.mods || {}).map(([id, stacks]) => {
      const mod = MOD_INDEX[id as keyof typeof MOD_INDEX];
      return {
        id,
        stacks,
        name: mod?.name || id,
        desc: mod?.desc || "",
        rarity: mod?.rarity || "common",
      };
    }),
    raidStats: (p as any).raidStats || null,
  });

  // Optional effect used by some mods; small AoE damage on bullet hit
  spawnSmallExplosion(b: Bullet) {
    return spawnSmallExplosionImpl(this, b);
  }


  processDotEffects(now: number) {
    return processDotEffectsImpl(this, now);
  }


  // Refund ammo on kill based on current weapon and percentage
  refundAmmoOnKill(owner: Player, pct: number) {
    return refundAmmoOnKillImpl(this, owner, pct);
  }


  // Try to retarget a bullet toward the nearest zombie for ricochet
  retargetBulletRicochet(b: Bullet, excludeId: string): boolean {
    const speed = Math.hypot(b.vel.x, b.vel.y) || 1;
    const range = 220;
    let best: { x:number;y:number; id:string } | null = null;
    let bestD = Infinity;
    for (const z of this.players.values()){
      if (z.role !== 'zombie' || !z.alive) continue;
      if (z.id === excludeId) continue;
      const d = Math.hypot(z.pos.x - b.pos.x, z.pos.y - b.pos.y);
      if (d < range && d < bestD) { bestD = d; best = { x:z.pos.x, y:z.pos.y, id:z.id }; }
    }
    for (const z of this.aiZombies){
      const zid = 'ai:'+z.id; if (zid === excludeId) continue;
      const d = Math.hypot(z.pos.x - b.pos.x, z.pos.y - b.pos.y);
      if (d < range && d < bestD) { bestD = d; best = { x:z.pos.x, y:z.pos.y, id:zid }; }
    }
    if (!best) return false;
    const dx = best.x - b.pos.x; const dy = best.y - b.pos.y; const dd = Math.hypot(dx,dy) || 1;
    b.vel.x = (dx/dd) * speed; b.vel.y = (dy/dd) * speed;
    return true;
  }

  // Apply chain lightning damage bouncing to nearest targets
  applyChainDamage(b: Bullet, from: {x:number;y:number}, excludeId: string, count: number, dmg: number) {
    return applyChainDamageImpl(this, b, from, excludeId, count, dmg);
  }


  sanitizeName(n: string) {
    return sanitizeNameImpl(this, n);
  }


  randomName() {
    return randomNameImpl(this);
  }


  spawnInRandomRoom(): Vec {
    return spawnInRandomRoomImpl(this);
  }


  spawnZombiePos(): Vec {
    return spawnZombiePosImpl(this);
  }


  // Map generation and helpers
  generateTileMapAndWalls() {
    return generateTileMapAndWallsImpl(this);
  }


  greedyRectsFromTiles(tiles: Uint8Array, gw:number, gh:number, size:number): Rect[] {
    const used = new Uint8Array(gw*gh);
    const rects: Rect[] = [];
    const isWall = (x:number,y:number)=> x>=0&&y>=0&&x<gw&&y<gh && tiles[y*gw+x]===1;
    for (let y=0;y<gh;y++){
      for (let x=0;x<gw;x++){
        const idx=y*gw+x;
        if (used[idx]) continue;
        if (!isWall(x,y)) continue;
        // grow width
        let w=1;
        while (isWall(x+w,y) && !used[y*gw + (x+w)]) w++;
        // grow height while full row of width
        let h=1; outer: while (y+h<gh){
          for (let xx=0; xx<w; xx++){ if (!isWall(x+xx,y+h) || used[(y+h)*gw+(x+xx)]) break outer; }
          h++;
        }
        for (let yy=0; yy<h; yy++) for (let xx=0; xx<w; xx++) used[(y+yy)*gw+(x+xx)]=1;
        rects.push({ id: crypto.randomUUID().slice(0,6), x: x*size, y: y*size, w: w*size, h: h*size });
      }
    }
    return rects;
  }

  u8ToBase64(u8: Uint8Array){
    // Convert to base64 without Buffer
    let s='';
    for (let i=0;i<u8.length;i++) s += String.fromCharCode(u8[i]);
    // @ts-ignore
    if (typeof btoa === 'function') return btoa(s);
    // Fallback simple base64
    // minimal polyfill
    // This is a light path; environment should have btoa.
    return (globalThis as any).Buffer ? (globalThis as any).Buffer.from(u8).toString('base64') : s;
  }

  randomFreePos(buffer = 24): Vec | null {
    return randomFreePosImpl(this, buffer);
  }


  // Lag compensation method
  processInputWithLagCompensation(player: Player, input: Input, timestamp: number) {
    return processInputWithLagCompensationImpl(this, player, input, timestamp);
  }


  circleIntersectsAnyWall(x:number,y:number,r:number){
    for (const w of this.walls){
      const nx = Math.max(w.x, Math.min(x, w.x+w.w));
      const ny = Math.max(w.y, Math.min(y, w.y+w.h));
      if (Math.hypot(x-nx,y-ny) < r) return true;
    }
    return false;
  }

  okDistanceFromPickups(x:number,y:number,minD:number){
    for (const p of this.pickups){ if (Math.hypot(x-p.x,y-p.y) < minD) return false; }
    return true;
  }

  pickZombieClass(): "runner" | "brute" | "spitter" | "stalker" | "bomber" {
    const w = this.cfg.zombies.weights;
    const bag: Array<"runner"|"brute"|"spitter"|"stalker"|"bomber"> = [];
    for (let i=0;i<w.runner;i++) bag.push('runner');
    for (let i=0;i<w.brute;i++) bag.push('brute');
    for (let i=0;i<w.spitter;i++) bag.push('spitter');
    for (let i=0;i<w.stalker;i++) bag.push('stalker');
    for (let i=0;i<w.bomber;i++) bag.push('bomber');
    return bag[Math.floor(Math.random()*bag.length)] || 'runner';
  }

  randRange(a:number,b:number){ return a + Math.floor(Math.random()*(b-a+1)); }

  // Extractions removed
  spawnExtractions() { /* no-op */ }

  // Get all rooms accessible from a starting tile position
  getAccessibleRooms(startX: number, startY: number): Array<{x: number; y: number; w: number; h: number}> {
    if (!this.map || !this.map.rooms) return [];
    
    // Use flood fill to find all reachable tiles
    const reachable = new Set<string>();
    const queue: Array<[number, number]> = [[startX, startY]];
    const visited = new Set<string>();
    
    const isWalkable = (x: number, y: number): boolean => {
      if (x < 0 || x >= this.map!.w || y < 0 || y >= this.map!.h) return false;
      const tile = this.map!.tiles[y * this.map!.w + x];
      return tile === 0; // Only floor tiles (no doors since we removed them)
    };
    
    while (queue.length > 0) {
      const [x, y] = queue.shift()!;
      const key = `${x},${y}`;
      
      if (visited.has(key)) continue;
      visited.add(key);
      
      if (!isWalkable(x, y)) continue;
      
      reachable.add(key);
      
      // Add adjacent tiles
      const neighbors = [[x+1,y], [x-1,y], [x,y+1], [x,y-1]];
      for (const [nx, ny] of neighbors) {
        const nKey = `${nx},${ny}`;
        if (!visited.has(nKey)) {
          queue.push([nx, ny]);
        }
      }
    }
    
    // Find which rooms contain reachable tiles
    const accessibleRooms: Array<{x: number; y: number; w: number; h: number}> = [];
    
    for (const room of this.map.rooms) {
      let hasReachableTile = false;
      
      for (let ty = room.y; ty < room.y + room.h && !hasReachableTile; ty++) {
        for (let tx = room.x; tx < room.x + room.w && !hasReachableTile; tx++) {
          if (reachable.has(`${tx},${ty}`)) {
            hasReachableTile = true;
          }
        }
      }
      
      if (hasReachableTile) {
        accessibleRooms.push(room);
      }
    }
    
    return accessibleRooms;
  }

  // Flood fill to find all tiles reachable from starting position
  getReachableTiles(startX: number, startY: number): Set<string> {
    if (!this.map) return new Set();
    
    const reachable = new Set<string>();
    const queue: Array<[number, number]> = [[startX, startY]];
    const visited = new Set<string>();
    
    const isWalkable = (x: number, y: number): boolean => {
      if (x < 0 || x >= this.map!.w || y < 0 || y >= this.map!.h) return false;
      const tile = this.map!.tiles[y * this.map!.w + x];
      return tile === 0 || tile === 5; // floor or doorOpen
    };
    
    while (queue.length > 0) {
      const [x, y] = queue.shift()!;
      const key = `${x},${y}`;
      
      if (visited.has(key)) continue;
      visited.add(key);
      
      if (!isWalkable(x, y)) continue;
      
      reachable.add(key);
      
      // Add adjacent tiles to queue
      const neighbors = [[x+1,y], [x-1,y], [x,y+1], [x,y-1]];
      for (const [nx, ny] of neighbors) {
        const nKey = `${nx},${ny}`;
        if (!visited.has(nKey)) {
          queue.push([nx, ny]);
        }
      }
    }
    
    return reachable;
  }

  rotateExtractionIfNeeded(nowMs: number) { /* no-op */ }

  // Boss System Methods
  updateBossSystem(now: number) {
    return updateBossSystemImpl(this, now);
  }


  spawnRandomBoss() {
    return spawnRandomBossImpl(this);
  }


  updateBoss(boss: Boss, now: number) {
    return updateBossImpl(this, boss, now);
  }


  processBossAbilities(boss: Boss, now: number, streamer: Player) {
    return processBossAbilitiesImpl(this, boss, now, streamer);
  }


  // Boss ability implementations
  necromancerSummon(boss: Boss, now: number) {
    return necromancerSummonImpl(this, boss, now);
  }


  necromancerTeleport(boss: Boss, streamer: Player) {
    return necromancerTeleportImpl(this, boss, streamer);
  }


  necromancerPoisonField(boss: Boss, streamer: Player, now: number) {
    return necromancerPoisonFieldImpl(this, boss, streamer, now);
  }


  bruteKingCharge(boss: Boss, streamer: Player, now: number) {
    return bruteKingChargeImpl(this, boss, streamer, now);
  }


  bruteKingGroundSlam(boss: Boss, streamer: Player, now: number) {
    return bruteKingGroundSlamImpl(this, boss, streamer, now);
  }


  shadowLordPhase(boss: Boss, now: number) {
    return shadowLordPhaseImpl(this, boss, now);
  }


  shadowLordClones(boss: Boss, now: number) {
    return shadowLordClonesImpl(this, boss, now);
  }


  shadowLordLifeDrain(boss: Boss, streamer: Player, now: number) {
    return shadowLordLifeDrainImpl(this, boss, streamer, now);
  }


  updateBossMinions(now: number) {
    return updateBossMinionsImpl(this, now);
  }


  updatePoisonFields(now: number) {
    return updatePoisonFieldsImpl(this, now);
  }


  onBossDeath(boss: Boss) {
    return onBossDeathImpl(this, boss);
  }


  generateBossLoot(boss: Boss) {
    return generateBossLootImpl(this, boss);
  }


  publicBoss(boss: any) {
    return publicBossImpl(this, boss);
  }


  // Initialize raid stats for a player
  initRaidStats(player: any): void {
    return initRaidStatsImpl(this, player);
  }


  // Track enemy kill
  trackEnemyKill(player: any, enemyType: string): void {
    return trackEnemyKillImpl(this, player, enemyType);
  }


  // Track boss kill
  trackBossKill(player: any, bossType?: string): void {
    return trackBossKillImpl(this, player, bossType);
  }


  // Track bullet fired
  trackBulletFired(player: any): void {
    return trackBulletFiredImpl(this, player);
  }


  // Track bullet hit
  trackBulletHit(player: any): void {
    return trackBulletHitImpl(this, player);
  }


  // Track damage dealt
  trackDamageDealt(player: any, damage: number): void {
    return trackDamageDealtImpl(this, player, damage);
  }


  // Track damage taken
  trackDamageTaken(player: any, damage: number): void {
    return trackDamageTakenImpl(this, player, damage);
  }


  // Track pickup taken
  trackPickupTaken(player: any, pickupType: string): void {
    return trackPickupTakenImpl(this, player, pickupType);
  }


  // Track XP gained
  trackXPGained(player: any, xp: number): void {
    return trackXPGainedImpl(this, player, xp);
  }

}
</file>

<file path="src/room/room-types.ts">
import type { ModId, ActiveBullet } from '../types';

export type Vec = { x: number; y: number };

export type Bullet = ActiveBullet;

export interface Input {
  up: boolean;
  down: boolean;
  left: boolean;
  right: boolean;
  shoot: boolean;
  aimX: number;
  aimY: number;
  melee?: boolean;
  dash?: boolean;
}

export type PlayerRole = 'streamer' | 'zombie';

export interface Player {
  id: string;
  role: PlayerRole;
  name: string;
  pos: Vec;
  vel: Vec;
  input: Input;
  ws?: WebSocket;
  score: number;
  banked?: number;
  alive: boolean;
  lastSeen: number;
  lastShotAt?: number;
  lastMeleeAt?: number;
  lastDashAt?: number;
  level?: number;
  xp?: number;
  mods?: Partial<Record<ModId, number>>;
  hp?: number;
  maxHp?: number;
  boostUntil?: number;
  ammo?: number;
  maxAmmo?: number;
  weaponBoostUntil?: number;
  emote?: string;
  emoteUntil?: number;
  weapon?: 'pistol' | 'smg' | 'shotgun' | 'bat';
  pistolAmmo?: number;
  smgAmmo?: number;
  shotgunAmmo?: number;
  meleeDirX?: number;
  meleeDirY?: number;
  dashUntil?: number;
  lagMs?: number;
  inputBuffer?: Array<{ input: Input; timestamp: number }>;
  lastInputTime?: number;
  zClass?: 'runner' | 'brute' | 'spitter' | 'stalker' | 'bomber';
  zHp?: number;
  zMaxHp?: number;
  nextSpitAt?: number;
  lastAbilityAt?: number;
  chargeUntil?: number;
  chargeDirX?: number;
  chargeDirY?: number;
  slowUntil?: number;
  slowMul?: number;
  burns?: Array<{ until: number; dps: number; nextTick: number; ownerId: string }>;
  bleeds?: Array<{ until: number; dps: number; nextTick: number; ownerId: string }>;
  cloaked?: boolean;
  cloakUntil?: number;
  uncloakUntil?: number;
  fuseStarted?: number;
  fuseUntil?: number;
  lastShieldRegen?: number;
  hpShield?: number;
  raidStats?: any;
  [key: string]: any;
}

export interface Rect {
  id: string;
  x: number;
  y: number;
  w: number;
  h: number;
}

export interface Extraction {
  id: string;
  x: number;
  y: number;
  r: number;
  activeUntil?: number;
}

export type PickupType =
  | 'health'
  | 'speed'
  | 'ammo'
  | 'weapon'
  | 'shield'
  | 'magnet'
  | 'freeze'
  | 'blast'
  | 'treasure'
  | 'key'
  | 'coin'
  | 'gem'
  | 'relic'
  | 'artifact'
  | 'crystal'
  | 'orb'
  | 'medallion'
  | 'scroll'
  | 'crown';

export interface Pickup {
  id: string;
  type: PickupType;
  x: number;
  y: number;
}

export interface AIZombie {
  id: string;
  pos: Vec;
  vel: Vec;
  hp: number;
  maxHp: number;
  zClass: 'runner' | 'brute' | 'spitter' | 'stalker' | 'bomber';
  state: 'idle' | 'chasing' | 'attacking';
  targetId?: string;
  lastSeen: number;
  lastAttack: number;
  detectionRange: number;
  chaseRange: number;
  roomId?: string;
  pathfindingCooldown: number;
  nextPathUpdate: number;
  slowUntil?: number;
  slowMul?: number;
  burns?: Array<{ until: number; dps: number; nextTick: number; ownerId: string }>;
  bleeds?: Array<{ until: number; dps: number; nextTick: number; ownerId: string }>;
  cloaked?: boolean;
  cloakUntil?: number;
  uncloakUntil?: number;
  fuseStarted?: number;
  fuseUntil?: number;
}
</file>

<file path="src/room/systems/ai-zombies.ts">
import type { RoomDO } from '../index';
import type { Player, AIZombie, Vec } from '../room-types';


export function spawnAIZombiesIfNeeded(ctx: RoomDO, now: number) {
  if (now - ctx.lastAIZombieSpawn < ctx.aiZombieSpawnCooldown) return;
  if (ctx.aiZombies.length >= ctx.maxAIZombies) return;
  
  // Only spawn if there's a streamer
  const streamer = [...ctx.players.values()].find(p => p.role === "streamer");
  if (!streamer) return;
  
  const spawnPos = ctx.getAIZombieSpawnPosition(streamer.pos);
  if (!spawnPos) return;
  
  const zClass = ctx.pickZombieClass();
  const baseHp = ctx.cfg.zombies.baseHp;
  const maxHp = Math.max(1, Math.round(baseHp * ctx.cfg.zombies.hpMul[zClass]));
  
  const aiZombie: AIZombie = {
    id: crypto.randomUUID().slice(0, 8),
    pos: spawnPos,
    vel: { x: 0, y: 0 },
    hp: maxHp,
    maxHp: maxHp,
    zClass: zClass,
    state: "idle",
    lastSeen: 0,
    lastAttack: 0,
    detectionRange: ctx.cfg.zombies.detectionRange[zClass],
    chaseRange: ctx.cfg.zombies.chaseRange[zClass],
    pathfindingCooldown: 500, // ms between pathfinding updates
    nextPathUpdate: now
  };
  
  ctx.aiZombies.push(aiZombie);
  ctx.lastAIZombieSpawn = now;

}

export function updateAIZombies(ctx: RoomDO, now: number) {
  const streamer = [...ctx.players.values()].find(p => p.role === "streamer");
  const dt = ctx.tickMs / 1000;
  
  for (let i = ctx.aiZombies.length - 1; i >= 0; i--) {
    const zombie = ctx.aiZombies[i];
    
    // Remove dead zombies
    if (zombie.hp <= 0) {
      // Drop random pickup (ammo or treasure) - only if drop chance succeeds
      const dropType = ctx.getRandomZombieDrop();
      if (dropType) {
        ctx.pickups.push({ 
          id: crypto.randomUUID().slice(0, 6), 
          type: dropType, 
          x: zombie.pos.x, 
          y: zombie.pos.y 
        });
      }
      ctx.aiZombies.splice(i, 1);
      continue;
    }
    
    if (!streamer) {
      zombie.state = "idle";
      continue;
    }
    
    const distToStreamer = Math.hypot(zombie.pos.x - streamer.pos.x, zombie.pos.y - streamer.pos.y);
    const hasLineOfSight = ctx.hasLineOfSight(zombie.pos, streamer.pos);
    
    // State machine
    switch (zombie.state) {
      case "idle":
        if (distToStreamer <= zombie.detectionRange && hasLineOfSight) {
          zombie.state = "chasing";
          zombie.targetId = streamer.id;
          zombie.lastSeen = now;
        }
        break;
        
      case "chasing":
        if (distToStreamer > zombie.chaseRange) {
          zombie.state = "idle";
          zombie.targetId = undefined;
        } else if (distToStreamer <= 20) {
          zombie.state = "attacking";
          zombie.lastAttack = now;
        } else if (hasLineOfSight) {
          zombie.lastSeen = now;
        }
        break;
        
      case "attacking":
        if (distToStreamer > 30) {
          zombie.state = "chasing";
        } else if (now - zombie.lastAttack > 1000) { // Attack every second
          ctx.aiZombieAttackStreamer(zombie, streamer, now);
          zombie.lastAttack = now;
        }
        break;
    }
    
    // Movement AI
    ctx.updateAIZombieMovement(zombie, streamer, now, dt);
    
    // Apply movement with collision
    ctx.moveAIZombie(zombie, dt);
  }

}

export function getAIZombieSpawnPosition(ctx: RoomDO, streamerPos: Vec) {
  if (!ctx.map || !ctx.map.rooms) return null;
  
  // Try to spawn in a room that's not too close to the streamer
  const attempts = 20;
  for (let i = 0; i < attempts; i++) {
    const room = ctx.map.rooms[Math.floor(Math.random() * ctx.map.rooms.length)];
    
    // Find floor tiles in this room
    const candidates: Vec[] = [];
    for (let ty = room.y + 1; ty < room.y + room.h - 1; ty++) {
      for (let tx = room.x + 1; tx < room.x + room.w - 1; tx++) {
        if (tx >= 0 && tx < ctx.map.w && ty >= 0 && ty < ctx.map.h) {
          const tile = ctx.map.tiles[ty * ctx.map.w + tx];
          if (tile === 0) { // floor tile
            const worldX = tx * ctx.map.size + ctx.map.size / 2;
            const worldY = ty * ctx.map.size + ctx.map.size / 2;
            
            // Check distance from streamer (not too close, not too far)
            const dist = Math.hypot(worldX - streamerPos.x, worldY - streamerPos.y);
            if (dist > 150 && dist < 400) {
              candidates.push({ x: worldX, y: worldY });
            }
          }
        }
      }
    }
    
    if (candidates.length > 0) {
      return candidates[Math.floor(Math.random() * candidates.length)];
    }
  }
  
  return null;

}

export function updateAIZombieMovement(ctx: RoomDO, zombie: AIZombie, streamer: Player, now: number, dt: number) {
  if (zombie.state === "idle") {
    zombie.vel.x = 0;
    zombie.vel.y = 0;
    return;
  }
  
  // Simple AI movement toward streamer
  const dx = streamer.pos.x - zombie.pos.x;
  const dy = streamer.pos.y - zombie.pos.y;
  const distance = Math.hypot(dx, dy);
  
  if (distance > 0) {
    const baseSpeed = ctx.cfg.speeds.zombie * ctx.cfg.zombies.speedMul[zombie.zClass];
    let speed = (ctx.zombieSlowUntil || 0) > now ? baseSpeed * ctx.cfg.speeds.zombieSlowMultiplier : baseSpeed;
    if ((zombie.slowUntil || 0) > now) speed *= Math.max(0.05, zombie.slowMul || 1);
    
    zombie.vel.x = (dx / distance) * speed;
    zombie.vel.y = (dy / distance) * speed;
  }

}

export function moveAIZombie(ctx: RoomDO, zombie: AIZombie, dt: number) {
  // Intended new position
  let nx = zombie.pos.x + zombie.vel.x * dt;
  let ny = zombie.pos.y + zombie.vel.y * dt;
  
  // Tile collision
  if (ctx.map) {
    const sz = ctx.map.size;
    const ix = Math.max(0, Math.min(ctx.map.w-1, Math.floor(nx / sz)));
    const iy = Math.max(0, Math.min(ctx.map.h-1, Math.floor(ny / sz)));
    const t = ctx.map.tiles[iy*ctx.map.w + ix] as TileId;
    
    const isSolid = (tt:TileId)=> tt===1 || tt===4; // wall or doorClosed
    const isLethal = (tt:TileId)=> tt===2; // pit
    const isSlow = (tt:TileId)=> tt===3; // water/sludge
    
    if (isSlow(t)) { 
      nx = zombie.pos.x + (zombie.vel.x * 0.6) * dt; 
      ny = zombie.pos.y + (zombie.vel.y * 0.6) * dt;
    }
    if (isSolid(t)) { 
      nx = zombie.pos.x; 
      ny = zombie.pos.y; 
    }
    if (isLethal(t)) {
      // Respawn zombie in a different location
      const newPos = ctx.getAIZombieSpawnPosition({ x: ctx.W/2, y: ctx.H/2 });
      if (newPos) {
        zombie.pos = newPos;
        return;
      }
    }
  }
  
  zombie.pos.x = Math.max(0, Math.min(ctx.W, nx));
  zombie.pos.y = Math.max(0, Math.min(ctx.H, ny));
  
  // Wall collision
  const pr = ctx.cfg.radii.zombie;
  for (const rct of ctx.walls) {
    const nearestX = Math.max(rct.x, Math.min(zombie.pos.x, rct.x + rct.w));
    const nearestY = Math.max(rct.y, Math.min(zombie.pos.y, rct.y + rct.h));
    let dx = zombie.pos.x - nearestX; 
    let dy = zombie.pos.y - nearestY; 
    let dist = Math.hypot(dx, dy);
    
    if (dist < pr) {
      if (dist === 0) {
        // Push out along smallest penetration axis
        const left = Math.abs(zombie.pos.x - rct.x);
        const right = Math.abs(rct.x + rct.w - zombie.pos.x);
        const top = Math.abs(zombie.pos.y - rct.y);
        const bottom = Math.abs(rct.y + rct.h - zombie.pos.y);
        const m = Math.min(left, right, top, bottom);
        if (m === left) zombie.pos.x = rct.x - pr;
        else if (m === right) zombie.pos.x = rct.x + rct.w + pr;
        else if (m === top) zombie.pos.y = rct.y - pr;
        else zombie.pos.y = rct.y + rct.h + pr;
      } else {
        const nx = dx / dist, ny = dy / dist;
        const push = (pr - dist) + 0.5;
        zombie.pos.x += nx * push; 
        zombie.pos.y += ny * push;
      }
    }
  }

}

export function aiZombieAttackStreamer(ctx: RoomDO, zombie: AIZombie, streamer: Player, now: number) {
  const shielded = ((streamer as any).shieldUntil || 0) > now;
  if (shielded) return;
  
  if ((streamer.hp ?? ctx.cfg.streamer.maxHp) > 0) {
    streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - ctx.cfg.combat.zombieTouchDamage);
    ctx.trackDamageTaken(streamer, ctx.cfg.combat.zombieTouchDamage);
    // Add damage number for zombie hit on streamer
    ctx.addDamageNumber(streamer.pos.x, streamer.pos.y, ctx.cfg.combat.zombieTouchDamage, false, false);
  }
  
  if ((streamer.hp ?? 0) <= 0) {
    // Respawn streamer; lose unbanked on death (keep banked)
    streamer.pos = ctx.spawnInRandomRoom();
    streamer.hp = streamer.maxHp ?? ctx.cfg.streamer.maxHp;
    streamer.score = 0;
  }
  
  // Knockback streamer slightly
  const dx = streamer.pos.x - zombie.pos.x; 
  const dy = streamer.pos.y - zombie.pos.y; 
  const d = Math.hypot(dx, dy) || 1;
  const kbMul = (zombie.zClass === 'brute') ? ctx.cfg.zombies.brute.extraKnockbackMul : 1;
  streamer.pos.x = Math.max(0, Math.min(ctx.W, streamer.pos.x + (dx / d) * ctx.cfg.combat.knockbackStep * kbMul));
  streamer.pos.y = Math.max(0, Math.min(ctx.H, streamer.pos.y + (dy / d) * ctx.cfg.combat.knockbackStep * kbMul));

}

export function hasLineOfSight(ctx: RoomDO, from: Vec, to: Vec) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const distance = Math.hypot(dx, dy);
  
  if (distance === 0) return true;
  
  const steps = Math.ceil(distance / 16); // Check every 16 pixels
  const stepX = dx / steps;
  const stepY = dy / steps;
  
  for (let i = 1; i < steps; i++) {
    const checkX = from.x + stepX * i;
    const checkY = from.y + stepY * i;
    
    // Check if this point intersects with walls
    for (const wall of ctx.walls) {
      if (checkX >= wall.x && checkX <= wall.x + wall.w &&
          checkY >= wall.y && checkY <= wall.y + wall.h) {
        return false;
      }
    }
  }
  
  return true;

}
</file>

<file path="src/room/systems/bosses.ts">
import type { RoomDO } from '../index';
import type { Boss, BossMinion, PoisonField, BossType } from '../../types';
import type { Player, Vec } from '../room-types';


export function updateBossSystem(ctx: RoomDO, now: number) {
  // Check for boss spawn announcement
  if (!ctx.nextBossAnnouncement && now - ctx.lastBossSpawn > ctx.bossSpawnCooldown - ctx.cfg.bosses.announceMs) {
    if (ctx.bosses.length < ctx.cfg.bosses.maxActive) {
      ctx.nextBossAnnouncement = now + ctx.cfg.bosses.announceMs;
      ctx.broadcast("notice", { message: "Warning A powerful boss is approaching! Prepare for battle!" });
    }
  }

  // Spawn boss if it's time
  if (ctx.nextBossAnnouncement && now >= ctx.nextBossAnnouncement) {
    ctx.spawnRandomBoss();
    ctx.nextBossAnnouncement = undefined;
    ctx.lastBossSpawn = now;
  }

  // Update existing bosses
  for (let i = ctx.bosses.length - 1; i >= 0; i--) {
    const boss = ctx.bosses[i];
    ctx.updateBoss(boss, now);
    
    // Remove dead bosses
    if (boss.hp <= 0 && boss.state === "dying") {
      ctx.onBossDeath(boss);
      ctx.bosses.splice(i, 1);
    }
  }

}

export function spawnRandomBoss(ctx: RoomDO) {
  const bossTypes: BossType[] = ["necromancer", "bruteKing", "shadowLord"];
  const randomType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
  const spawnPos = ctx.spawnInRandomRoom();
  
  const bossConfig = ctx.cfg.bosses.types[randomType];
  const boss: Boss = {
    id: crypto.randomUUID().slice(0, 8),
    type: randomType,
    pos: spawnPos,
    vel: { x: 0, y: 0 },
    hp: bossConfig.hp,
    maxHp: bossConfig.hp,
    radius: bossConfig.radius,
    damage: bossConfig.damage,
    speed: bossConfig.speed,
    state: "spawning",
    lastSeen: Date.now(),
    spawnTime: Date.now(),
    minionIds: [],
    cloneIds: []
  };

  ctx.bosses.push(boss);
  ctx.broadcast("boss_spawn", { boss: ctx.publicBoss(boss) });
  ctx.broadcast("notice", { message: `Skull ${randomType.toUpperCase()} has entered the arena!` });

}

export function updateBoss(ctx: RoomDO, boss: Boss, now: number) {
  const streamer = [...ctx.players.values()].find(p => p.role === "streamer" && p.alive);
  if (!streamer) {
    boss.state = "idle";
    return;
  }

  const dist = Math.hypot(boss.pos.x - streamer.pos.x, boss.pos.y - streamer.pos.y);
  
  // Check if phase ability has expired
  if (boss.phased && boss.phaseUntil && now > boss.phaseUntil) {
    boss.phased = false;
    boss.phaseUntil = undefined;
    ctx.broadcast("notice", { message: "Ghost Shadow Lord returns to reality!" });
  }
  
  // Handle boss states
  switch (boss.state) {
    case "spawning":
      if (now - boss.spawnTime > 2000) {
        boss.state = "idle";
      }
      break;
      
    case "idle":
      if (dist < 400) {
        boss.state = "chasing";
        boss.targetId = streamer.id;
      }
      break;
      
    case "chasing":
      if (dist > 600) {
        boss.state = "idle";
        boss.targetId = undefined;
      } else if (dist < boss.radius + 30) {
        boss.state = "attacking";
      }
      break;
      
    case "attacking":
      if (dist > boss.radius + 50) {
        boss.state = "chasing";
      }
      break;
  }

  // Movement AI - improved movement logic
  if ((boss.state === "chasing" || boss.state === "attacking") && streamer) {
    const dx = streamer.pos.x - boss.pos.x;
    const dy = streamer.pos.y - boss.pos.y;
    const len = Math.hypot(dx, dy) || 1;
    
    let speed = boss.speed;
    if (boss.enraged && boss.type === "bruteKing") {
      const config = ctx.cfg.bosses.types.bruteKing;
      speed *= config.abilities.enrage.speedMul;
    }
    
    // Only move if not too close (prevents jittering)
    if (len > boss.radius + ctx.cfg.radii.streamer + 5) {
      boss.vel.x = (dx / len) * speed;
      boss.vel.y = (dy / len) * speed;
    } else {
      // Slow down when very close
      boss.vel.x = (dx / len) * speed * 0.3;
      boss.vel.y = (dy / len) * speed * 0.3;
    }
  } else if (boss.state === "idle") {
    // Idle wandering movement
    if (!boss.wanderTarget || Math.hypot(boss.pos.x - boss.wanderTarget.x, boss.pos.y - boss.wanderTarget.y) < 20) {
      // Set new wander target
      boss.wanderTarget = {
        x: boss.pos.x + (Math.random() - 0.5) * 200,
        y: boss.pos.y + (Math.random() - 0.5) * 200
      };
      // Keep target in bounds
      boss.wanderTarget.x = Math.max(boss.radius, Math.min(ctx.W - boss.radius, boss.wanderTarget.x));
      boss.wanderTarget.y = Math.max(boss.radius, Math.min(ctx.H - boss.radius, boss.wanderTarget.y));
    }
    
    const dx = boss.wanderTarget.x - boss.pos.x;
    const dy = boss.wanderTarget.y - boss.pos.y;
    const len = Math.hypot(dx, dy) || 1;
    
    boss.vel.x = (dx / len) * boss.speed * 0.5; // Slower idle movement
    boss.vel.y = (dy / len) * boss.speed * 0.5;
  } else {
    boss.vel.x = 0;
    boss.vel.y = 0;
  }

  // Update position
  const dt = ctx.tickMs / 1000;
  boss.pos.x += boss.vel.x * dt;
  boss.pos.y += boss.vel.y * dt;

  // Keep boss in bounds
  boss.pos.x = Math.max(boss.radius, Math.min(ctx.W - boss.radius, boss.pos.x));
  boss.pos.y = Math.max(boss.radius, Math.min(ctx.H - boss.radius, boss.pos.y));

  // Handle abilities
  ctx.processBossAbilities(boss, now, streamer);

  // Handle contact damage with cooldown and range check
  if (boss.state === "attacking" && streamer && dist < boss.radius + ctx.cfg.radii.streamer + 10) {
    // Add damage cooldown to prevent hitting every tick and ensure close range
    // Also prevent damage while boss is phased
    if ((!boss.lastDamage || now - boss.lastDamage > 1000) && dist < 100 && !boss.phased) { // 1 second cooldown + max 100px range + not phased
      let damage = boss.damage;
      if (boss.enraged && boss.type === "bruteKing") {
        damage *= ctx.cfg.bosses.types.bruteKing.abilities.enrage.damageMul;
      }
      
      streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - damage);
      ctx.trackDamageTaken(streamer, damage);
      ctx.addDamageNumber(streamer.pos.x, streamer.pos.y, damage, false, false);
      boss.lastDamage = now;
      
      // Knockback
      const kx = (streamer.pos.x - boss.pos.x) / (dist || 1);
      const ky = (streamer.pos.y - boss.pos.y) / (dist || 1);
      streamer.pos.x += kx * ctx.cfg.combat.knockbackStep * 2;
      streamer.pos.y += ky * ctx.cfg.combat.knockbackStep * 2;
    }
  }

  // Check for enrage condition (Brute King only)
  if (boss.type === "bruteKing" && !boss.enraged) {
    const hpPct = boss.hp / boss.maxHp;
    if (hpPct <= ctx.cfg.bosses.types.bruteKing.abilities.enrage.hpThreshold) {
      boss.enraged = true;
      ctx.broadcast("notice", { message: "Fire BRUTE KING ENRAGES! Speed and damage increased!" });
    }
  }

}

export function processBossAbilities(ctx: RoomDO, boss: Boss, now: number, streamer: Player) {
  const bossConfig = ctx.cfg.bosses.types[boss.type];
  
  // Process abilities based on boss type
  switch (boss.type) {
    case 'necromancer':
      const necroConfig = bossConfig as typeof ctx.cfg.bosses.types.necromancer;
      
      // Summon minions
      if (!boss.lastSummon || now - boss.lastSummon > necroConfig.abilities.summon.cooldownMs) {
        if (Math.random() < 0.3) {
          ctx.necromancerSummon(boss, now);
          boss.lastSummon = now;
        }
      }
      
      // Teleport
      if (!boss.lastTeleport || now - boss.lastTeleport > necroConfig.abilities.teleport.cooldownMs) {
        if (Math.random() < 0.2) {
          ctx.necromancerTeleport(boss, streamer);
          boss.lastTeleport = now;
        }
      }
      
      // Poison field
      if (!boss.lastPoisonField || now - boss.lastPoisonField > necroConfig.abilities.poisonField.cooldownMs) {
        if (Math.random() < 0.25) {
          ctx.necromancerPoisonField(boss, streamer, now);
          boss.lastPoisonField = now;
        }
      }
      break;
      
    case 'bruteKing':
      const bruteConfig = bossConfig as typeof ctx.cfg.bosses.types.bruteKing;
      
      // Check for enrage
      if (!boss.enraged && boss.hp <= boss.maxHp * bruteConfig.abilities.enrage.hpThreshold) {
        boss.enraged = true;
        boss.speed *= bruteConfig.abilities.enrage.speedMul;
        boss.damage *= bruteConfig.abilities.enrage.damageMul;
        ctx.broadcast("notice", { message: `Skull The ${boss.type} becomes enraged!` });
      }
      
      // Charge attack
      if (!boss.lastCharge || now - boss.lastCharge > bruteConfig.abilities.charge.cooldownMs) {
        if (Math.random() < 0.4) {
          ctx.bruteKingCharge(boss, streamer, now);
          boss.lastCharge = now;
        }
      }
      
      // Ground slam
      if (!boss.lastGroundSlam || now - boss.lastGroundSlam > bruteConfig.abilities.groundSlam.cooldownMs) {
        if (Math.random() < 0.3) {
          ctx.bruteKingGroundSlam(boss, streamer, now);
          boss.lastGroundSlam = now;
        }
      }
      break;
      
    case 'shadowLord':
      const shadowConfig = bossConfig as typeof ctx.cfg.bosses.types.shadowLord;
      
      // Phase ability
      if (!boss.lastPhase || now - boss.lastPhase > shadowConfig.abilities.phase.cooldownMs) {
        if (Math.random() < 0.2) {
          ctx.shadowLordPhase(boss, now);
          boss.lastPhase = now;
        }
      }
      
      // Shadow clones
      if (!boss.lastShadowClone || now - boss.lastShadowClone > shadowConfig.abilities.shadowClone.cooldownMs) {
        if (Math.random() < 0.25) {
          ctx.shadowLordClones(boss, now);
          boss.lastShadowClone = now;
        }
      }
      
      // Life drain
      if (!boss.lastLifeDrain || now - boss.lastLifeDrain > shadowConfig.abilities.lifeDrain.cooldownMs) {
        if (Math.random() < 0.3) {
          ctx.shadowLordLifeDrain(boss, streamer, now);
          boss.lastLifeDrain = now;
        }
      }
      break;
  }

}

export function necromancerSummon(ctx: RoomDO, boss: Boss, now: number) {
  const config = ctx.cfg.bosses.types.necromancer.abilities.summon;
  for (let i = 0; i < config.minionCount; i++) {
    const angle = (Math.PI * 2 * i) / config.minionCount;
    const spawnX = boss.pos.x + Math.cos(angle) * 60;
    const spawnY = boss.pos.y + Math.sin(angle) * 60;
    
    const minion: BossMinion = {
      id: crypto.randomUUID().slice(0, 8),
      bossId: boss.id,
      pos: { x: spawnX, y: spawnY },
      vel: { x: 0, y: 0 },
      hp: config.minionHp,
      maxHp: config.minionHp,
      state: "idle",
      lastSeen: now,
      spawnTime: now
    };
    
    ctx.bossMinions.push(minion);
    boss.minionIds = boss.minionIds || [];
    boss.minionIds.push(minion.id);
  }
  
  ctx.broadcast("notice", { message: "Skull Necromancer summons undead minions!" });

}

export function necromancerTeleport(ctx: RoomDO, boss: Boss, streamer: Player) {
  const config = ctx.cfg.bosses.types.necromancer.abilities.teleport;
  const angle = Math.random() * Math.PI * 2;
  const distance = 100 + Math.random() * (config.range - 100);
  
  const newX = streamer.pos.x + Math.cos(angle) * distance;
  const newY = streamer.pos.y + Math.sin(angle) * distance;
  
  boss.pos.x = Math.max(boss.radius, Math.min(ctx.W - boss.radius, newX));
  boss.pos.y = Math.max(boss.radius, Math.min(ctx.H - boss.radius, newY));
  
  ctx.broadcast("boss_teleport", { bossId: boss.id, pos: boss.pos });

}

export function necromancerPoisonField(ctx: RoomDO, boss: Boss, streamer: Player, now: number) {
  const config = ctx.cfg.bosses.types.necromancer.abilities.poisonField;
  
  const poisonField: PoisonField = {
    id: crypto.randomUUID().slice(0, 8),
    pos: { x: streamer.pos.x, y: streamer.pos.y },
    radius: config.radius,
    dps: config.dps,
    createdAt: now,
    expiresAt: now + config.durationMs,
    ownerId: boss.id
  };
  
  ctx.poisonFields.push(poisonField);
  ctx.broadcast("poison_field", { field: poisonField });

}

export function bruteKingCharge(ctx: RoomDO, boss: Boss, streamer: Player, now: number) {
  const config = ctx.cfg.bosses.types.bruteKing.abilities.charge;
  const dx = streamer.pos.x - boss.pos.x;
  const dy = streamer.pos.y - boss.pos.y;
  const len = Math.hypot(dx, dy) || 1;
  
  boss.chargeDirX = dx / len;
  boss.chargeDirY = dy / len;
  boss.chargeUntil = now + config.durationMs;
  boss.state = "ability";
  
  ctx.broadcast("notice", { message: "Shock Brute King charges forward!" });

}

export function bruteKingGroundSlam(ctx: RoomDO, boss: Boss, streamer: Player, now: number) {
  const config = ctx.cfg.bosses.types.bruteKing.abilities.groundSlam;
  const dist = Math.hypot(boss.pos.x - streamer.pos.x, boss.pos.y - streamer.pos.y);
  
  if (dist <= config.radius) {
    const damage = config.damage;
    streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - damage);
    ctx.trackDamageTaken(streamer, damage);
    ctx.addDamageNumber(streamer.pos.x, streamer.pos.y, damage, false, false);
    
    // Stun effect
    (streamer as any).stunUntil = now + config.stunMs;
  }
  
  ctx.broadcast("ground_slam", { pos: boss.pos, radius: config.radius });
  ctx.broadcast("notice", { message: "Impact Ground slam creates shockwaves!" });

}

export function shadowLordPhase(ctx: RoomDO, boss: Boss, now: number) {
  const config = ctx.cfg.bosses.types.shadowLord.abilities.phase;
  boss.phased = true;
  boss.phaseUntil = now + config.durationMs;
  
  ctx.broadcast("notice", { message: "Ghost Shadow Lord phases out of reality!" });

}

export function shadowLordClones(ctx: RoomDO, boss: Boss, now: number) {
  const config = ctx.cfg.bosses.types.shadowLord.abilities.shadowClone;
  
  for (let i = 0; i < config.cloneCount; i++) {
    const angle = (Math.PI * 2 * i) / config.cloneCount;
    const spawnX = boss.pos.x + Math.cos(angle) * 80;
    const spawnY = boss.pos.y + Math.sin(angle) * 80;
    
    const clone: BossMinion = {
      id: crypto.randomUUID().slice(0, 8),
      bossId: boss.id,
      pos: { x: spawnX, y: spawnY },
      vel: { x: 0, y: 0 },
      hp: config.cloneHp,
      maxHp: config.cloneHp,
      state: "idle",
      lastSeen: now,
      spawnTime: now,
      expiresAt: now + config.durationMs
    };
    
    ctx.bossMinions.push(clone);
    boss.cloneIds = boss.cloneIds || [];
    boss.cloneIds.push(clone.id);
  }
  
  ctx.broadcast("notice", { message: "Moon Shadow clones emerge from the darkness!" });

}

export function shadowLordLifeDrain(ctx: RoomDO, boss: Boss, streamer: Player, now: number) {
  const config = ctx.cfg.bosses.types.shadowLord.abilities.lifeDrain;
  const damage = config.dps;
  const heal = Math.round(damage * config.healMul);
  
  streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - damage);
  ctx.trackDamageTaken(streamer, damage);
  boss.hp = Math.min(boss.maxHp, boss.hp + heal);
  
  ctx.addDamageNumber(streamer.pos.x, streamer.pos.y, damage, false, true);
  ctx.addDamageNumber(boss.pos.x, boss.pos.y, -heal, false, false); // Negative for healing
  
  ctx.broadcast("life_drain", { from: boss.pos, to: streamer.pos });

}

export function updateBossMinions(ctx: RoomDO, now: number) {
  for (let i = ctx.bossMinions.length - 1; i >= 0; i--) {
    const minion = ctx.bossMinions[i];
    
    // Remove expired minions
    if (minion.expiresAt && now > minion.expiresAt) {
      ctx.bossMinions.splice(i, 1);
      continue;
    }
    
    // Remove minions whose boss is dead
    const boss = ctx.bosses.find(b => b.id === minion.bossId);
    if (!boss) {
      ctx.bossMinions.splice(i, 1);
      continue;
    }
    
    // Simple AI for minions
    const streamer = [...ctx.players.values()].find(p => p.role === "streamer" && p.alive);
    if (streamer) {
      const dist = Math.hypot(minion.pos.x - streamer.pos.x, minion.pos.y - streamer.pos.y);
      
      if (dist < 200) {
        minion.state = "chasing";
        minion.targetId = streamer.id;
        
        const dx = streamer.pos.x - minion.pos.x;
        const dy = streamer.pos.y - minion.pos.y;
        const len = Math.hypot(dx, dy) || 1;
        
        const speed = 80;
        minion.vel.x = (dx / len) * speed;
        minion.vel.y = (dy / len) * speed;
        
        // Update position
        const dt = ctx.tickMs / 1000;
        minion.pos.x += minion.vel.x * dt;
        minion.pos.y += minion.vel.y * dt;
        
        // Contact damage
        if (dist < 20) {
          const damage = 15;
          streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - damage);
          ctx.trackDamageTaken(streamer, damage);
          ctx.addDamageNumber(streamer.pos.x, streamer.pos.y, damage, false, false);
        }
      }
    }
  }

}

export function updatePoisonFields(ctx: RoomDO, now: number) {
  for (let i = ctx.poisonFields.length - 1; i >= 0; i--) {
    const field = ctx.poisonFields[i];
    
    if (now > field.expiresAt) {
      ctx.poisonFields.splice(i, 1);
      continue;
    }
    
    // Damage streamer if in poison field
    const streamer = [...ctx.players.values()].find(p => p.role === "streamer" && p.alive);
    if (streamer) {
      const dist = Math.hypot(streamer.pos.x - field.pos.x, streamer.pos.y - field.pos.y);
      if (dist <= field.radius) {
        const damage = Math.round(field.dps * (ctx.tickMs / 1000));
        streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - damage);
        ctx.trackDamageTaken(streamer, damage);
        ctx.addDamageNumber(streamer.pos.x, streamer.pos.y, damage, false, true);
      }
    }
  }

}

export function onBossDeath(ctx: RoomDO, boss: Boss) {
  // Generate loot drops
  ctx.generateBossLoot(boss);
  
  // Clean up minions and clones
  ctx.bossMinions = ctx.bossMinions.filter(m => m.bossId !== boss.id);
  
  // Broadcast death
  ctx.broadcast("boss_death", { bossId: boss.id, pos: boss.pos });
  ctx.broadcast("notice", { message: `Skull ${boss.type.toUpperCase()} has been defeated! Loot scattered!` });

}

export function generateBossLoot(ctx: RoomDO, boss: Boss) {
  const config = ctx.cfg.bosses.lootDrops;
  const dropCount = config.guaranteedDrops + 
    (Math.random() < config.bonusDropChance ? Math.floor(Math.random() * config.maxBonusDrops) : 0);
  
  for (let i = 0; i < dropCount; i++) {
    const angle = (Math.PI * 2 * i) / dropCount + Math.random() * 0.5;
    const distance = 30 + Math.random() * 60;
    const dropX = boss.pos.x + Math.cos(angle) * distance;
    const dropY = boss.pos.y + Math.sin(angle) * distance;
    
    let dropType: PickupType;
    
    // Boss drops: ammo, health, and treasures (no keys)
    const rand = Math.random();
    if (rand < 0.4) {
      // 40% chance for ammo
      dropType = "ammo";
    } else if (rand < 0.6) {
      // 20% chance for health
      dropType = "health";
    } else if (rand < 0.8) {
      // 20% chance for valuable treasures
      const valuableTreasures: PickupType[] = ["gem", "crystal", "orb", "relic", "artifact"];
      dropType = valuableTreasures[Math.floor(Math.random() * valuableTreasures.length)];
    } else {
      // 20% chance for special items
      const specialItems: PickupType[] = ["crown", "scroll", "weapon"];
      dropType = specialItems[Math.floor(Math.random() * specialItems.length)];
    }
    
    ctx.pickups.push({
      id: crypto.randomUUID().slice(0, 6),
      type: dropType,
      x: Math.max(20, Math.min(ctx.W - 20, dropX)),
      y: Math.max(20, Math.min(ctx.H - 20, dropY))
    });
  }

}

export function publicBoss(ctx: RoomDO, boss: any) {
  const visual = ctx.cfg.bosses.types[boss.type].visual;
  return {
    id: boss.id,
    type: boss.type,
    pos: boss.pos,
    hp: boss.hp,
    maxHp: boss.maxHp,
    radius: boss.radius,
    state: boss.state,
    enraged: boss.enraged,
    phased: boss.phased,
    visual: visual
  };

}
</file>

<file path="src/room/systems/broadcast.ts">
import type { RoomDO } from '../index';

export function broadcastState(ctx: RoomDO) {
  // Clean up old damage numbers (older than 1 second to prevent duplicates)
  const now = Date.now();
  ctx.damageNumbers = ctx.damageNumbers.filter(dn => now - dn.timestamp < 1000);

  const snapshot = {
    type: "state",
    t: Date.now(),
    players: [...ctx.players.values()].map(ctx.publicPlayer),
    bullets: ctx.bullets.map(b => ({ id: b.id, x: b.pos.x, y: b.pos.y, ownerId: b.ownerId })),
    globs: ctx.spittles.map(g => ({ id: g.id, x: g.pos.x, y: g.pos.y })),
    walls: ctx.walls.map(o => ({ id: o.id, x: o.x, y: o.y, w: o.w, h: o.h })),
    pickups: ctx.pickups.map(pk => ({ id: pk.id, type: pk.type, x: pk.x, y: pk.y })),
          aiZombies: ctx.aiZombies.map(z => ({ 
      id: z.id, 
      x: z.pos.x, 
      y: z.pos.y, 
      hp: z.hp, 
      maxHp: z.maxHp, 
      zClass: z.zClass, 
      state: z.state,
      detectionRange: z.detectionRange,
      chaseRange: z.chaseRange
    })),
    damageNumbers: ctx.damageNumbers.map(dn => ({
      id: dn.id,
      x: dn.x,
      y: dn.y,
      damage: dn.damage,
      isCrit: dn.isCrit,
      isDot: dn.isDot,
      timestamp: dn.timestamp
    })),
    bosses: ctx.bosses.map(boss => ctx.publicBoss(boss)),
    bossMinions: ctx.bossMinions.map(minion => ({
      id: minion.id,
      bossId: minion.bossId,
      pos: minion.pos,
      hp: minion.hp,
      maxHp: minion.maxHp,
      state: minion.state
    })),
    poisonFields: ctx.poisonFields.map(field => ({
      id: field.id,
      pos: field.pos,
      radius: field.radius,
      dps: field.dps,
      expiresAt: field.expiresAt
    })),
    arena: { w: ctx.W, h: ctx.H },
    remainingTime: Math.max(0, Math.floor(((ctx.roundEndTime || Date.now()) - Date.now()) / 1000)),
    chatEnabled: ctx.chatEnabled,
  };
  const msg = JSON.stringify(snapshot);
  for (const p of ctx.players.values()) {
    if (!p.ws) continue;
    try { p.ws.send(msg); } catch {}
  }

}
</file>

<file path="src/room/systems/combat.ts">
import type { RoomDO } from '../index';
import type { Bullet } from '../room-types';
import { XP_PER_KILL, XP_THRESHOLDS, statsFor } from '../../upgrades';


export function createExplosion(ctx: RoomDO, x: number, y: number, damage: number, radius: number, ownerId: string) {
  // Damage all zombies in radius
  for (const z of ctx.players.values()) {
    if (z.role !== 'zombie' || !z.alive) continue;
    const dist = Math.hypot(z.pos.x - x, z.pos.y - y);
    if (dist <= radius) {
      const dmg = Math.round(damage * (1 - dist / radius)); // Falloff damage
      z.zHp = Math.max(0, (z.zHp ?? ctx.cfg.zombies.baseHp) - dmg);
      // Add damage number
      ctx.addDamageNumber(z.pos.x, z.pos.y, dmg, false, false);
      if ((z.zHp ?? 0) <= 0) {
        z.alive = false;
        ctx.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
        const id = z.id;
        setTimeout(() => { const zp = ctx.players.get(id); if (zp) { zp.pos = ctx.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, ctx.cfg.combat.respawnMs);
      }
    }
  }
  // Damage AI zombies
  for (const z of ctx.aiZombies) {
    const dist = Math.hypot(z.pos.x - x, z.pos.y - y);
    if (dist <= radius) {
      const dmg = Math.round(damage * (1 - dist / radius));
      z.hp = Math.max(0, z.hp - dmg);
      // Add damage number for AI zombies
      ctx.addDamageNumber(z.pos.x, z.pos.y, dmg, false, false);
    }
  }
  ctx.broadcast('notice', { message: 'Impact Explosive death!' });

}

export function spawnSmallExplosion(ctx: RoomDO, b: Bullet) {
  const radius = 26;
  for (const z of ctx.players.values()){
    if (z.role !== 'zombie' || !z.alive) continue;
    if (Math.hypot(z.pos.x - b.pos.x, z.pos.y - b.pos.y) <= radius) {
      z.zHp = Math.max(0, (z.zHp ?? ctx.cfg.zombies.baseHp) - Math.round((b.meta?.damage||20) * 0.5));
      // Add damage number for explosion hit on zombie
      ctx.addDamageNumber(z.pos.x, z.pos.y, Math.round((b.meta?.damage||20) * 0.5), false, false);
      if ((z.zHp ?? 0) <= 0) {
        z.alive = false;
        ctx.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
        const id = z.id;
        setTimeout(() => { const zp = ctx.players.get(id); if (zp) { zp.pos = ctx.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, ctx.cfg.combat.respawnMs);
      }
    }
  }

}

export function addDamageNumber(ctx: RoomDO, x: number, y: number, damage: number, isCrit: boolean = false, isDot: boolean = false) {
  ctx.damageNumbers.push({
    id: crypto.randomUUID().slice(0, 6),
    x, y, damage, isCrit, isDot,
    timestamp: Date.now()
  });

}

export function processDotEffects(ctx: RoomDO, now: number) {
  // Player-controlled zombies
  for (const z of ctx.players.values()){
    if (z.role !== 'zombie' || !z.alive) continue;
    if (z.burns && z.burns.length){
      let kept: typeof z.burns = [];
      for (const e of z.burns){
        if (now > e.until) continue;
        if (now >= e.nextTick) {
          e.nextTick += 1000;
          z.zHp = Math.max(0, (z.zHp ?? ctx.cfg.zombies.baseHp) - e.dps);
          const owner = ctx.players.get(e.ownerId);
          // Lifesteal on DoT damage
          if (owner && owner.role==='streamer') {
            const s = statsFor(owner).s;
            if (s.lifestealPct>0) {
              const heal = Math.max(0, Math.floor(e.dps * s.lifestealPct));
              owner.hp = Math.min(owner.maxHp ?? ctx.cfg.streamer.maxHp, (owner.hp ?? ctx.cfg.streamer.maxHp) + heal);
            }
            owner.score += 1;
            owner.xp = (owner.xp||0) + XP_PER_KILL;
            const need = XP_THRESHOLDS(owner.level||0);
            if ((owner.xp||0) >= need) { owner.xp -= need; owner.level = (owner.level||0) + 1; ctx.offerUpgrades(owner.id); }
          }
          if ((z.zHp ?? 0) <= 0) {
            z.alive = false;
            ctx.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
            const id = z.id;
            setTimeout(()=>{ const zp=ctx.players.get(id); if (zp){ zp.pos=ctx.spawnZombiePos(); zp.alive=true; zp.zHp=zp.zMaxHp; } }, ctx.cfg.combat.respawnMs);
            if (owner && owner.role==='streamer') {
              const s = statsFor(owner).s;
              if (s.reloadOnKillPct>0) ctx.refundAmmoOnKill(owner, s.reloadOnKillPct);
            }
            continue; // don't keep this effect
          }
        }
        kept.push(e);
      }
      z.burns = kept;
    }
    if (z.bleeds && z.bleeds.length){
      let kept: typeof z.bleeds = [];
      for (const e of z.bleeds){
        if (now > e.until) continue;
        if (now >= e.nextTick) {
          e.nextTick += 1000;
          z.zHp = Math.max(0, (z.zHp ?? ctx.cfg.zombies.baseHp) - e.dps);
          const owner = ctx.players.get(e.ownerId);
          if (owner && owner.role==='streamer') {
            const s = statsFor(owner).s;
            if (s.lifestealPct>0) {
              const heal = Math.max(0, Math.floor(e.dps * s.lifestealPct));
              owner.hp = Math.min(owner.maxHp ?? ctx.cfg.streamer.maxHp, (owner.hp ?? ctx.cfg.streamer.maxHp) + heal);
            }
            owner.score += 1;
            owner.xp = (owner.xp||0) + XP_PER_KILL;
            const need = XP_THRESHOLDS(owner.level||0);
            if ((owner.xp||0) >= need) { owner.xp -= need; owner.level = (owner.level||0) + 1; ctx.offerUpgrades(owner.id); }
          }
          if ((z.zHp ?? 0) <= 0) {
            z.alive = false;
            ctx.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
            const id = z.id;
            setTimeout(()=>{ const zp=ctx.players.get(id); if (zp){ zp.pos=ctx.spawnZombiePos(); zp.alive=true; zp.zHp=zp.zMaxHp; } }, ctx.cfg.combat.respawnMs);
            if (owner && owner.role==='streamer') {
              const s = statsFor(owner).s;
              if (s.reloadOnKillPct>0) ctx.refundAmmoOnKill(owner, s.reloadOnKillPct);
            }
            continue;
          }
        }
        kept.push(e);
      }
      z.bleeds = kept;
    }
  }
  // AI zombies
  for (const a of ctx.aiZombies){
    if (a.burns && a.burns.length){
      let kept: typeof a.burns = [];
      for (const e of a.burns){
        if (now > e.until) continue;
        if (now >= e.nextTick) {
          e.nextTick += 1000;
          a.hp = Math.max(0, a.hp - e.dps);
          const owner = ctx.players.get(e.ownerId);
          if (owner && owner.role==='streamer') {
            const s = statsFor(owner).s;
            if (s.lifestealPct>0) {
              const heal = Math.max(0, Math.floor(e.dps * s.lifestealPct));
              owner.hp = Math.min(owner.maxHp ?? ctx.cfg.streamer.maxHp, (owner.hp ?? ctx.cfg.streamer.maxHp) + heal);
            }
            owner.score += 1;
            owner.xp = (owner.xp||0) + XP_PER_KILL;
            const need = XP_THRESHOLDS(owner.level||0);
            if ((owner.xp||0) >= need) { owner.xp -= need; owner.level = (owner.level||0) + 1; ctx.offerUpgrades(owner.id); }
          }
          if (a.hp <= 0) {
            if (owner && owner.role==='streamer') {
              const s = statsFor(owner).s;
              if (s.reloadOnKillPct>0) ctx.refundAmmoOnKill(owner, s.reloadOnKillPct);
            }
            continue; // killed; removal handled in updateAIZombies
          }
        }
        kept.push(e);
      }
      a.burns = kept;
    }
    if (a.bleeds && a.bleeds.length){
      let kept: typeof a.bleeds = [];
      for (const e of a.bleeds){
        if (now > e.until) continue;
        if (now >= e.nextTick) {
          e.nextTick += 1000;
          a.hp = Math.max(0, a.hp - e.dps);
          const owner = ctx.players.get(e.ownerId);
          if (owner && owner.role==='streamer') {
            const s = statsFor(owner).s;
            if (s.lifestealPct>0) {
              const heal = Math.max(0, Math.floor(e.dps * s.lifestealPct));
              owner.hp = Math.min(owner.maxHp ?? ctx.cfg.streamer.maxHp, (owner.hp ?? ctx.cfg.streamer.maxHp) + heal);
            }
            owner.score += 1;
            owner.xp = (owner.xp||0) + XP_PER_KILL;
            const need = XP_THRESHOLDS(owner.level||0);
            if ((owner.xp||0) >= need) { owner.xp -= need; owner.level = (owner.level||0) + 1; ctx.offerUpgrades(owner.id); }
          }
          if (a.hp <= 0) {
            if (owner && owner.role==='streamer') {
              const s = statsFor(owner).s;
              if (s.reloadOnKillPct>0) ctx.refundAmmoOnKill(owner, s.reloadOnKillPct);
            }
            continue;
          }
        }
        kept.push(e);
      }
      a.bleeds = kept;
    }
  }

}

export function refundAmmoOnKill(ctx: RoomDO, owner: Player, pct: number) {
  const w = owner.weapon || 'pistol';
  if (w === 'pistol') {
    const add = Math.max(1, Math.floor(ctx.cfg.weapons.ammo.max.pistol * pct));
    owner.pistolAmmo = Math.min(ctx.cfg.weapons.ammo.max.pistol, (owner.pistolAmmo||0) + add);
  } else if (w === 'smg') {
    const add = Math.max(1, Math.floor(ctx.cfg.weapons.ammo.max.smg * pct));
    owner.smgAmmo = Math.min(ctx.cfg.weapons.ammo.max.smg, (owner.smgAmmo||0) + add);
  } else if (w === 'shotgun') {
    const add = Math.max(1, Math.floor(ctx.cfg.weapons.ammo.max.shotgun * pct));
    owner.shotgunAmmo = Math.min(ctx.cfg.weapons.ammo.max.shotgun, (owner.shotgunAmmo||0) + add);
  }

}

export function applyChainDamage(ctx: RoomDO, b: Bullet, from: {x:number;y:number}, excludeId: string, count: number, dmg: number) {
  const visited = new Set<string>([excludeId]);
  let pos = { x: from.x, y: from.y };
  let remaining = count;
  let damage = dmg;
  const range = 200;
  while (remaining > 0 && damage > 0) {
    let best: { isAI:boolean; p?: Player; a?: AIZombie; id:string; x:number; y:number } | null = null;
    let bestD = Infinity;
    
    // Check player zombies
    for (const z of ctx.players.values()){
      if (z.role !== 'zombie' || !z.alive) continue;
      if (visited.has(z.id)) continue;
      const d = Math.hypot(z.pos.x - pos.x, z.pos.y - pos.y);
      if (d < range && d < bestD) { 
        bestD = d; 
        best = { isAI: false, p: z, id: z.id, x: z.pos.x, y: z.pos.y }; 
      }
    }
    
    // Check AI zombies
    for (const z of ctx.aiZombies) {
      const zid = 'ai:' + z.id; 
      if (visited.has(zid)) continue;
      const d = Math.hypot(z.pos.x - pos.x, z.pos.y - pos.y);
      if (d < range && d < bestD) { 
        bestD = d; 
        best = { isAI: true, a: z, id: zid, x: z.pos.x, y: z.pos.y }; 
      }
    }
    
    if (!best) break;
    
    // Apply damage and show damage number
    if (best.isAI && best.a) {
      // AI zombie hit
      best.a.hp = Math.max(0, best.a.hp - damage);
      ctx.addDamageNumber(best.a.pos.x, best.a.pos.y, damage, false, false);
      
      // Reward owner
      const owner = ctx.players.get(b.ownerId);
      if (owner && owner.role === 'streamer') {
        owner.score += 1;
        owner.xp = (owner.xp || 0) + XP_PER_KILL;
        const need = XP_THRESHOLDS(owner.level || 0);
        if ((owner.xp || 0) >= need) { 
          owner.xp -= need; 
          owner.level = (owner.level || 0) + 1; 
          ctx.offerUpgrades(owner.id); 
        }
        
        // Refund ammo if applicable
        const s = statsFor(owner).s;
        if (s && s.reloadOnKillPct > 0) {
          ctx.refundAmmoOnKill(owner, s.reloadOnKillPct);
        }
      }
    } else if (!best.isAI && best.p) {
      // Player zombie hit
      best.p.zHp = Math.max(0, (best.p.zHp ?? ctx.cfg.zombies.baseHp) - damage);
      ctx.addDamageNumber(best.p.pos.x, best.p.pos.y, damage, false, false);
      
      // Handle zombie death
      if ((best.p.zHp ?? 0) <= 0) {
        best.p.alive = false;
        // Respawn logic would go here if needed
      }
    }
    
    // Update position and reduce damage for next bounce
    if (best) {
      visited.add(best.id);
      pos = { x: best.x, y: best.y };
      remaining -= 1;
      damage = Math.floor(damage * 0.7);
    } else {
      break;
    }
  }

}
</file>

<file path="src/room/systems/input.ts">
import type { RoomDO } from '../index';
import type { Player, Input } from '../room-types';


export function processInputWithLagCompensation(ctx: RoomDO, player: Player, input: Input, timestamp: number) {
  const now = Date.now();
  
  // Calculate lag
  if (player.lastInputTime) {
    const timeDiff = now - player.lastInputTime;
    player.lagMs = Math.max(0, Math.min(500, timeDiff)); // Cap at 500ms
  }
  
  // Store input in buffer for potential rollback
  if (!player.inputBuffer) player.inputBuffer = [];
  player.inputBuffer.push({ input: { ...input }, timestamp });
  
  // Keep only recent inputs (1 second)
  const cutoff = now - 1000;
  player.inputBuffer = player.inputBuffer.filter(i => i.timestamp > cutoff);
  
  // Apply input immediately (server authoritative)
  player.input = input;
  player.lastInputTime = now;

}
</file>

<file path="src/room/systems/map.ts">
import type { RoomDO } from '../index';

export function generateTileMapAndWalls(ctx: RoomDO) {
  const size = ctx.cfg.tiles.size;
  const gw = Math.max(10, Math.floor(ctx.W / size));
  const gh = Math.max(8, Math.floor(ctx.H / size));
  const theme: 'dungeon'|'cave'|'lab' = ctx.cfg.tiles.theme || 'dungeon';
  const tiles = new Uint8Array(gw*gh);
  // Fill with walls (1)
  tiles.fill(1);
  // Carve simple BSP-like rooms and corridors
  const rooms: {x:number;y:number;w:number;h:number}[] = [];
  const carveRoom = (x:number,y:number,w:number,h:number)=>{
    for (let j=y; j<y+h; j++) for (let i=x; i<x+w; i++) if (i>0&&i<gw-1&&j>0&&j<gh-1) tiles[j*gw+i]=0;
    rooms.push({x,y,w,h});
  };
  // Generate many more rooms using grid-based layout
  const gridCellsX = Math.floor(gw / 20); // Cells of ~20 tiles each
  const gridCellsY = Math.floor(gh / 15);
  const cellWidth = Math.floor(gw / gridCellsX);
  const cellHeight = Math.floor(gh / gridCellsY);
  
  // Room types for variety
  const roomTypes = ['small', 'medium', 'large', 'hall', 'chamber', 'vault'];
  
  for (let gy = 0; gy < gridCellsY; gy++) {
    for (let gx = 0; gx < gridCellsX; gx++) {
      // 70% chance to place a room in each grid cell
      if (Math.random() < 0.7) {
        const baseX = gx * cellWidth;
        const baseY = gy * cellHeight;
        const roomType = roomTypes[Math.floor(Math.random() * roomTypes.length)];
        
        let rw, rh;
        switch(roomType) {
          case 'small':
            rw = 5 + Math.floor(Math.random() * 4); // 5-8
            rh = 4 + Math.floor(Math.random() * 3); // 4-6
            break;
          case 'medium':
            rw = 8 + Math.floor(Math.random() * 5); // 8-12
            rh = 6 + Math.floor(Math.random() * 4); // 6-9
            break;
          case 'large':
            rw = 12 + Math.floor(Math.random() * 6); // 12-17
            rh = 8 + Math.floor(Math.random() * 5); // 8-12
            break;
          case 'hall':
            rw = 15 + Math.floor(Math.random() * 8); // 15-22 (long halls)
            rh = 4 + Math.floor(Math.random() * 2); // 4-5 (narrow)
            break;
          case 'chamber':
            rw = 10 + Math.floor(Math.random() * 4); // 10-13 (square-ish)
            rh = 9 + Math.floor(Math.random() * 4); // 9-12
            break;
          case 'vault':
            rw = 6 + Math.floor(Math.random() * 3); // 6-8 (small but important)
            rh = 5 + Math.floor(Math.random() * 2); // 5-6
            break;
          default:
            rw = 8 + Math.floor(Math.random() * 4);
            rh = 6 + Math.floor(Math.random() * 3);
        }
        
        // Ensure room fits in grid cell with margin
        rw = Math.min(rw, cellWidth - 2);
        rh = Math.min(rh, cellHeight - 2);
        
        const rx = baseX + 1 + Math.floor(Math.random() * Math.max(1, cellWidth - rw - 2));
        const ry = baseY + 1 + Math.floor(Math.random() * Math.max(1, cellHeight - rh - 2));
        
        // Ensure room is within bounds
        if (rx + rw < gw - 1 && ry + rh < gh - 1) {
          carveRoom(rx, ry, rw, rh);
        }
      }
    }
  }
  // Create extensive corridor network to connect rooms
  // First, connect adjacent rooms in grid for guaranteed connectivity
  for (let gy = 0; gy < gridCellsY; gy++) {
    for (let gx = 0; gx < gridCellsX; gx++) {
      const currentRooms = rooms.filter(r => 
        r.x >= gx * cellWidth && r.x < (gx + 1) * cellWidth &&
        r.y >= gy * cellHeight && r.y < (gy + 1) * cellHeight
      );
      
      if (currentRooms.length === 0) continue;
      const currentRoom = currentRooms[0];
      
      // Connect to right neighbor
      if (gx < gridCellsX - 1) {
        const rightRooms = rooms.filter(r => 
          r.x >= (gx + 1) * cellWidth && r.x < (gx + 2) * cellWidth &&
          r.y >= gy * cellHeight && r.y < (gy + 1) * cellHeight
        );
        
        if (rightRooms.length > 0) {
          const rightRoom = rightRooms[0];
          const corridorY = Math.floor((currentRoom.y + currentRoom.h/2 + rightRoom.y + rightRoom.h/2) / 2);
          const corridorWidth = 2 + Math.floor(Math.random() * 2);
          
          for (let offset = -Math.floor(corridorWidth/2); offset <= Math.floor(corridorWidth/2); offset++) {
            const cy = corridorY + offset;
            if (cy > 0 && cy < gh - 1) {
              for (let cx = currentRoom.x + currentRoom.w; cx < rightRoom.x; cx++) {
                if (cx > 0 && cx < gw - 1) tiles[cy * gw + cx] = 0;
              }
            }
          }
        }
      }
      
      // Connect to bottom neighbor
      if (gy < gridCellsY - 1) {
        const bottomRooms = rooms.filter(r => 
          r.x >= gx * cellWidth && r.x < (gx + 1) * cellWidth &&
          r.y >= (gy + 1) * cellHeight && r.y < (gy + 2) * cellHeight
        );
        
        if (bottomRooms.length > 0) {
          const bottomRoom = bottomRooms[0];
          const corridorX = Math.floor((currentRoom.x + currentRoom.w/2 + bottomRoom.x + bottomRoom.w/2) / 2);
          const corridorWidth = 2 + Math.floor(Math.random() * 2);
          
          for (let offset = -Math.floor(corridorWidth/2); offset <= Math.floor(corridorWidth/2); offset++) {
            const cx = corridorX + offset;
            if (cx > 0 && cx < gw - 1) {
              for (let cy = currentRoom.y + currentRoom.h; cy < bottomRoom.y; cy++) {
                if (cy > 0 && cy < gh - 1) tiles[cy * gw + cx] = 0;
              }
            }
          }
        }
      }
    }
  }
  
  // Add random long-distance connections for shortcuts and loops
  const numLongConnections = Math.floor(rooms.length * 0.15); // 15% of rooms get long connections
  for (let i = 0; i < numLongConnections; i++) {
    const roomA = rooms[Math.floor(Math.random() * rooms.length)];
    const roomB = rooms[Math.floor(Math.random() * rooms.length)];
    
    if (roomA === roomB) continue;
    
    const ax = Math.floor(roomA.x + roomA.w/2);
    const ay = Math.floor(roomA.y + roomA.h/2);
    const bx = Math.floor(roomB.x + roomB.w/2);
    const by = Math.floor(roomB.y + roomB.h/2);
    
    // Create L-shaped corridor
    const corridorWidth = 2;
    
    // Horizontal segment
    const minx = Math.min(ax, bx);
    const maxx = Math.max(ax, bx);
    for (let offset = -Math.floor(corridorWidth/2); offset <= Math.floor(corridorWidth/2); offset++) {
      const cy = ay + offset;
      if (cy > 0 && cy < gh - 1) {
        for (let cx = minx; cx <= maxx; cx++) {
          if (cx > 0 && cx < gw - 1) tiles[cy * gw + cx] = 0;
        }
      }
    }
    
    // Vertical segment
    const miny = Math.min(ay, by);
    const maxy = Math.max(ay, by);
    for (let offset = -Math.floor(corridorWidth/2); offset <= Math.floor(corridorWidth/2); offset++) {
      const cx = bx + offset;
      if (cx > 0 && cx < gw - 1) {
        for (let cy = miny; cy <= maxy; cy++) {
          if (cy > 0 && cy < gh - 1) tiles[cy * gw + cx] = 0;
        }
      }
    }
  }
  
  // Add environmental variety
  // Water/sludge areas (slow movement) - configurable frequency
  const numWaterAreas = Math.floor(rooms.length * ctx.cfg.tiles.traps.waterFrequency);
  for (let i = 0; i < numWaterAreas; i++) {
    const wx = 3 + Math.floor(Math.random() * (gw - 10));
    const wy = 3 + Math.floor(Math.random() * (gh - 8));
    const ww = 3 + Math.floor(Math.random() * 6);
    const wh = 2 + Math.floor(Math.random() * 5);
    
    for (let j = wy; j < wy + wh && j < gh - 1; j++) {
      for (let i = wx; i < wx + ww && i < gw - 1; i++) {
        if (tiles[j * gw + i] === 0) { // Only replace floor tiles
          tiles[j * gw + i] = 3; // Water/sludge
        }
      }
    }
  }
  
  // Pit traps (lethal) - configurable frequency
  const numPits = Math.floor(rooms.length * ctx.cfg.tiles.traps.pitFrequency);
  for (let i = 0; i < numPits; i++) {
    const px = 2 + Math.floor(Math.random() * (gw - 6));
    const py = 2 + Math.floor(Math.random() * (gh - 6));
    
    if (tiles[py * gw + px] === 0) {
      tiles[py * gw + px] = 2; // Pit
      // Sometimes create larger pit areas
      if (Math.random() < 0.4) {
        const pitSize = 1 + Math.floor(Math.random() * 2);
        for (let dy = 0; dy <= pitSize && py + dy < gh - 1; dy++) {
          for (let dx = 0; dx <= pitSize && px + dx < gw - 1; dx++) {
            if (tiles[(py + dy) * gw + (px + dx)] === 0) {
              tiles[(py + dy) * gw + (px + dx)] = 2;
            }
          }
        }
      }
    }
  }
  // Spike traps (damage over time) - configurable frequency
  const numSpikeTraps = Math.floor(rooms.length * ctx.cfg.tiles.traps.spikeFrequency);
  for (let i = 0; i < numSpikeTraps; i++) {
    const sx = 2 + Math.floor(Math.random() * (gw - 6));
    const sy = 2 + Math.floor(Math.random() * (gh - 6));
    
    if (tiles[sy * gw + sx] === 0) {
      tiles[sy * gw + sx] = 6; // Spikes
      // Sometimes create spike clusters
      if (Math.random() < 0.3) {
        const spikeSize = 1 + Math.floor(Math.random() * 2);
        for (let dy = 0; dy <= spikeSize && sy + dy < gh - 1; dy++) {
          for (let dx = 0; dx <= spikeSize && sx + dx < gw - 1; dx++) {
            if (tiles[(sy + dy) * gw + (sx + dx)] === 0) {
              tiles[(sy + dy) * gw + (sx + dx)] = 6;
            }
          }
        }
      }
    }
  }
  // Poison pools (damage and slow) - configurable frequency
  const numPoisonPools = Math.floor(rooms.length * ctx.cfg.tiles.traps.poisonFrequency);
  for (let i = 0; i < numPoisonPools; i++) {
    const px = 3 + Math.floor(Math.random() * (gw - 10));
    const py = 3 + Math.floor(Math.random() * (gh - 8));
    const pw = 2 + Math.floor(Math.random() * 4);
    const ph = 2 + Math.floor(Math.random() * 3);
    
    for (let j = py; j < py + ph && j < gh - 1; j++) {
      for (let i = px; i < px + pw && i < gw - 1; i++) {
        if (tiles[j * gw + i] === 0) { // Only replace floor tiles
          tiles[j * gw + i] = 7; // Poison
        }
      }
    }
  }
  
  // Add border walls kept
  // Props/Lights - Scale with map size for immersive exploration
  const props: {x:number;y:number;type:'crate'|'pillar'|'bonepile'}[] = [];
  const lights: {x:number;y:number;r:number;a:number}[] = [];
  
  // Scale props with map size - aim for 1 prop per ~300 tiles
  const numProps = Math.floor((gw * gh) / 300);
  for (let k = 0; k < numProps; k++){
    props.push({ 
      x: 2 + Math.floor(Math.random() * (gw - 4)), 
      y: 2 + Math.floor(Math.random() * (gh - 4)), 
      type: (['crate','pillar','bonepile'] as const)[Math.floor(Math.random() * 3)] 
    });
  }
  
  // Scale lights with map size - more atmospheric lighting for exploration
  const numLights = Math.floor((gw * gh) / 500);
  for (let k = 0; k < numLights; k++){
    lights.push({ 
      x: 2 + Math.floor(Math.random() * (gw - 4)), 
      y: 2 + Math.floor(Math.random() * (gh - 4)), 
      r: 3 + Math.floor(Math.random() * 8), 
      a: 0.08 + Math.random() * 0.25 
    });
  }
  ctx.map = { w: gw, h: gh, size, theme, tiles, props, lights, rooms };
  // Derive collision rects from wall tiles via greedy merge
  ctx.walls = ctx.greedyRectsFromTiles(tiles, gw, gh, size);
  ctx.mapReady = true;

}

export function spawnInRandomRoom(ctx: RoomDO) {
  // Spawn within a random room
  if (!ctx.map || ctx.map.rooms.length === 0) {
    // Fallback to center if no rooms available
    return { x: ctx.W / 2, y: ctx.H / 2 };
  }
  
  const room = ctx.map.rooms[Math.floor(Math.random() * ctx.map.rooms.length)];
  const tileSize = ctx.map.size;
  
  // Convert room coordinates to world coordinates and add some padding
  const padding = tileSize * 0.5; // Half tile padding from walls
  const worldX = (room.x + 1) * tileSize + padding + Math.random() * ((room.w - 2) * tileSize - padding * 2);
  const worldY = (room.y + 1) * tileSize + padding + Math.random() * ((room.h - 2) * tileSize - padding * 2);
  
  return { x: worldX, y: worldY };

}

export function spawnZombiePos(ctx: RoomDO) {
  return ctx.spawnInRandomRoom();

}

export function randomFreePos(ctx: RoomDO, buffer = 24) {
  for (let tries = 0; tries < 40; tries++) {
    const x = buffer + Math.random() * (ctx.W - buffer * 2);
    const y = buffer + Math.random() * (ctx.H - buffer * 2);
    // Not too close to center spawn
    if (Math.hypot(x - ctx.W/2, y - ctx.H/2) < 60) continue;
    let ok = true;
    for (const rct of ctx.walls) {
      const margin = 18;
      if (x > rct.x - margin && x < rct.x + rct.w + margin && y > rct.y - margin && y < rct.y + rct.h + margin) { ok = false; break; }
    }
    if (!ok) continue;
    return { x, y };
  }
  return null;

}
</file>

<file path="src/room/systems/pickups.ts">
import type { RoomDO } from '../index';
import type { PickupType } from '../room-types';


export function checkPickupSpawning(ctx: RoomDO) {
  const now = Date.now();
  if (now - ctx.lastPickupSpawn > ctx.pickupIntervalMs) {
    ctx.lastPickupSpawn = now;
    const totalCap = ctx.cfg.pickups.totalCap;
    if (ctx.pickups.length < totalCap) {
      const caps = ctx.cfg.pickups.caps as Record<PickupType, number>;
      const counts = { health:0, speed:0, ammo:0, weapon:0, shield:0, magnet:0, freeze:0, blast:0, treasure:0 } as Record<PickupType, number>;
      for (const pk of ctx.pickups) counts[pk.type]++;
      const types: PickupType[] = ["health","speed","ammo","weapon","shield","magnet","freeze","blast","treasure"]; 
      // Weighted pick: prefer under-cap types
      const options: PickupType[] = [];
      for (const t of types){
        const capacity = Math.max(0, (caps[t]||0)-counts[t]);
        for (let i=0;i<capacity;i++) options.push(t);
      }
      if (options.length > 0) {
        const type = options[Math.floor(Math.random()*options.length)];
        const pos = ctx.randomFreePos(28);
        if (pos && ctx.okDistanceFromPickups(pos.x, pos.y, ctx.cfg.pickups.minDistance)) {
          ctx.pickups.push({ id: crypto.randomUUID().slice(0,6), type, x: pos.x, y: pos.y });
        }
      }
    }
  }

}

export function getRandomZombieDrop(ctx: RoomDO) {
  // First check if any drop should happen at all
  if (Math.random() > ctx.cfg.aiZombies.dropChance) {
    return null; // No drop
  }
  
  const rand = Math.random();
  
  // Use config values for drop chances (normalized since we already passed the drop check)
  const totalChance = ctx.cfg.aiZombies.ammoDropChance + ctx.cfg.aiZombies.treasureDropChance;
  const normalizedAmmoChance = ctx.cfg.aiZombies.ammoDropChance / totalChance;
  
  if (rand < normalizedAmmoChance) {
    return "ammo";
  }
  
  // Treasure drops with configurable rarities
  const treasureRoll = Math.random();
  const rates = ctx.cfg.aiZombies.treasureDropRates;
  
  let cumulative = 0;
  for (const [treasure, rate] of Object.entries(rates)) {
    cumulative += rate;
    if (treasureRoll < cumulative) {
      return treasure as PickupType;
    }
  }
  
  // Fallback to coin if something goes wrong
  return "coin";

}

export function getTreasureValue(ctx: RoomDO, type: PickupType) {
  return ctx.cfg.aiZombies.treasureValues[type] || 0;

}
</file>

<file path="src/room/systems/stats.ts">
import type { RoomDO } from '../index';

export function initRaidStats(ctx: RoomDO, player: any) {
  console.log('Initializing raid stats for player:', player.id, player.name);
  if (!player.raidStats) {
    player.raidStats = {
      enemiesKilled: 0,
      bossesKilled: 0,
      bulletsFired: 0,
      bulletsHit: 0,
      coinsCollected: 0,
      pickupsTaken: 0,
      damageDealt: 0,
      damageTaken: 0,
      totalXPGained: 0,
      startTime: Date.now(),
      enemyBreakdown: {
        basic: 0,
        runner: 0,
        brute: 0,
        spitter: 0,
        stalker: 0,
        bomber: 0
      },
      bossesDefeated: []
    };
  }

}

export function trackEnemyKill(ctx: RoomDO, player: any, enemyType: string) {
  if (player.role !== 'streamer') return; // Only track for streamers
  if (!player.raidStats) ctx.initRaidStats(player);
  player.raidStats!.enemiesKilled++;
  console.log('Enemy killed! Type:', enemyType, 'Total kills:', player.raidStats!.enemiesKilled);
  
  // Track by enemy type
  switch (enemyType) {
    case 'runner':
      player.raidStats!.enemyBreakdown.runner++;
      break;
    case 'brute':
      player.raidStats!.enemyBreakdown.brute++;
      break;
    case 'spitter':
      player.raidStats!.enemyBreakdown.spitter++;
      break;
    case 'stalker':
      player.raidStats!.enemyBreakdown.stalker++;
      break;
    case 'bomber':
      player.raidStats!.enemyBreakdown.bomber++;
      break;
    default:
      player.raidStats!.enemyBreakdown.basic++;
      break;
  }

}

export function trackBossKill(ctx: RoomDO, player: any, bossType?: string) {
  if (player.role !== 'streamer') return; // Only track for streamers
  if (!player.raidStats) ctx.initRaidStats(player);
  player.raidStats!.bossesKilled++;
  if (bossType) {
    player.raidStats!.bossesDefeated.push(bossType);
  }

}

export function trackBulletFired(ctx: RoomDO, player: any) {
  if (player.role !== 'streamer') return; // Only track for streamers
  if (!player.raidStats) ctx.initRaidStats(player);
  player.raidStats!.bulletsFired++;
  console.log('Bullet fired! Total:', player.raidStats!.bulletsFired);

}

export function trackBulletHit(ctx: RoomDO, player: any) {
  if (player.role !== 'streamer') return; // Only track for streamers
  if (!player.raidStats) ctx.initRaidStats(player);
  player.raidStats!.bulletsHit++;

}

export function trackDamageDealt(ctx: RoomDO, player: any, damage: number) {
  if (player.role !== 'streamer') return; // Only track for streamers
  if (!player.raidStats) ctx.initRaidStats(player);
  player.raidStats!.damageDealt += damage;

}

export function trackDamageTaken(ctx: RoomDO, player: any, damage: number) {
  if (player.role !== 'streamer') return; // Only track for streamers
  if (!player.raidStats) ctx.initRaidStats(player);
  player.raidStats!.damageTaken += damage;
  console.log('Damage taken! Amount:', damage, 'Total:', player.raidStats!.damageTaken);

}

export function trackPickupTaken(ctx: RoomDO, player: any, pickupType: string) {
  if (player.role !== 'streamer') return; // Only track for streamers
  if (!player.raidStats) ctx.initRaidStats(player);
  player.raidStats!.pickupsTaken++;
  
  if (pickupType.includes('coin') || pickupType.includes('gem') || 
      pickupType.includes('crystal') || pickupType.includes('treasure')) {
    player.raidStats!.coinsCollected++;
  }

}

export function trackXPGained(ctx: RoomDO, player: any, xp: number) {
  if (player.role !== 'streamer') return; // Only track for streamers
  if (!player.raidStats) ctx.initRaidStats(player);
  player.raidStats!.totalXPGained += xp;

}
</file>

<file path="src/room/systems/update.ts">
import type { RoomDO } from '../index';
import { XP_PER_KILL, XP_THRESHOLDS, statsFor, statusFrom, MOD_INDEX } from '../../upgrades';
import type { Bullet, Player, Pickup, PickupType, Vec, Rect } from '../room-types';
import type { BulletSpawnSpec } from '../../types';
import { TileId } from '../../config';


export function update(ctx: RoomDO) {
  const now = Date.now();

  // Drop stale sockets (missed heartbeats for 40s)
  for (const [id, p] of ctx.players) {
    if (now - p.lastSeen > 40000) {
      ctx.players.delete(id);
    }
  }

  // Process upgrade effects
  ctx.processUpgradeEffects(now);
  
  // Process zombie special abilities
  ctx.processZombieAbilities(now);

  // Extractions removed

  // Update AI Zombies
  ctx.updateAIZombies(now);

  // Spawn AI Zombies if needed
  ctx.spawnAIZombiesIfNeeded(now);

  // Update Boss System
  ctx.updateBossSystem(now);

  // Update Boss Minions
  ctx.updateBossMinions(now);

  // Update Poison Fields
  ctx.updatePoisonFields(now);

  // Integrate movement
  const dt = ctx.tickMs / 1000;
  for (const p of ctx.players.values()) {
    let baseSpeed = p.role === "streamer" ? ctx.cfg.speeds.streamer : ctx.cfg.speeds.zombie; // px/s
    if (p.role === 'zombie' && p.zClass) baseSpeed *= ctx.cfg.zombies.speedMul[p.zClass];
    if (p.role === "zombie" && (ctx.zombieSlowUntil || 0) > now) baseSpeed *= ctx.cfg.speeds.zombieSlowMultiplier; // global slow
    if (p.role === 'zombie' && ((p.slowUntil || 0) > now)) {
      baseSpeed *= Math.max(0.05, p.slowMul || 1);
    }
    if (p.role === 'streamer' && ((p as any).gooSlowUntil || 0) > now) baseSpeed *= ctx.cfg.zombies.spitter.streamerSlowMul;
    // Apply movement speed upgrades for streamer
    if (p.role === 'streamer') {
      const { s } = statsFor(p);
      baseSpeed *= s.movementSpeedMul;
    }
    const boosted = p.role === "zombie" && (p.boostUntil || 0) > now;
    let speed = boosted ? baseSpeed * ctx.cfg.speeds.zombieBoostMultiplier : baseSpeed;
    let vx = 0, vy = 0;
    if (p.input.up) vy -= 1;
    if (p.input.down) vy += 1;
    if (p.input.left) vx -= 1;
    if (p.input.right) vx += 1;
    // Zombie active abilities on left-click
    let useCharge = false; let chargeSpeed = 0;
    if (p.role === 'zombie' && p.zClass) {
      const nowMs = now;
      const since = nowMs - (p.lastAbilityAt || 0);
      if (p.zClass === 'runner') {
        if (p.input.shoot && since >= ctx.cfg.zombies.runnerAbility.cooldownMs) {
          p.boostUntil = nowMs + ctx.cfg.zombies.runnerAbility.durationMs;
          p.lastAbilityAt = nowMs;
        }
      } else if (p.zClass === 'brute') {
        if (p.input.shoot && since >= ctx.cfg.zombies.bruteAbility.cooldownMs) {
          const dirx = (p.input.aimX || p.pos.x) - p.pos.x;
          const diry = (p.input.aimY || p.pos.y) - p.pos.y;
          const d = Math.hypot(dirx, diry) || 1;
          p.chargeDirX = dirx / d; p.chargeDirY = diry / d;
          p.chargeUntil = nowMs + ctx.cfg.zombies.bruteAbility.durationMs;
          p.lastAbilityAt = nowMs;
        }
        if ((p.chargeUntil || 0) > nowMs) {
          useCharge = true; chargeSpeed = ctx.cfg.zombies.bruteAbility.speed;
          vx = p.chargeDirX || 0; vy = p.chargeDirY || 0;
        }
      } else if (p.zClass === 'spitter') {
        if (p.input.shoot && since >= ctx.cfg.zombies.spitter.manualCooldownMs) {
          const dx = (p.input.aimX || p.pos.x) - p.pos.x;
          const dy = (p.input.aimY || p.pos.y) - p.pos.y;
          const d = Math.hypot(dx, dy) || 1;
          const s = ctx.cfg.zombies.spitter.projectileSpeed;
          ctx.spittles.push({ id: crypto.randomUUID().slice(0,6), pos: { x: p.pos.x, y: p.pos.y }, vel: { x: (dx/d)*s, y: (dy/d)*s }, ttl: ctx.cfg.zombies.spitter.projectileTtl });
          p.lastAbilityAt = nowMs;
        }
      }
    }
    const len = Math.hypot(vx, vy) || 1;
    // Handle dash (streamer only)
    if (p.role === 'streamer') {
      // Trigger dash on key press if off cooldown
      const nowMs = Date.now();
      (p as any)._dashLatched = (p as any)._dashLatched || false;
      const ready = (nowMs - (p.lastDashAt || 0)) >= ctx.cfg.dash.cooldownMs;
      if (p.input.dash && ready && !(p as any)._dashLatched) {
        p.dashUntil = nowMs + ctx.cfg.dash.durationMs;
        p.lastDashAt = nowMs;
        (p as any)._dashLatched = true;
      }
      if (!p.input.dash && (p as any)._dashLatched) (p as any)._dashLatched = false;
      // Apply dash speed multiplier if active
      if ((p.dashUntil || 0) > nowMs) {
        const { s } = statsFor(p);
        speed *= ctx.cfg.dash.speedMultiplier * s.dashDistanceMul;
        // Trigger dash reload upgrade
        if (s.dashReloadPct > 0 && !((p as any).dashReloadTriggered)) {
          ctx.refundAmmoOnKill(p, s.dashReloadPct);
          (p as any).dashReloadTriggered = true;
        }
      } else {
        (p as any).dashReloadTriggered = false;
      }
    }
    const moveSpeed = useCharge ? chargeSpeed : speed;
    p.vel.x = (vx / len) * moveSpeed;
    p.vel.y = (vy / len) * moveSpeed;
    // Intended new position
    let nx = p.pos.x + p.vel.x * dt;
    let ny = p.pos.y + p.vel.y * dt;
    // Tile semantics: solid, door, pit, slow
    if (ctx.map) {
      const sz = ctx.map.size;
      const ix = Math.max(0, Math.min(ctx.map.w-1, Math.floor(nx / sz)));
      const iy = Math.max(0, Math.min(ctx.map.h-1, Math.floor(ny / sz)));
      const t = ctx.map.tiles[iy*ctx.map.w + ix] as TileId;
      const isSolid = (tt:TileId)=> tt===1 || tt===4; // wall or doorClosed
      const isLethal = (tt:TileId)=> tt===2; // pit
      const isSlow = (tt:TileId)=> tt===3; // water/sludge
      const isSpikes = (tt:TileId)=> tt===6; // spike trap
      const isPoison = (tt:TileId)=> tt===7; // poison pool
      
      // Door interaction feedback for streamer
      if (p.role === 'streamer' && t === 4) {
        const lastDoorToast = (p as any).lastDoorToast || 0;
        if (now - lastDoorToast > 3000) { // Throttle to every 3 seconds
          ctx.broadcast("notice", { message: "Door Closed door! Find a KEY pickup to open all doors" });
          (p as any).lastDoorToast = now;
        }
      }
      
      if (isSlow(t)) { 
        nx = p.pos.x + (p.vel.x * 0.6) * dt; 
        ny = p.pos.y + (p.vel.y * 0.6) * dt;
        // Water/sludge feedback for streamer
        if (p.role === 'streamer') {
          const lastSlowToast = (p as any).lastSlowToast || 0;
          if (now - lastSlowToast > 4000) {
            ctx.broadcast("notice", { message: "Droplet Moving through water - slowed down!" });
            (p as any).lastSlowToast = now;
          }
        }
      }
      if (isSolid(t)) { nx = p.pos.x; ny = p.pos.y; }
      if (isLethal(t)) {
        if (p.role === 'streamer') {
          ctx.broadcast("notice", { message: "Skull Fell into a pit! Respawning..." });
          p.hp = 0;
          // simple respawn
          p.pos = ctx.spawnInRandomRoom();
          p.hp = p.maxHp ?? ctx.cfg.streamer.maxHp;
          nx = p.pos.x; ny = p.pos.y;
        } else {
          p.alive = false; const id=p.id; setTimeout(()=>{ const zp=ctx.players.get(id); if (zp) { zp.pos=ctx.spawnZombiePos(); zp.alive=true; } }, ctx.cfg.combat.respawnMs);
        }
      }
      
      // Spike trap - damage over time
      if (isSpikes(t)) {
        const lastSpikeDamage = (p as any).lastSpikeDamage || 0;
        if (now - lastSpikeDamage > 500) { // Damage every 0.5 seconds
          if (p.role === 'streamer') {
            const damage = 8; // Moderate damage
            p.hp = Math.max(0, (p.hp ?? ctx.cfg.streamer.maxHp) - damage);
            ctx.trackDamageTaken(p, damage);
            // Add damage number for spikes
            ctx.addDamageNumber(p.pos.x, p.pos.y, damage, false, true);
            ctx.broadcast("notice", { message: "Dagger Stepped on spikes! Taking damage..." });
            (p as any).lastSpikeDamage = now;
            if ((p.hp ?? 0) <= 0) {
              p.pos = ctx.spawnInRandomRoom();
              p.hp = p.maxHp ?? ctx.cfg.streamer.maxHp;
              nx = p.pos.x; ny = p.pos.y;
            }
          } else {
            const damage = 5;
            p.zHp = Math.max(0, (p.zHp ?? ctx.cfg.zombies.baseHp) - damage);
            // Add damage number for zombie on spikes
            ctx.addDamageNumber(p.pos.x, p.pos.y, damage, false, true);
            (p as any).lastSpikeDamage = now;
            if ((p.zHp ?? 0) <= 0) {
              p.alive = false; 
              const id = p.id; 
              setTimeout(() => { 
                const zp = ctx.players.get(id); 
                if (zp) { 
                  zp.pos = ctx.spawnZombiePos(); 
                  zp.alive = true; 
                  zp.zHp = zp.zMaxHp; 
                } 
              }, ctx.cfg.combat.respawnMs);
            }
          }
        }
      }
      
      // Poison pool - damage and slow
      if (isPoison(t)) {
        // Apply slow effect
        nx = p.pos.x + (p.vel.x * 0.4) * dt; 
        ny = p.pos.y + (p.vel.y * 0.4) * dt;
        
        const lastPoisonDamage = (p as any).lastPoisonDamage || 0;
        if (now - lastPoisonDamage > 1000) { // Damage every 1 second
          if (p.role === 'streamer') {
            const damage = 6; // Moderate damage
            p.hp = Math.max(0, (p.hp ?? ctx.cfg.streamer.maxHp) - damage);
            ctx.trackDamageTaken(p, damage);
            // Add damage number for poison
            ctx.addDamageNumber(p.pos.x, p.pos.y, damage, false, true);
            const lastPoisonToast = (p as any).lastPoisonToast || 0;
            if (now - lastPoisonToast > 3000) {
              ctx.broadcast("notice", { message: "Skull Poison pool! Taking damage and slowed..." });
              (p as any).lastPoisonToast = now;
            }
            (p as any).lastPoisonDamage = now;
            if ((p.hp ?? 0) <= 0) {
              p.pos = ctx.spawnInRandomRoom();
              p.hp = p.maxHp ?? ctx.cfg.streamer.maxHp;
              nx = p.pos.x; ny = p.pos.y;
            }
          } else {
            const damage = 4;
            p.zHp = Math.max(0, (p.zHp ?? ctx.cfg.zombies.baseHp) - damage);
            // Add damage number for zombie in poison
            ctx.addDamageNumber(p.pos.x, p.pos.y, damage, false, true);
            (p as any).lastPoisonDamage = now;
            if ((p.zHp ?? 0) <= 0) {
              p.alive = false; 
              const id = p.id; 
              setTimeout(() => { 
                const zp = ctx.players.get(id); 
                if (zp) { 
                  zp.pos = ctx.spawnZombiePos(); 
                  zp.alive = true; 
                  zp.zHp = zp.zMaxHp; 
                } 
              }, ctx.cfg.combat.respawnMs);
            }
          }
        }
      }
    }
    p.pos.x = Math.max(0, Math.min(ctx.W, nx));
    p.pos.y = Math.max(0, Math.min(ctx.H, ny));

    // Resolve collisions with walls (circle vs axis-aligned rectangles)
    const pr = p.role === "streamer" ? ctx.cfg.radii.streamer : ctx.cfg.radii.zombie;
    for (const rct of ctx.walls) {
      const nearestX = Math.max(rct.x, Math.min(p.pos.x, rct.x + rct.w));
      const nearestY = Math.max(rct.y, Math.min(p.pos.y, rct.y + rct.h));
      let dx = p.pos.x - nearestX; let dy = p.pos.y - nearestY; let dist = Math.hypot(dx, dy);
      if (dist < pr) {
        if (dist === 0) {
          // Center is inside rectangle; push out along smallest penetration axis
          const left = Math.abs(p.pos.x - rct.x);
          const right = Math.abs(rct.x + rct.w - p.pos.x);
          const top = Math.abs(p.pos.y - rct.y);
          const bottom = Math.abs(rct.y + rct.h - p.pos.y);
          const m = Math.min(left, right, top, bottom);
          if (m === left) p.pos.x = rct.x - pr;
          else if (m === right) p.pos.x = rct.x + rct.w + pr;
          else if (m === top) p.pos.y = rct.y - pr;
          else p.pos.y = rct.y + rct.h + pr;
        } else {
          const nx = dx / dist, ny = dy / dist;
          const push = (pr - dist) + 0.5;
          p.pos.x += nx * push; p.pos.y += ny * push;
        }
      }
    }

    // Shooting / attacking (streamer only)
    if (p.role === "streamer" && p.input.shoot) {
      const nowMs = Date.now();
      const boostedW = (p.weaponBoostUntil || 0) > nowMs;
      const weapon = p.weapon || "pistol";
      const dirx = p.input.aimX - p.pos.x;
      const diry = p.input.aimY - p.pos.y;
      const d = Math.hypot(dirx, diry) || 1;
      const nx = dirx / d, ny = diry / d;
      const since = nowMs - (p.lastShotAt || 0);
      let { s } = statsFor(p);
      // Apply berserker rage damage bonus
      if (s.berserkerStacks > 0) {
        const recentKills = ((p as any).berserkerKills || []).filter((t: number) => now - t <= 5000);
        const stacks = Math.min(recentKills.length, s.berserkerStacks);
        s = { ...s, damageMul: s.damageMul * (1 + stacks * 0.1) }; // 10% per stack
      }
      if (weapon === "pistol") {
        const baseCd = boostedW ? ctx.cfg.weapons.cooldownMs.pistol.boosted : ctx.cfg.weapons.cooldownMs.pistol.base;
        const cd = baseCd / Math.max(0.01, s.fireRateMul);
        (p as any)._pistolLatched = (p as any)._pistolLatched || false;
        const ammoCost = Math.max(1, Math.floor(1 * s.ammoEfficiencyMul));
        if (since >= cd && (p.pistolAmmo ?? 0) >= ammoCost && !(p as any)._pistolLatched) {
          const speedB = (boostedW ? ctx.cfg.weapons.projectile.pistol.speed * 1.166 : ctx.cfg.weapons.projectile.pistol.speed) * s.projectileSpeedMul;
          const spec: BulletSpawnSpec = {
            pos: { x: p.pos.x, y: p.pos.y },
            vel: { x: nx*speedB, y: ny*speedB },
            ttl: ctx.cfg.weapons.projectile.pistol.ttl,
            ownerId: p.id,
            meta: {
              damage: (ctx.cfg.weapons.damage.pistol||0) * s.damageMul,
              radius: ctx.cfg.radii.bulletMargin * s.bulletSizeMul,
              pierce: s.pierce,
              bounce: s.bounce,
              ricochet: s.ricochet,
              chain: s.chain,
              status: statusFrom(s),
              critChance: s.critChance,
              critMul: s.critMul,
            }
          };
          const spawned: BulletSpawnSpec[] = [spec];
          for (const [id, n] of Object.entries(p.mods||{})) {
            (MOD_INDEX as any)[id]?.hooks?.onShoot?.({ room: ctx as any, playerId: p.id, bullets: spawned, stats: s });
          }
          for (const sp of spawned) {
            ctx.bullets.push({ id: crypto.randomUUID().slice(0,6), ...sp });
            // Track bullet fired
            ctx.trackBulletFired(p);
          }
          p.pistolAmmo = Math.max(0, (p.pistolAmmo ?? 0) - ammoCost);
          p.lastShotAt = nowMs;
          (p as any)._pistolLatched = true;
        }
      } else if (weapon === "smg") {
        const baseCd = boostedW ? ctx.cfg.weapons.cooldownMs.smg.boosted : ctx.cfg.weapons.cooldownMs.smg.base;
        const cd = baseCd / Math.max(0.01, s.fireRateMul);
        const ammoCost = Math.max(1, Math.floor(1 * s.ammoEfficiencyMul));
        if (since >= cd && (p.smgAmmo ?? 0) >= ammoCost) {
          const speedB = (boostedW ? ctx.cfg.weapons.projectile.smg.speed * 1.176 : ctx.cfg.weapons.projectile.smg.speed) * s.projectileSpeedMul;
          const spread = (Math.random()-0.5) * 0.12 * s.spreadMul; // radians
          const cs = Math.cos(spread), sn = Math.sin(spread);
          const vx = nx * cs - ny * sn; const vy = nx * sn + ny * cs;
          const spec: BulletSpawnSpec = {
            pos: { x: p.pos.x, y: p.pos.y },
            vel: { x: vx*speedB, y: vy*speedB },
            ttl: ctx.cfg.weapons.projectile.smg.ttl,
            ownerId: p.id,
            meta: {
              damage: (ctx.cfg.weapons.damage.smg||0) * s.damageMul,
              radius: ctx.cfg.radii.bulletMargin * s.bulletSizeMul,
              pierce: s.pierce,
              bounce: s.bounce,
              ricochet: s.ricochet,
              chain: s.chain,
              status: statusFrom(s),
              critChance: s.critChance,
              critMul: s.critMul,
            }
          };
          const spawned: BulletSpawnSpec[] = [spec];
          for (const [id, n] of Object.entries(p.mods||{})) {
            (MOD_INDEX as any)[id]?.hooks?.onShoot?.({ room: ctx as any, playerId: p.id, bullets: spawned, stats: s });
          }
          for (const sp of spawned) {
            ctx.bullets.push({ id: crypto.randomUUID().slice(0,6), ...sp });
            // Track bullet fired
            ctx.trackBulletFired(p);
          }
          p.smgAmmo = Math.max(0, (p.smgAmmo ?? 0) - ammoCost);
          p.lastShotAt = nowMs;
        }
      } else if (weapon === "shotgun") {
        const baseCd = boostedW ? ctx.cfg.weapons.cooldownMs.shotgun.boosted : ctx.cfg.weapons.cooldownMs.shotgun.base;
        const cd = baseCd / Math.max(0.01, s.fireRateMul);
        const ammoCost = Math.max(1, Math.floor(1 * s.ammoEfficiencyMul));
        if (since >= cd && (p.shotgunAmmo ?? 0) >= ammoCost) {
          const speedB = (boostedW ? ctx.cfg.weapons.projectile.shotgun.speed * 1.2 : ctx.cfg.weapons.projectile.shotgun.speed) * s.projectileSpeedMul;
          const pellets = ctx.cfg.weapons.projectile.shotgun.pellets;
          const spawned: BulletSpawnSpec[] = [];
          for (let i=0;i<pellets;i++){
            const spread = (Math.random()-0.5) * 0.45 * s.spreadMul; // radians
            const cs = Math.cos(spread), sn = Math.sin(spread);
            const vx = nx * cs - ny * sn; const vy = nx * sn + ny * cs;
            spawned.push({
              pos:{x:p.pos.x,y:p.pos.y},
              vel:{x:vx*speedB,y:vy*speedB},
              ttl: ctx.cfg.weapons.projectile.shotgun.ttl,
              ownerId:p.id,
              meta:{
                damage:(ctx.cfg.weapons.damage.shotgun||0) * s.damageMul,
                radius: ctx.cfg.radii.bulletMargin * s.bulletSizeMul,
                pierce: s.pierce,
                bounce: s.bounce,
                ricochet: s.ricochet,
                chain: s.chain,
                status: statusFrom(s),
                critChance: s.critChance,
                critMul: s.critMul,
              }
            });
          }
          for (const [id, n] of Object.entries(p.mods||{})) {
            (MOD_INDEX as any)[id]?.hooks?.onShoot?.({ room: ctx as any, playerId: p.id, bullets: spawned, stats: s });
          }
          for (const sp of spawned) {
            ctx.bullets.push({ id: crypto.randomUUID().slice(0,6), ...sp });
            // Track bullet fired
            ctx.trackBulletFired(p);
          }
          p.shotgunAmmo = Math.max(0, (p.shotgunAmmo ?? 0) - ammoCost);
          p.lastShotAt = nowMs;
        }
      }
    }
    // Always-available bat (melee) on separate input
    if (p.role === "streamer" && p.input.melee) {
      const nowMs = Date.now();
      const since = nowMs - (p.lastMeleeAt || 0);
      const cd = ctx.cfg.melee.cooldownMs;
      if (since >= cd) {
        // Improved aim direction calculation with fallback
        let dirx = p.input.aimX - p.pos.x;
        let diry = p.input.aimY - p.pos.y;

        // Fallback to last melee direction if aim is zero or invalid
        if (Math.hypot(dirx, diry) < 1) {
          if (p.meleeDirX !== undefined && p.meleeDirY !== undefined) {
            dirx = p.meleeDirX;
            diry = p.meleeDirY;
          } else {
            // Default to right if no previous direction
            dirx = 1;
            diry = 0;
          }
        }

        const d = Math.hypot(dirx, diry) || 1;
        const nx = dirx / d, ny = diry / d;
        p.meleeDirX = nx; p.meleeDirY = ny;
        const reach = ctx.cfg.melee.reach;

        // Check PLAYER zombies for melee hits
        for (const z of ctx.players.values()){
          if (z.role !== "zombie" || !z.alive) continue;
          const dx = z.pos.x - p.pos.x;
          const dy = z.pos.y - p.pos.y;
          const dist = Math.hypot(dx, dy);
          if (dist > reach) continue;

          // Improved arc check - use dot product for cone attack
          const zombieDirX = dx / dist;
          const zombieDirY = dy / dist;
          const dot = zombieDirX * nx + zombieDirY * ny;

          // Wider arc check - zombie must be within the attack cone
          if (dot > Math.cos(ctx.cfg.melee.arcRad)) {
            // Apply melee damage
            const damage = ctx.cfg.weapons.damage.melee;
            const oldHp = z.zHp ?? ctx.cfg.zombies.baseHp;
            z.zHp = Math.max(0, oldHp - damage);

            // Apply knockback - push zombie away from player
            const knockbackDistance = ctx.cfg.melee.knockbackStep;
            const newX = z.pos.x + zombieDirX * knockbackDistance;
            const newY = z.pos.y + zombieDirY * knockbackDistance;

            // Clamp to map bounds
            z.pos.x = Math.max(0, Math.min(ctx.W, newX));
            z.pos.y = Math.max(0, Math.min(ctx.H, newY));

            // Add damage number for melee
            ctx.addDamageNumber(z.pos.x, z.pos.y, damage, false, false);

            if ((z.zHp ?? 0) <= 0) {
              z.alive = false;
              // Drop ammo on zombie death
              ctx.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
              const id = z.id;
              setTimeout(() => { const zp = ctx.players.get(id); if (zp) { zp.pos = ctx.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, ctx.cfg.combat.respawnMs);
              p.score += 1;
              // Track enemy kill
              ctx.trackEnemyKill(p, 'basic');
            }
          }
        }

        // Check AI zombies for melee hits (same logic)
        for (const zombie of ctx.aiZombies) {
          const dx = zombie.pos.x - p.pos.x;
          const dy = zombie.pos.y - p.pos.y;
          const dist = Math.hypot(dx, dy);
          if (dist > reach) continue;

          // Same arc check as player zombies
          const zombieDirX = dx / dist;
          const zombieDirY = dy / dist;
          const dot = zombieDirX * nx + zombieDirY * ny;

          if (dot > Math.cos(ctx.cfg.melee.arcRad)) {
            // Apply melee damage
            const damage = ctx.cfg.weapons.damage.melee;
            const oldHp = zombie.hp;
            zombie.hp = Math.max(0, zombie.hp - damage);

            // Apply knockback - push zombie away from player
            const knockbackDistance = ctx.cfg.melee.knockbackStep;
            const newX = zombie.pos.x + zombieDirX * knockbackDistance;
            const newY = zombie.pos.y + zombieDirY * knockbackDistance;

            // Clamp to map bounds
            zombie.pos.x = Math.max(0, Math.min(ctx.W, newX));
            zombie.pos.y = Math.max(0, Math.min(ctx.H, newY));

            // Add damage number for melee
            ctx.addDamageNumber(zombie.pos.x, zombie.pos.y, damage, false, false);

            // Track bullet hit (reuse for melee)
            ctx.trackBulletHit(p);
            ctx.trackDamageDealt(p, damage);

            // Handle AI zombie death
            if (zombie.hp <= 0) {
              // Drop random pickup (ammo or treasure)
              const dropType = ctx.getRandomZombieDrop();
              if (dropType) {
                ctx.pickups.push({
                  id: crypto.randomUUID().slice(0, 6),
                  type: dropType,
                  x: zombie.pos.x,
                  y: zombie.pos.y
                });
              }

              // Award points and XP for AI zombie kill
              p.score += 1;
              p.xp = (p.xp||0) + XP_PER_KILL;
              ctx.trackEnemyKill(p, zombie.zClass || 'basic');
              ctx.trackXPGained(p, XP_PER_KILL);

              // Level up check
              const need = XP_THRESHOLDS(p.level||0);
              if ((p.xp||0) >= need) {
                p.xp = (p.xp||0) - need;
                p.level = (p.level||0) + 1;
                ctx.offerUpgrades(p.id);
              }

              // Remove dead AI zombie
              const idx = ctx.aiZombies.indexOf(zombie);
              if (idx >= 0) ctx.aiZombies.splice(idx, 1);
            }
          }
        }
      }
    }

    // Reset pistol latch when trigger released
    if (p.role === "streamer" && !p.input.shoot) {
      if ((p as any)._pistolLatched) (p as any)._pistolLatched = false;
    }
  }

  // Update bullets
  const aliveBullets: Bullet[] = [];
  for (const b of ctx.bullets) {
    b.ttl -= ctx.tickMs;
    b.pos.x += b.vel.x * dt;
    b.pos.y += b.vel.y * dt;
    if (b.ttl <= 0) continue;
    if (b.pos.x < 0 || b.pos.x > ctx.W || b.pos.y < 0 || b.pos.y > ctx.H) continue;

    // Collision with walls: use bullet-specific radius and allow simple bounce
    let blocked = false;
    for (const rct of ctx.walls) {
      const m = b.meta.radius || ctx.cfg.radii.bulletMargin;
      if (b.pos.x > rct.x - m && b.pos.x < rct.x + rct.w + m && b.pos.y > rct.y - m && b.pos.y < rct.y + rct.h + m) { blocked = true; break; }
    }
    if (blocked) {
      if (b.meta.bounce > 0) {
        b.meta.bounce -= 1;
        // Simple reflection: invert both components
        b.vel.x *= -1; b.vel.y *= -1;
        aliveBullets.push(b);
        continue;
      }
      continue;
    }

    // Collision with zombies (class-based HP)
    let consumed = false;
    for (const p of ctx.players.values()) {
      if (p.role !== "zombie" || !p.alive) continue;
      const r = ctx.cfg.radii.zombie; // zombie radius
      if (Math.hypot(p.pos.x - b.pos.x, p.pos.y - b.pos.y) < r) {
        const base = b.meta.damage || 0;
        const crit = Math.random() < (b.meta.critChance || 0);
        const dealt = Math.max(0, Math.round(base * (crit ? (b.meta.critMul || 1) : 1)));
        p.zHp = Math.max(0, (p.zHp ?? ctx.cfg.zombies.baseHp) - dealt);
        // Add damage number for bullet hit
        ctx.addDamageNumber(p.pos.x, p.pos.y, dealt, crit, false);
        const owner = ctx.players.get(b.ownerId);
        // Track bullet hit
        if (owner) {
          ctx.trackBulletHit(owner);
          ctx.trackDamageDealt(owner, dealt);
        }
        const ownerStats = owner ? statsFor(owner).s : undefined;
        // Lifesteal on hit
        if (owner && ownerStats && ownerStats.lifestealPct > 0 && owner.role === 'streamer') {
          const heal = Math.max(0, Math.floor(dealt * ownerStats.lifestealPct));
          owner.hp = Math.min(owner.maxHp ?? ctx.cfg.streamer.maxHp, (owner.hp ?? ctx.cfg.streamer.maxHp) + heal);
        };
        // Apply status effects
        if (b.meta.status) {
          const nowMs = now;
          const st = b.meta.status;
          if (st.slowMs && st.slowMul && Math.random() < (st.slowChance || 1)) {
            p.slowUntil = nowMs + st.slowMs; p.slowMul = st.slowMul;
          }
          if (st.burnMs && st.burnDps && Math.random() < (st.burnChance || 1)) {
            p.burns = p.burns || [];
            p.burns.push({ until: nowMs + st.burnMs, dps: st.burnDps, nextTick: nowMs + 1000, ownerId: b.ownerId });
          }
          if (st.bleedMs && st.bleedDps && Math.random() < (st.bleedChance || 1)) {
            p.bleeds = p.bleeds || [];
            p.bleeds.push({ until: nowMs + st.bleedMs, dps: st.bleedDps, nextTick: nowMs + 1000, ownerId: b.ownerId });
          }
        }
        // Call onHit hooks
        if (owner && owner.mods) {
          for (const [id, n] of Object.entries(owner.mods)) {
            (MOD_INDEX as any)[id]?.hooks?.onHit?.({ room: ctx as any, bullet: b, targetId: p.id, killed: false, stats: ownerStats || {} });
          }
        }
        let killed = false;
        if ((p.zHp ?? 0) <= 0) {
          p.alive = false; killed = true;
          // Drop ammo on zombie death
          ctx.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: p.pos.x, y: p.pos.y });
          const id = p.id;
          setTimeout(() => { const zp = ctx.players.get(id); if (zp) { zp.pos = ctx.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, ctx.cfg.combat.respawnMs);
          // Reload on kill
          if (owner && ownerStats && ownerStats.reloadOnKillPct > 0 && owner.role === 'streamer') {
            ctx.refundAmmoOnKill(owner, ownerStats.reloadOnKillPct);
          }
          // Reward streamer (only on kill)
          if (owner && owner.role === 'streamer') {
            owner.score += 1;
            owner.xp = (owner.xp||0) + XP_PER_KILL;
            const need = XP_THRESHOLDS(owner.level||0);
            if ((owner.xp||0) >= need) {
              owner.xp = (owner.xp||0) - need; owner.level = (owner.level||0) + 1;
              ctx.offerUpgrades(owner.id);
            }
          }
          // Call onKill hooks and handle berserker stacks
          if (killed && owner && owner.mods) {
            for (const [id, n] of Object.entries(owner.mods)) {
              (MOD_INDEX as any)[id]?.hooks?.onKill?.({ room: ctx as any, killerId: owner.id, victimId: p.id, stats: ownerStats || {} });
            }
            // Track berserker kills
            if (ownerStats && ownerStats.berserkerStacks > 0) {
              (owner as any).berserkerKills = (owner as any).berserkerKills || [];
              (owner as any).berserkerKills.push(now);
            }
            // Blood aura healing
            if (ownerStats && ownerStats.vampireAuraRange > 0) {
              const healAmount = Math.floor(ownerStats.vampireAuraRange / 10); // 5 HP per 50px range
              owner.hp = Math.min(owner.maxHp ?? ctx.cfg.streamer.maxHp, (owner.hp ?? ctx.cfg.streamer.maxHp) + healAmount);
            }
          }
        }
        // Handle pierce or ricochet
        if (b.meta.pierce > 0) {
          b.meta.pierce -= 1; aliveBullets.push(b);
        } else {
          // Try ricochet if available
          if (b.meta.ricochet > 0 && ctx.retargetBulletRicochet(b, p.id)) {
            b.meta.ricochet -= 1; aliveBullets.push(b);
          } else {
            consumed = true;
          }
        }
        // Chain lightning
        if (b.meta.chain > 0) {
          ctx.applyChainDamage(b, { x: b.pos.x, y: b.pos.y }, p.id, b.meta.chain, Math.round((b.meta.damage||0)*0.7));
        }
        break;
      }
    }
    // If not consumed by player-zombie hit, check collision with AI zombies
    if (!consumed) {
      let hitAI = false;
      for (const zombie of ctx.aiZombies) {
        const r = ctx.cfg.radii.zombie;
        if (Math.hypot(zombie.pos.x - b.pos.x, zombie.pos.y - b.pos.y) < r) {
          const base = b.meta.damage || 0;
          const crit = Math.random() < (b.meta.critChance || 0);
          const dealt = Math.max(0, Math.round(base * (crit ? (b.meta.critMul || 1) : 1)));
          zombie.hp = Math.max(0, zombie.hp - dealt);
          // Add damage number for bullet hit on AI zombie
          ctx.addDamageNumber(zombie.pos.x, zombie.pos.y, dealt, crit, false);
          const owner = ctx.players.get(b.ownerId);
          // Track bullet hit
          if (owner) {
            ctx.trackBulletHit(owner);
            ctx.trackDamageDealt(owner, dealt);
          }
          const ownerStats = owner ? statsFor(owner).s : undefined;
          // Lifesteal
          if (owner && ownerStats && ownerStats.lifestealPct > 0 && owner.role === 'streamer') {
            const heal = Math.max(0, Math.floor(dealt * ownerStats.lifestealPct));
            owner.hp = Math.min(owner.maxHp ?? ctx.cfg.streamer.maxHp, (owner.hp ?? ctx.cfg.streamer.maxHp) + heal);
          }
          // Status effects
          if (b.meta.status) {
            const nowMs = now;
            const st = b.meta.status;
            if (st.slowMs && st.slowMul && Math.random() < (st.slowChance || 1)) { zombie.slowUntil = nowMs + st.slowMs; zombie.slowMul = st.slowMul; }
            if (st.burnMs && st.burnDps && Math.random() < (st.burnChance || 1)) { zombie.burns = zombie.burns || []; zombie.burns.push({ until: nowMs + st.burnMs, dps: st.burnDps, nextTick: nowMs + 1000, ownerId: b.ownerId }); }
            if (st.bleedMs && st.bleedDps && Math.random() < (st.bleedChance || 1)) { zombie.bleeds = zombie.bleeds || []; zombie.bleeds.push({ until: nowMs + st.bleedMs, dps: st.bleedDps, nextTick: nowMs + 1000, ownerId: b.ownerId }); }
          }
          // Kill check for reload-on-kill
          const wasKilled = zombie.hp <= 0;
          if (wasKilled && owner && ownerStats && ownerStats.reloadOnKillPct > 0 && owner.role === 'streamer') {
            ctx.refundAmmoOnKill(owner, ownerStats.reloadOnKillPct);
          }
          // Reward streamer (only on kill)
          if (wasKilled && owner && owner.role === 'streamer') {
            owner.score += 1;
            owner.xp = (owner.xp||0) + XP_PER_KILL;
            // Track AI zombie kill
            ctx.trackEnemyKill(owner, zombie.zClass || 'basic');
            ctx.trackXPGained(owner, XP_PER_KILL);
            const need = XP_THRESHOLDS(owner.level||0);
            if ((owner.xp||0) >= need) { owner.xp -= need; owner.level = (owner.level||0) + 1; ctx.offerUpgrades(owner.id); }
          }
          // Pierce/ricochet handling
          if (b.meta.pierce > 0) { b.meta.pierce -= 1; aliveBullets.push(b); }
          else if (b.meta.ricochet > 0 && ctx.retargetBulletRicochet(b, 'ai:'+zombie.id)) { b.meta.ricochet -= 1; aliveBullets.push(b); }
          else { consumed = true; }
          // Chain lightning
          if (b.meta.chain > 0) { ctx.applyChainDamage(b, { x: b.pos.x, y: b.pos.y }, 'ai:'+zombie.id, b.meta.chain, Math.round((b.meta.damage||0)*0.7)); }
          hitAI = true;
          break;
        }
      }
      // Check collision with bosses if not consumed by zombies
      if (!hitAI && !consumed) {
        let hitBoss = false;
        for (const boss of ctx.bosses) {
          if (boss.state === "dying") continue;
          
          // Skip if boss is phased (Shadow Lord ability)
          if (boss.phased) continue;
          
          const bossRadius = boss.radius;
          if (Math.hypot(boss.pos.x - b.pos.x, boss.pos.y - b.pos.y) < bossRadius) {
            const base = b.meta.damage || 0;
            const crit = Math.random() < (b.meta.critChance || 0);
            const dealt = Math.max(0, Math.round(base * (crit ? (b.meta.critMul || 1) : 1)));
            boss.hp = Math.max(0, boss.hp - dealt);
            
            // Add damage number for boss hit
            ctx.addDamageNumber(boss.pos.x, boss.pos.y, dealt, crit, false);
            
            const owner = ctx.players.get(b.ownerId);
            const ownerStats = owner ? statsFor(owner).s : undefined;
            
            // Lifesteal on boss hit
            if (owner && ownerStats && ownerStats.lifestealPct > 0 && owner.role === 'streamer') {
              const heal = Math.max(0, Math.floor(dealt * ownerStats.lifestealPct));
              owner.hp = Math.min(owner.maxHp ?? ctx.cfg.streamer.maxHp, (owner.hp ?? ctx.cfg.streamer.maxHp) + heal);
            }
            
            // Check if boss died
            if (boss.hp <= 0 && (boss.state as any) !== "dying") {
              boss.state = "dying";
              // Reward streamer for boss kill
              if (owner && owner.role === 'streamer') {
                // Track boss kill
                ctx.trackBossKill(owner, boss.type);
                owner.score += 10; // More points for boss kill
                const bossXP = XP_PER_KILL * 5; // 5x XP for boss
                owner.xp = (owner.xp||0) + bossXP;
                ctx.trackXPGained(owner, bossXP);
                const need = XP_THRESHOLDS(owner.level||0);
                if ((owner.xp||0) >= need) {
                  owner.xp = (owner.xp||0) - need;
                  owner.level = (owner.level||0) + 1;
                  ctx.offerUpgrades(owner.id);
                }
              }
            }
            
            // Pierce/ricochet handling
            if (b.meta.pierce > 0) {
              b.meta.pierce -= 1;
              aliveBullets.push(b);
            } else if (b.meta.ricochet > 0 && ctx.retargetBulletRicochet(b, 'boss:'+boss.id)) {
              b.meta.ricochet -= 1;
              aliveBullets.push(b);
            } else {
              consumed = true;
            }
            
            // Chain lightning
            if (b.meta.chain > 0) {
              ctx.applyChainDamage(b, { x: b.pos.x, y: b.pos.y }, 'boss:'+boss.id, b.meta.chain, Math.round((b.meta.damage||0)*0.7));
            }
            
            hitBoss = true;
            break;
          }
        }
        
        if (!hitBoss && !consumed) aliveBullets.push(b);
      }
    }
  }
  ctx.bullets = aliveBullets;

  // Process damage-over-time effects (burn/bleed) for both player zombies and AI zombies
  ctx.processDotEffects(now);

  // Find streamer at the start of the update
  const streamer = [...ctx.players.values()].find(p => p.role === "streamer");

  // Update spitter globs
  const aliveGlobs: typeof ctx.spittles = [];
  for (const g of ctx.spittles) {
    g.ttl -= ctx.tickMs;
    g.pos.x += g.vel.x * dt;
    g.pos.y += g.vel.y * dt;
    if (g.ttl <= 0) continue;
    if (g.pos.x < 0 || g.pos.x > ctx.W || g.pos.y < 0 || g.pos.y > ctx.H) continue;
    // collide with streamer
    if (streamer) {
      const r = ctx.cfg.radii.streamer + 2;
      if (Math.hypot(streamer.pos.x - g.pos.x, streamer.pos.y - g.pos.y) < r) {
        // apply slow and small damage
        (streamer as any).gooSlowUntil = now + ctx.cfg.zombies.spitter.slowMs;
        streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - ctx.cfg.zombies.spitter.hitDamage);
        ctx.trackDamageTaken(streamer, ctx.cfg.zombies.spitter.hitDamage);
        continue; // glob consumed
      }
    }
    aliveGlobs.push(g);
  }
  ctx.spittles = aliveGlobs;

  // Zombie damage to streamer
  if (streamer) {
    // Check for ghost walk invulnerability
    const isInvulnerable = ((streamer as any).ghostWalkUntil || 0) > now;
    // Dash-kill pass: if streamer is dashing, kill non-brute zombies on contact
    if ((streamer.dashUntil || 0) > now) {
      for (const z of ctx.players.values()) {
        if (z.role !== 'zombie' || !z.alive) continue;
        const dist = Math.hypot(z.pos.x - streamer.pos.x, z.pos.y - streamer.pos.y);
        const thresh = ctx.cfg.radii.zombie + ctx.cfg.radii.streamer;
        if (dist <= thresh) {
          if (z.zClass === 'brute') {
            continue; // brutes resist dash kill
          }
          z.zHp = 0; z.alive = false;
          // Drop ammo on zombie death
          ctx.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
          const id = z.id;
          setTimeout(() => { const zp = ctx.players.get(id); if (zp) { zp.pos = ctx.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, ctx.cfg.combat.respawnMs);
          streamer.score += 1;
        }
      }
    }
    // Spitter AI: fire globs toward streamer
    for (const z of ctx.players.values()){
      if (z.role !== 'zombie' || !z.alive || z.zClass !== 'spitter') continue;
      const rng = ctx.cfg.zombies.spitter.range;
      const dx = streamer.pos.x - z.pos.x; const dy = streamer.pos.y - z.pos.y; const dist = Math.hypot(dx, dy);
      if (dist <= rng && (z.nextSpitAt || 0) <= now) {
        const s = ctx.cfg.zombies.spitter.projectileSpeed;
        const nx = (dx / (dist||1)); const ny = (dy / (dist||1));
        ctx.spittles.push({ id: crypto.randomUUID().slice(0,6), pos: { x: z.pos.x, y: z.pos.y }, vel: { x: nx * s, y: ny * s }, ttl: ctx.cfg.zombies.spitter.projectileTtl });
        z.nextSpitAt = now + ctx.randRange(ctx.cfg.zombies.spitter.cooldownMsMin, ctx.cfg.zombies.spitter.cooldownMsMax);
      }
    }
    for (const z of ctx.players.values()) {
      if (z.role !== "zombie" || !z.alive) continue;
      const dist = Math.hypot(z.pos.x - streamer.pos.x, z.pos.y - streamer.pos.y);
      if (dist < 16) {
        const shielded = ((streamer as any).shieldUntil || 0) > now;
        if (!shielded && !isInvulnerable) {
          if ((streamer.hp ?? ctx.cfg.streamer.maxHp) > 0) {
            streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - ctx.cfg.combat.zombieTouchDamage);
            ctx.trackDamageTaken(streamer, ctx.cfg.combat.zombieTouchDamage);
          }
          if ((streamer.hp ?? 0) <= 0) {
            // Handle explosive death before respawn
            const { s } = statsFor(streamer);
            if (s.explosiveDeathDamage > 0) {
              ctx.createExplosion(streamer.pos.x, streamer.pos.y, s.explosiveDeathDamage, 60, streamer.id);
            }
            // Respawn streamer; lose unbanked on death (keep banked)
            streamer.pos = ctx.spawnInRandomRoom();
            streamer.hp = streamer.maxHp ?? ctx.cfg.streamer.maxHp;
            streamer.score = 0;
          }
        }// Knockback streamer slightly
        const dx = streamer.pos.x - z.pos.x; const dy = streamer.pos.y - z.pos.y; const d = Math.hypot(dx, dy) || 1;
        const kbMul = (z.zClass === 'brute') ? ctx.cfg.zombies.brute.extraKnockbackMul : 1;
        streamer.pos.x = Math.max(0, Math.min(ctx.W, streamer.pos.x + (dx / d) * ctx.cfg.combat.knockbackStep * kbMul));
        streamer.pos.y = Math.max(0, Math.min(ctx.H, streamer.pos.y + (dy / d) * ctx.cfg.combat.knockbackStep * kbMul));
        // Teleport zombie to edge to avoid instant re-hit
        z.pos = ctx.spawnZombiePos();
      }
    }
  }

  // (duplicate spawning block removed; handled by checkPickupSpawning())

  // Pickup collection
  const remaining: Pickup[] = [];
  for (const p of ctx.pickups) {
    let taken = false;
    for (const pl of ctx.players.values()) {
      const pr = pl.role === "streamer" ? 10 : 12;
      const pickupR = (pl.role === "streamer" && (((pl as any).magnetUntil || 0) > now)) ? 26 : 10;
      if (Math.hypot(pl.pos.x - p.x, pl.pos.y - p.y) < pr + pickupR) { // pickup radius
        if (p.type === "health" && pl.role === "streamer") {
          pl.hp = Math.min(pl.maxHp ?? ctx.cfg.streamer.maxHp, (pl.hp ?? ctx.cfg.streamer.maxHp) + 20);
          ctx.broadcast("notice", { message: "Love Health restored!" });
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
        if (p.type === "speed" && pl.role === "zombie") {
          pl.boostUntil = now + ctx.cfg.effects.zombieBoostMs; // speed boost
          taken = true; break;
        }
        if (p.type === "ammo" && pl.role === "streamer") {
          pl.pistolAmmo = Math.min((pl.pistolAmmo ?? 0) + ctx.cfg.weapons.ammo.pickupGain.pistol, ctx.cfg.weapons.ammo.max.pistol);
          pl.smgAmmo = Math.min((pl.smgAmmo ?? 0) + ctx.cfg.weapons.ammo.pickupGain.smg, ctx.cfg.weapons.ammo.max.smg);
          pl.shotgunAmmo = Math.min((pl.shotgunAmmo ?? 0) + ctx.cfg.weapons.ammo.pickupGain.shotgun, ctx.cfg.weapons.ammo.max.shotgun);
          ctx.broadcast("notice", { message: "Pistol Ammo refilled for all weapons!" });
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
        if (p.type === "weapon" && pl.role === "streamer") {
          // If currently bat-only, grant pistol and some starter ammo; otherwise weapon boost
          if ((pl.weapon||'bat') === 'bat') {
            pl.weapon = 'pistol';
            pl.pistolAmmo = Math.max(pl.pistolAmmo||0, 30);
            ctx.broadcast("notice", { message: "Pistol Pistol unlocked with ammo!" });
          } else {
            ctx.broadcast("notice", { message: "Shock Weapon boost activated!" });
          }
          pl.weaponBoostUntil = now + ctx.cfg.effects.weaponBoostMs; // better weapon
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
        if (p.type === "shield" && pl.role === "streamer") {
          (pl as any).shieldUntil = now + ctx.cfg.effects.shieldMs; // shield
          ctx.broadcast("notice", { message: "Shield Shield activated - temporary invulnerability!" });
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
        if (p.type === "magnet" && pl.role === "streamer") {
          (pl as any).magnetUntil = now + ctx.cfg.effects.magnetMs; // big pickup radius
          ctx.broadcast("notice", { message: "Magnet Magnet activated - larger pickup radius!" });
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
        if (p.type === "freeze" && pl.role === "streamer") {
          ctx.zombieSlowUntil = now + ctx.cfg.effects.freezeMs; // slow zombies globally
          ctx.broadcast("notice", { message: "Snow Freeze activated - all zombies slowed!" });
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
        if (p.type === "blast" && pl.role === "streamer") {
          // Clear nearby zombies and score for each
          const radius = ctx.cfg.pickups.blastRadius;
          let zombiesHit = 0;
          for (const z of ctx.players.values()){
            if (z.role !== "zombie" || !z.alive) continue;
            if (Math.hypot(z.pos.x - pl.pos.x, z.pos.y - pl.pos.y) <= radius){
              z.zHp = Math.max(0, (z.zHp ?? ctx.cfg.zombies.baseHp) - 100);
              // Add damage number for blast hit on zombie
              ctx.addDamageNumber(z.pos.x, z.pos.y, 100, false, false);
              if ((z.zHp ?? 0) <= 0) {
                z.alive = false;
                zombiesHit++;
                // Drop ammo on zombie death
                ctx.pickups.push({ id: crypto.randomUUID().slice(0,6), type: 'ammo', x: z.pos.x, y: z.pos.y });
                const id = z.id;
                setTimeout(() => { const zp = ctx.players.get(id); if (zp) { zp.pos = ctx.spawnZombiePos(); zp.alive = true; zp.zHp = zp.zMaxHp; } }, ctx.cfg.combat.respawnMs);
                if (pl.role === "streamer") pl.score += 1;
              }
            }
          }
          ctx.broadcast("notice", { message: `Impact Blast killed ${zombiesHit} zombies!` });
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
        if (p.type === "treasure" && pl.role === "streamer") {
          pl.score += ctx.cfg.pickups.treasureScore;
          ctx.broadcast("notice", { message: `Gem Treasure found! +${ctx.cfg.pickups.treasureScore} points` });
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
        // Handle new treasure types
        const treasureValue = ctx.getTreasureValue(p.type);
        if (treasureValue > 0 && pl.role === "streamer") {
          pl.score += treasureValue;
          const treasureNames: Record<string, string> = {
            coin: "MoneyBag Coin",
            gem: "Gem Gem", 
            crystal: "CrystalBall Crystal",
            orb: "Star Orb",
            relic: "Vase Relic",
            artifact: "Coffin Artifact",
            medallion: "Medal Medallion",
            scroll: "Scroll Scroll",
            crown: "Crown Crown"
          };
          const name = treasureNames[p.type] || "Gem Treasure";
          ctx.broadcast("notice", { message: `${name} found! +${treasureValue} points` });
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
        if (p.type === "key" && pl.role === "streamer") {
          // Open all doors: convert tile 4 (doorClosed) to 5 (doorOpen)
          if (ctx.map) {
            for (let i=0;i<ctx.map.tiles.length;i++) if (ctx.map.tiles[i]===4) ctx.map.tiles[i]=5;
            // Broadcast updated map to all clients
            const base64 = ctx.u8ToBase64(ctx.map.tiles);
            ctx.broadcast('map', { map: { w: ctx.map.w, h: ctx.map.h, size: ctx.map.size, theme: ctx.map.theme, tilesBase64: base64, props: ctx.map.props, lights: ctx.map.lights } });
          }
          ctx.broadcast("notice", { message: "Key Key used! All doors are now open!" });
          ctx.trackPickupTaken(pl, p.type);
          taken = true; break;
        }
      }
    }
    if (!taken) remaining.push(p);
  }
  ctx.pickups = remaining;

  // Extractions removed

  const s = [...ctx.players.values()].find(p => p.role === "streamer");

  // Round timer: reset when time elapses
  if ((ctx.roundEndTime || 0) > 0 && now >= (ctx.roundEndTime as number)) {
    // On round end, just reset unbanked score (no extractions)
    if (s) { s.score = 0; }

    ctx.roundEndTime = now + ctx.roundDurationMs;
    ctx.bullets = [];
    ctx.pickups = [];
    // Extractions removed - no respawn/rotation
    // Optionally regenerate map each round (for variety)
    ctx.generateTileMapAndWalls();
    // Broadcast new map to all clients
    if (ctx.map) {
      const base64 = ctx.u8ToBase64(ctx.map.tiles);
      ctx.broadcast('map', { map: { w: ctx.map.w, h: ctx.map.h, size: ctx.map.size, theme: ctx.map.theme, tilesBase64: base64, props: ctx.map.props, lights: ctx.map.lights } });
    }
    for (const p of ctx.players.values()) {
      if (p.role === "streamer") {
        p.pos = { x: ctx.W / 2, y: ctx.H / 2 };
        p.alive = true;
        p.hp = p.maxHp ?? ctx.cfg.streamer.maxHp;
        p.weapon = "pistol";
        p.pistolAmmo = ctx.cfg.weapons.ammo.initial.pistol;
        p.smgAmmo = 0;
        p.shotgunAmmo = 0;
      } else {
        p.pos = ctx.spawnZombiePos();
        p.alive = true;
        p.boostUntil = undefined;
        p.zHp = p.zMaxHp;
      }
    }
    // Let clients know a new round started
    ctx.broadcast("notice", { message: "New round!" });
  }

}
</file>

<file path="src/room/systems/upgrades.ts">
import type { RoomDO } from '../index';
import { statsFor, rollChoices } from '../../upgrades';
import type { ModId } from '../../types';


export function processUpgradeEffects(ctx: RoomDO, now: number) {
  for (const p of ctx.players.values()) {
    if (p.role !== 'streamer' || !p.mods) continue;
    const { s } = statsFor(p);
    
    // Shield regeneration (auto-repair)
    if (s.shieldRegenRate > 0) {
      if (!p.lastShieldRegen || now - p.lastShieldRegen >= 3000) {
        if ((p.hp ?? 0) < (p.maxHp ?? ctx.cfg.streamer.maxHp)) {
          p.hp = Math.min((p.maxHp ?? ctx.cfg.streamer.maxHp), (p.hp ?? 0) + 1);
          p.lastShieldRegen = now;
        }
      }
    }
    
    // Time dilation (bullet time when low health)
    if (s.timeDilationMs > 0) {
      const healthPct = (p.hp || 0) / (p.maxHp || ctx.cfg.streamer.maxHp);
      if (healthPct <= 0.25 && !((p as any).timeDilationUntil > now)) {
        (p as any).timeDilationUntil = now + s.timeDilationMs;
        ctx.broadcast('notice', { message: 'Alarm Time slows as death approaches...' });
      }
    }
    
    // Bullet time during dash
    if (s.bulletTimeMs > 0 && (p.dashUntil || 0) > now) {
      (p as any).bulletTimeUntil = Math.max((p as any).bulletTimeUntil || 0, now + s.bulletTimeMs);
    }
  }

}

export function offerUpgrades(ctx: RoomDO, playerId: string) {
  const p = ctx.players.get(playerId);
  if (!p || p.role !== 'streamer') return;
  const choices = rollChoices(p.mods || {}, Math.random);
  try {
    p.ws?.send(JSON.stringify({
      type: 'upgrade_offer',
      level: p.level || 0,
      choices: choices.map(c => ({ id: c.id, name: c.name, desc: c.desc, rarity: c.rarity, currentStacks: (p.mods?.[c.id as keyof typeof p.mods] as number) || 0 }))
    }));
  } catch {}

}

export function applyUpgrade(ctx: RoomDO, playerId: string, id: ModId) {
  const p = ctx.players.get(playerId);
  if (!p || p.role !== 'streamer') return;
  p.mods = p.mods || {};
  const prev = (p.mods[id] || 0) as number;
  (p.mods as any)[id] = prev + 1;
  ctx.broadcast('notice', { message: `${p.name} chose ${String(id).replace(/_/g,' ')}` });

}
</file>

<file path="src/room/systems/zombie-abilities.ts">
import type { RoomDO } from '../index';
import type { Player, AIZombie } from '../room-types';


export function processZombieAbilities(ctx: RoomDO, now: number) {
  // Process player zombies
  for (const z of ctx.players.values()) {
    if (z.role !== 'zombie' || !z.alive) continue;
    
    // Stalker cloaking mechanics
    if (z.zClass === 'stalker') {
      if (!z.cloakUntil) {
        z.cloakUntil = now + ctx.cfg.zombies.stalker.cloakDurationMs;
        z.cloaked = true;
      } else if (z.cloakUntil < now && z.cloaked) {
        z.cloaked = false;
        z.uncloakUntil = now + ctx.cfg.zombies.stalker.uncloakDurationMs;
      } else if (z.uncloakUntil && z.uncloakUntil < now) {
        z.cloakUntil = now + ctx.cfg.zombies.stalker.cloakDurationMs;
        z.cloaked = true;
        z.uncloakUntil = undefined;
      }
    }
    
    // Bomber fuse mechanics
    if (z.zClass === 'bomber' && z.zHp && z.zHp <= (z.zMaxHp || 100) * 0.3) {
      if (!z.fuseStarted) {
        z.fuseStarted = now;
        z.fuseUntil = now + ctx.cfg.zombies.bomber.fuseTimeMs;
        ctx.broadcast('notification', { message: `Bomber ${z.name} is about to explode!` });
      }
      
      if (z.fuseUntil && now >= z.fuseUntil) {
        ctx.bomberExplode(z, now);
      }
    }
  }
  
  // Process AI zombies
  for (const z of ctx.aiZombies) {
    // Stalker cloaking for AI
    if (z.zClass === 'stalker') {
      if (!z.cloakUntil) {
        z.cloakUntil = now + ctx.cfg.zombies.stalker.cloakDurationMs;
        z.cloaked = true;
      } else if (z.cloakUntil < now && z.cloaked) {
        z.cloaked = false;
        z.uncloakUntil = now + ctx.cfg.zombies.stalker.uncloakDurationMs;
      } else if (z.uncloakUntil && z.uncloakUntil < now) {
        z.cloakUntil = now + ctx.cfg.zombies.stalker.cloakDurationMs;
        z.cloaked = true;
        z.uncloakUntil = undefined;
      }
    }
    
    // Bomber fuse for AI
    if (z.zClass === 'bomber' && z.hp <= z.maxHp * 0.3) {
      if (!z.fuseStarted) {
        z.fuseStarted = now;
        z.fuseUntil = now + ctx.cfg.zombies.bomber.fuseTimeMs;
      }
      
      if (z.fuseUntil && now >= z.fuseUntil) {
        ctx.bomberExplodeAI(z, now);
      }
    }
  }

}

export function bomberExplode(ctx: RoomDO, bomber: Player, now: number) {
  const radius = ctx.cfg.zombies.bomber.explosionRadius;
  const damage = ctx.cfg.zombies.bomber.explosionDamage;
  
  // Damage streamer if in range
  const streamer = [...ctx.players.values()].find(p => p.role === 'streamer');
  if (streamer) {
    const dist = Math.hypot(bomber.pos.x - streamer.pos.x, bomber.pos.y - streamer.pos.y);
    if (dist <= radius) {
      const dmg = Math.round(damage * (1 - dist / radius));
      streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - dmg);
      ctx.trackDamageTaken(streamer, dmg);
      ctx.broadcast('notification', { message: `Bomber explosion deals ${dmg} damage!` });
    }
  }
  
  // Kill the bomber
  bomber.alive = false;
  bomber.zHp = 0;
  
  // Create explosion effect
  ctx.broadcast('explosion', { x: bomber.pos.x, y: bomber.pos.y, radius, damage });

}

export function bomberExplodeAI(ctx: RoomDO, bomber: AIZombie, now: number) {
  const radius = ctx.cfg.zombies.bomber.explosionRadius;
  const damage = ctx.cfg.zombies.bomber.explosionDamage;
  
  // Damage streamer if in range
  const streamer = [...ctx.players.values()].find(p => p.role === 'streamer');
  if (streamer) {
    const dist = Math.hypot(bomber.pos.x - streamer.pos.x, bomber.pos.y - streamer.pos.y);
    if (dist <= radius) {
      const dmg = Math.round(damage * (1 - dist / radius));
      streamer.hp = Math.max(0, (streamer.hp ?? ctx.cfg.streamer.maxHp) - dmg);
      ctx.trackDamageTaken(streamer, dmg);
    }
  }
  
  // Remove the AI bomber
  const idx = ctx.aiZombies.indexOf(bomber);
  if (idx >= 0) ctx.aiZombies.splice(idx, 1);
  
  // Create explosion effect
  ctx.broadcast('explosion', { x: bomber.pos.x, y: bomber.pos.y, radius, damage });

}
</file>

<file path="src/room/utils/names.ts">
import type { RoomDO } from '../index';

export function sanitizeName(ctx: RoomDO, n: string) {
  if (!n) return "";
  const ok = n.replace(/[^a-zA-Z0-9 _-]/g, "").slice(0, 20);
  return ok.trim();

}

export function randomName(ctx: RoomDO) {
  const list = (ctx.env.TARKOV_NAMES || "").split(",").map(s => s.trim()).filter(Boolean);
  return list[Math.floor(Math.random() * list.length)] || "FactoryGhost";

}
</file>

<file path="wrangler.toml">
name = "arena-shooter"
main = "src/worker.ts"
compatibility_date = "2024-10-22"

[[durable_objects.bindings]]
name = "ROOMS"
class_name = "RoomDO"

[vars]
TARKOV_NAMES = "KibaRogue,WoodsScav,ShorelineRat,FactoryGhost,LabsRunner,InterchangeChad,DormsGoblin,ReserveMole,FleaFlipper,TetrizHoarder,LedXHunter,SlickSeeker,RSASSEnjoyer,M995Enjoyer,GrenadierGoon,SanitarStan,KillaChaser,TagillaTapper,GluharGuy,ShturmanScout,KnightWatcher,RogueRaider,USECFriend,BEARBuddy,JaegerPal,FenceFella,TherapistAlly,RagmanRigger,SkierSlinger,PraporPatron,MechanicMain,PeacekeeperPro,LabsRat,MarkedRoomMole,StashGremlin,MoonshineMax,ScavJunkie,OmComEnjoyer,SJ6Sprinter,AltynAddict,ThermalAndy,GreenBatteryGuy,DormsKeyKing,GPUGoblin,AmmoArbiter,WaffleFilter"

[assets]
directory = "public"

[[migrations]]
tag = "v1"
new_sqlite_classes = ["RoomDO"]
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Cloudflare Workers
.wrangler/
worker/
dist/

# Environment variables
.env
.env.local
.env.production
.env.staging

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# Build outputs
build/
dist/
out/

# Temporary folders
tmp/
temp/
old-working/

# Cache
.cache/
.parcel-cache/

# Lock files (keep package-lock.json but ignore others)
yarn.lock
pnpm-lock.yaml
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
Source lives in `src/`: `worker.ts` handles `/create` and WebSocket upgrades, while `room.ts` runs the Durable Object loop and state. Static client assets sit under `public/` (`streamer.html`, `join.html`, `common.js`, `styles.css`). `wrangler.toml` wires bindings, Durable Object migrations, and static asset mounting. Keep any experimental scripts inside `old-working/` if you need scratch space.

## Build, Test, and Development Commands
Use `npx wrangler dev` to boot the Worker, Durable Objects, and static files at `http://127.0.0.1:8787`. Deploy with `npx wrangler deploy` once changes are validated. Run `npm install` before first use to hydrate `node_modules/`. If you prefer a global binary, `npm i -D wrangler` adds `wrangler dev` and `wrangler deploy` to your PATH.

## Coding Style & Naming Conventions
TypeScript modules use 2-space indentation, `camelCase` for variables/functions, and `PascalCase` for classes such as `RoomDO`. Keep imports relative (e.g., `./room`). Client files remain vanilla JS/HTML/CSS with kebab-case filenames. Avoid side effects during module load; initialize state inside handlers, constructors, or the game loop. Comment sparingly to clarify non-obvious logic.

## Testing Guidelines
No automated harness ships today. Validate via `npx wrangler dev`: create a room at `/streamer.html`, then join from `/join.html?room=XXXXXX` in a separate tab. If you introduce automated tests, place them under `src/__tests__/`, keep them fast, and prefer `vitest` or similarly lightweight runners.

## Commit & Pull Request Guidelines
Write commits with short imperative subjects scoped to the module (e.g., `room: cap zombies at 100`). Each PR should describe the change, outline manual validation steps, attach screenshots or GIFs for UI tweaks, and link relevant issues. Call out any updates to `wrangler.toml` or Durable Object bindings explicitly.

## Security & Configuration Tips
Do not commit secrets; configure them with `wrangler secret put NAME`. The Worker must expose only `/create` and `/ws/*`; serve `public/` through the configured assets route or Pages. Validate all room inputs in `room.ts` and keep tick rates conservative to protect CPU budgets.

## Architecture Overview
The Worker routes HTTP traffic and performs WebSocket upgrades, delegating room state to the Durable Object. Each room instance owns authoritative game state, broadcasting updates ~20 times per second. Clients subscribe via `/ws/:room` and render controls locally while the server adjudicates moves.
</file>

<file path="src/upgrades.ts">
import { ModDef, ModHooks, ModId, Rarity, StatBlock } from "./types";

// XP pacing
export const XP_PER_KILL = 1;
export const XP_THRESHOLDS = (lvl:number)=> 3 + Math.floor(lvl*1.8); // small, fast roguelite loops

// Base stats and aggregation
export function baseStats(): StatBlock {
  return {
    damageMul: 1, fireRateMul: 1, projectileSpeedMul: 1,
    bulletSizeMul: 1, spreadMul: 1, knockbackMul: 1,
    critChance: 0, critMul: 1.5, pierce: 0, bounce: 0, ricochet: 0, split: 0, chain: 0,
    burnChance: 0, burnDps: 0, burnMs: 0,
    slowChance: 0, slowMul: 1, slowMs: 0,
    bleedChance: 0, bleedDps: 0, bleedMs: 0,
    reloadOnKillPct: 0, lifestealPct: 0, ammoEfficiencyMul: 1, magnetBonus: 0, dashReloadPct: 0,
    // New stats for advanced upgrades
    movementSpeedMul: 1, dashDistanceMul: 1, ghostWalkMs: 0, berserkerStacks: 0,
    vampireAuraRange: 0, timeDilationMs: 0, bulletTimeMs: 0, explosiveDeathDamage: 0, shieldRegenRate: 0
  };
}

export function statsFor(p: any): { s: StatBlock } {
  const s = baseStats();
  const mods: Partial<Record<ModId, number>> = p?.mods || {};
  for (const [id, stacks] of Object.entries(mods) as [ModId, number][]) {
    const def = MOD_INDEX[id];
    if (def?.apply) def.apply(s, stacks);
  }
  return { s };
}

export function statusFrom(s: StatBlock) {
  const st: any = {};
  if (s.burnMs && s.burnDps && s.burnChance) { st.burnMs = s.burnMs; st.burnDps = s.burnDps; st.burnChance = s.burnChance; }
  if (s.slowMs && s.slowMul && s.slowChance) { st.slowMs = s.slowMs; st.slowMul = s.slowMul; st.slowChance = s.slowChance; }
  if (s.bleedMs && s.bleedDps && s.bleedChance) { st.bleedMs = s.bleedMs; st.bleedDps = s.bleedDps; st.bleedChance = s.bleedChance; }
  return Object.keys(st).length ? st : undefined;
}

// Upgrade catalog
export const MODS: ModDef[] = [
  { id:'damage_up', name:'+15% Damage', rarity:'common', desc:'All weapons deal 15% more damage.',
    apply:(s,k)=>{ s.damageMul *= Math.pow(1.15, k); } },
  { id:'firerate_up', name:'+20% Fire Rate', rarity:'common', desc:'Shoot faster.',
    apply:(s,k)=>{ s.fireRateMul *= Math.pow(1.2, k); } },
  { id:'bullet_size', name:'Bigger Bullets', rarity:'uncommon', desc:'+20% bullet size per stack.',
    apply:(s,k)=>{ s.bulletSizeMul *= Math.pow(1.2, k); } },
  { id:'spread_down', name:'Tighter Spread', rarity:'uncommon', desc:'-15% spread.',
    apply:(s,k)=>{ s.spreadMul *= Math.pow(0.85, k); } },
  { id:'pierce', name:'Piercing', rarity:'rare', desc:'+1 pierce per stack.',
    apply:(s,k)=>{ s.pierce += k; } },
  { id:'bounce', name:'Bouncy Bullets', rarity:'rare', desc:'+1 wall bounce.',
    apply:(s,k)=>{ s.bounce += k; } },
  { id:'crit_chance', name:'Criticals', rarity:'rare', desc:'+10% crit chance (+50% crit dmg).',
    apply:(s,k)=>{ s.critChance += 0.10*k; s.critMul = Math.max(s.critMul, 1.5); } },
  { id:'status_burn', name:'Incendiary', rarity:'rare', desc:'Bullets have 15% to ignite (12 DPS for 3s).',
    apply:(s,k)=>{ s.burnChance += 0.15*k; s.burnDps = Math.max(s.burnDps, 12); s.burnMs = Math.max(s.burnMs, 3000); } },
  { id:'status_slow', name:'Cryo Rounds', rarity:'uncommon', desc:'15% chance to slow (40% for 2s).',
    apply:(s,k)=>{ s.slowChance += 0.15*k; s.slowMul = Math.min(s.slowMul, 0.6); s.slowMs = Math.max(s.slowMs, 2000); } },
  { id:'lifesteal', name:'Lifesteal', rarity:'epic', desc:'Heal 2% of damage dealt.',
    apply:(s,k)=>{ s.lifestealPct += 0.02*k; } },
  { id:'reload_on_kill', name:'Adrenaline', rarity:'epic', desc:'Refund 10% ammo on kill.',
    apply:(s,k)=>{ s.reloadOnKillPct += 0.10*k; } },
  { id:'on_hit_explode', name:'Micro-grenades', rarity:'epic', desc:'Small explosion on hit.',
    hooks:{ onHit: ({room,bullet}) => { (room as any).spawnSmallExplosion?.(bullet); } } },
  { id:'shotgun_extra_pellet', name:'+Pellets', rarity:'uncommon', desc:'+1 shotgun pellet.',
    hooks:{ onShoot: ({bullets}) => { /* can be implemented to add an extra pellet where appropriate */ } } },
  { id:'smg_stability', name:'SMG Stability', rarity:'common', desc:'SMG spread −20%.',
    apply:(s,k)=>{ s.spreadMul *= Math.pow(0.8, k); } },
  { id:'pistol_precision', name:'Pistol Precision', rarity:'common', desc:'Pistol crit chance +15%.',
    apply:(s,k)=>{ s.critChance += 0.15*k; } },
  { id:'dash_reload', name:'Combat Slide', rarity:'rare', desc:'Dashing reloads 20% ammo.',
    apply:(s,k)=>{ s.dashReloadPct += 0.2*k; } },
  { id:'ammo_efficiency', name:'Ammo Saver', rarity:'uncommon', desc:'Shots cost 10% less ammo.',
    apply:(s,k)=>{ s.ammoEfficiencyMul *= Math.pow(0.9, k); } },
  { id:'magnet_radius', name:'Loot Vacuum', rarity:'common', desc:'+40px pickup radius UI hint.',
    apply:(s,k)=>{ s.magnetBonus += 40*k; } },
  
  // New fun upgrades
  { id:'movement_speed', name:'Swift Feet', rarity:'common', desc:'+25% movement speed.',
    apply:(s,k)=>{ s.movementSpeedMul *= Math.pow(1.25, k); } },
  { id:'dash_distance', name:'Long Dash', rarity:'uncommon', desc:'+50% dash distance.',
    apply:(s,k)=>{ s.dashDistanceMul *= Math.pow(1.5, k); } },
  { id:'double_jump', name:'Air Walker', rarity:'rare', desc:'Dash resets on kill (simulates double jump).',
    hooks:{ onKill: ({room,killerId}) => { const p = (room as any).players?.get(killerId); if (p) p.lastDashAt = 0; } } },
  { id:'ghost_walk', name:'Phase Step', rarity:'epic', desc:'Brief invulnerability after dash (0.5s).',
    apply:(s,k)=>{ s.ghostWalkMs += 500*k; } },
  { id:'berserker', name:'Berserker Rage', rarity:'rare', desc:'+10% damage per recent kill (max 5 stacks).',
    apply:(s,k)=>{ s.berserkerStacks += 5*k; } },
  { id:'vampire_aura', name:'Blood Aura', rarity:'epic', desc:'Heal from nearby zombie deaths (+50px range).',
    apply:(s,k)=>{ s.vampireAuraRange += 50*k; } },
  { id:'time_dilation', name:'Bullet Time', rarity:'legendary', desc:'Slow time on low health (2s duration).',
    apply:(s,k)=>{ s.timeDilationMs += 2000*k; } },
  { id:'bullet_time', name:'Matrix Mode', rarity:'legendary', desc:'Slow projectiles when dashing (1s).',
    apply:(s,k)=>{ s.bulletTimeMs += 1000*k; } },
  { id:'explosive_death', name:'Martyrdom', rarity:'rare', desc:'Explode on death dealing 50 damage.',
    apply:(s,k)=>{ s.explosiveDeathDamage += 50*k; } },
  { id:'shield_regen', name:'Auto-Repair', rarity:'uncommon', desc:'Regenerate 1 HP every 3 seconds.',
    apply:(s,k)=>{ s.shieldRegenRate += k; } },
];

export const MOD_INDEX: Record<ModId, ModDef> = Object.fromEntries(MODS.map(m=>[m.id,m])) as any;

// Rolling choices for offers
export function rollChoices(current: Partial<Record<ModId,number>>, rng: () => number): ModDef[] {
  const weights: Record<Rarity, number> = { common: 70, uncommon: 22, rare: 6, epic: 1.8, legendary: 0.2 };
  const pool = MODS.map(m => ({ m, w: weights[m.rarity] }));
  const picks: ModDef[] = [];
  for (let i=0; i<3; i++){
    let total = pool.reduce((s,p)=> s+p.w, 0);
    let r = rng()*total;
    let chosen: ModDef | null = null;
    for (const p of pool) { r -= p.w; if (r<=0){ chosen = p.m; break; } }
    if (!chosen) chosen = pool[pool.length-1].m;
    if (picks.some(x=>x.id===chosen!.id)) { i--; continue; }
    picks.push(chosen);
  }
  return picks;
}
</file>

<file path="src/worker.ts">
import { RoomDO } from "./room";

export interface Env {
  ROOMS: DurableObjectNamespace;
  TARKOV_NAMES: string;
}

declare global {
  interface DurableObjectNamespace {
    idFromName(name: string): DurableObjectId;
    get(id: DurableObjectId): DurableObjectStub;
  }
  
  interface DurableObjectId {}
  
  interface DurableObjectStub {
    fetch(request: Request): Promise<Response>;
  }
}

export default {
  async fetch(req: Request, env: Env) {
    const url = new URL(req.url);

    // Return current default config (for UI/editor)
    if (url.pathname === "/config" && req.method === "GET") {
      // Lazy import to avoid side-effects on module load
      const { CONFIG } = await import("./config");
      return new Response(JSON.stringify(CONFIG), { headers: { "content-type": "application/json" } });
    }

    // WebSocket upgrade routed to the Room Durable Object
    if (url.pathname.startsWith("/ws/") && req.headers.get("Upgrade") === "websocket") {
      const roomId = url.pathname.split("/").pop()!;
      const id = env.ROOMS.idFromName(roomId);
      const stub = env.ROOMS.get(id);
      return stub.fetch(req);
    }

    // Mint a new room id with regional hint
    if (url.pathname === "/create" && req.method === "POST") {
      let overrides: any = undefined;
      try {
        const ct = req.headers.get('content-type') || '';
        if (ct.includes('application/json')) {
          const body = await req.json().catch(() => ({}));
          if (body && typeof body === 'object') overrides = body.overrides || body.config || undefined;
        }
      } catch {}

      const region = getRegionFromRequest(req);
      const roomId = `${region}-${crypto.randomUUID().slice(0, 6)}`;

      // If overrides provided, initialize the DO instance with them before returning
      if (overrides && typeof overrides === 'object') {
        try {
          const id = env.ROOMS.idFromName(roomId);
          const stub = env.ROOMS.get(id);
          await stub.fetch(new Request(`https://do/${roomId}/setup`, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ overrides })
          }));
        } catch {}
      }
      return new Response(JSON.stringify({ roomId }), { headers: { "content-type": "application/json" } });
    }

    // Simple health
    if (url.pathname === "/health") return new Response("ok");

    return new Response("Not found", { status: 404 });
  },
};

// Required for binding discovery in some setups
// Get region hint from CF headers or fallback
function getRegionFromRequest(req: Request): string {
  // Cloudflare provides colo (data center) in CF-Ray header
  const cfRay = req.headers.get('CF-Ray');
  if (cfRay) {
    const colo = cfRay.split('-')[1];
    if (colo) {
      // Map some common colos to regions
      const regionMap: Record<string, string> = {
        'LAX': 'us-west', 'SFO': 'us-west', 'SEA': 'us-west',
        'DFW': 'us-central', 'ORD': 'us-central', 'ATL': 'us-central',
        'IAD': 'us-east', 'EWR': 'us-east', 'MIA': 'us-east',
        'LHR': 'eu-west', 'CDG': 'eu-west', 'AMS': 'eu-west',
        'FRA': 'eu-central', 'WAW': 'eu-central',
        'NRT': 'asia-east', 'ICN': 'asia-east', 'HKG': 'asia-east',
        'SIN': 'asia-south', 'BOM': 'asia-south'
      };
      return regionMap[colo] || 'global';
    }
  }
  
  // Fallback to CF-IPCountry header
  const country = req.headers.get('CF-IPCountry');
  if (country) {
    const countryToRegion: Record<string, string> = {
      'US': 'us-central', 'CA': 'us-central',
      'GB': 'eu-west', 'DE': 'eu-central', 'FR': 'eu-west', 'NL': 'eu-west',
      'JP': 'asia-east', 'KR': 'asia-east', 'CN': 'asia-east',
      'SG': 'asia-south', 'IN': 'asia-south', 'AU': 'asia-south'
    };
    return countryToRegion[country] || 'global';
  }
  
  return 'global';
}

export { RoomDO };
</file>

<file path="src/types.ts">
// src/types.ts
export type ModId =
  | 'damage_up' | 'firerate_up' | 'bullet_size'
  | 'pierce' | 'bounce' | 'ricochet' | 'shot_split'
  | 'spread_down' | 'reload_on_kill' | 'lifesteal'
  | 'knockback_up' | 'crit_chance' | 'status_burn'
  | 'status_slow' | 'status_bleed'
  | 'shotgun_extra_pellet' | 'smg_stability' | 'pistol_precision'
  | 'dash_reload' | 'on_hit_explode' | 'chain_lightning'
  | 'magnet_radius' | 'on_extract_refund' | 'ammo_efficiency'
  | 'movement_speed' | 'dash_distance' | 'double_jump' | 'ghost_walk'
  | 'berserker' | 'vampire_aura' | 'time_dilation' | 'bullet_time'
  | 'explosive_death' | 'shield_regen';

export type Rarity = 'common'|'uncommon'|'rare'|'epic'|'legendary';

export interface ModDef {
  id: ModId;
  name: string;
  desc: string;
  rarity: Rarity;
  maxStacks?: number;        // default infinite
  // Pure stat changes:
  apply?: (s: StatBlock, stacks: number) => void;
  // Event hooks (optional):
  hooks?: Partial<ModHooks>;
}

export interface StatBlock {
  damageMul: number;         // x
  fireRateMul: number;       // x
  projectileSpeedMul: number;// x
  bulletSizeMul: number;     // x (used for collision radius margin)
  spreadMul: number;         // x
  knockbackMul: number;      // x
  critChance: number;        // 0..1
  critMul: number;           // x
  pierce: number;            // hits before despawn
  bounce: number;            // wall bounces
  ricochet: number;          // number of ricochets to nearest enemy
  split: number;             // extra bullets per shot (per split event)
  chain: number;             // chain count for lightning
  burnChance: number; burnDps: number; burnMs: number;
  slowChance: number; slowMul: number; slowMs: number;
  bleedChance: number; bleedDps: number; bleedMs: number;
  reloadOnKillPct: number;
  lifestealPct: number;
  ammoEfficiencyMul: number; // <1 means cheaper per shot
  magnetBonus: number;       // +px to pickup range (client hint only)
  dashReloadPct: number;
  // New stats for advanced upgrades
  movementSpeedMul: number;  // movement speed multiplier
  dashDistanceMul: number;   // dash distance multiplier
  ghostWalkMs: number;       // ghost walk duration
  berserkerStacks: number;   // berserker damage stacks
  vampireAuraRange: number;  // vampire aura range
  timeDilationMs: number;    // time dilation duration
  bulletTimeMs: number;      // bullet time duration
  explosiveDeathDamage: number; // explosive death damage
  shieldRegenRate: number;   // shield regeneration rate
}

export interface ModHooks {
  // Invoked when server is about to spawn bullets for a shot:
  onShoot?: (ctx: ShotContext) => void;
  // Invoked when a bullet hits something
  onHit?: (ctx: HitContext) => void;
  // Invoked when a zombie dies
  onKill?: (ctx: KillContext) => void;
}

export interface ShotContext {
  room: any;        // avoid circular import with RoomDO
  playerId: string;
  // mutable – push extra bullets, tweak per-shot spread, etc.
  bullets: BulletSpawnSpec[];
  stats: StatBlock;    // computed stats snapshot
}

export interface HitContext {
  room: any; // avoid circular import
  bullet: ActiveBullet;
  targetId?: string;   // zombie id
  killed?: boolean;
  stats: StatBlock;
}

export interface KillContext {
  room: any; // avoid circular import
  killerId: string;
  victimId: string;
  stats: StatBlock;
}

// Compact info we bake into a bullet at spawn (no functions):
export interface BulletSpawnSpec {
  pos: {x:number;y:number};
  vel: {x:number;y:number};
  ttl: number;
  ownerId: string;
  meta: {
    damage: number;
    radius: number;         // collision radius for this bullet
    pierce: number;
    bounce: number;
    ricochet: number;
    chain: number;
    status?: { 
      burnMs?:number; burnDps?:number; burnChance?:number;
      slowMs?:number; slowMul?:number; slowChance?:number;
      bleedMs?:number; bleedDps?:number; bleedChance?:number;
    };
    critChance: number;
    critMul: number;
  };
}
export type ActiveBullet = BulletSpawnSpec & { id: string };

export type ZombieClass = "runner" | "brute" | "spitter" | "stalker" | "bomber";

export type BossType = "necromancer" | "bruteKing" | "shadowLord";

export interface Boss {
  id: string;
  type: BossType;
  pos: { x: number; y: number };
  vel: { x: number; y: number };
  hp: number;
  maxHp: number;
  radius: number;
  damage: number;
  speed: number;
  state: "spawning" | "idle" | "chasing" | "attacking" | "ability" | "dying";
  targetId?: string;
  lastSeen: number;
  spawnTime: number;
  
  // Ability cooldowns
  lastSummon?: number;
  lastTeleport?: number;
  lastPoisonField?: number;
  lastCharge?: number;
  lastGroundSlam?: number;
  lastPhase?: number;
  lastShadowClone?: number;
  lastLifeDrain?: number;
  
  // State tracking
  enraged?: boolean;
  phased?: boolean;
  phaseUntil?: number;
  chargeUntil?: number;
  chargeDirX?: number;
  chargeDirY?: number;
  stunUntil?: number;
  
  // Minions and clones
  minionIds?: string[];
  cloneIds?: string[];
  
  // Status effects
  slowUntil?: number;
  slowMul?: number;
  burns?: Array<{ until: number; dps: number; nextTick: number; ownerId: string }>;
  bleeds?: Array<{ until: number; dps: number; nextTick: number; ownerId: string }>;
  
  // Damage cooldown
  lastDamage?: number;
  
  // Wandering AI
  wanderTarget?: { x: number; y: number };
}

export interface BossMinion {
  id: string;
  bossId: string;
  pos: { x: number; y: number };
  vel: { x: number; y: number };
  hp: number;
  maxHp: number;
  state: "idle" | "chasing" | "attacking";
  targetId?: string;
  lastSeen: number;
  spawnTime: number;
  expiresAt?: number;
}

export interface PoisonField {
  id: string;
  pos: { x: number; y: number };
  radius: number;
  dps: number;
  createdAt: number;
  expiresAt: number;
  ownerId: string;
}

export interface RaidStats {
  enemiesKilled: number;
  bossesKilled: number;
  bulletsFired: number;
  bulletsHit: number;
  coinsCollected: number;
  pickupsTaken: number;
  damageDealt: number;
  damageTaken: number;
  totalXPGained: number;
  startTime: number;
  enemyBreakdown: {
    basic: number;
    runner: number;
    brute: number;
    spitter: number;
    stalker: number;
    bomber: number;
  };
  bossesDefeated: string[]; // Array of boss names/types killed
}

export interface Player {
  id: string;
  name: string;
  x: number;
  y: number;
  hp?: number;
  maxHp?: number;
  score: number;
  banked?: number;
  role: "streamer" | "zombie";
  alive: boolean;
  weapon?: string;
  pistolAmmo?: number;
  smgAmmo?: number;
  shotgunAmmo?: number;
  weaponed?: boolean;
  boosted?: boolean;
  level?: number;
  xp?: number;
  xpForNext?: number;
  mods?: Partial<Record<ModId, number>>;
  zClass?: string;
  emote?: string;
  emoteUntil?: number;
  meleeAt?: number;
  meleeDirX?: number;
  meleeDirY?: number;
  dashing?: boolean;
  dashReadyAt?: number;
  lastDashAt?: number;
  raidStats?: RaidStats;
}
</file>

<file path="public/index.html">
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Streamer vs. Chat — Zombies</title>
  <link rel="stylesheet" href="/styles.css" />
  <style>
    .hero {
      position: relative;
      min-height: 100dvh;
      display: grid; place-items: center;
      overflow: hidden;
    }
    .hero-inner { text-align: center; padding: 100px 20px 60px; }
    .title {
      font-weight: 800; font-size: clamp(28px, 6vw, 56px);
      letter-spacing: .5px;
      background: linear-gradient(90deg, #fff, #a5b4fc 35%, #99f6e4 70%);
      -webkit-background-clip: text; background-clip: text; color: transparent;
      text-shadow: 0 10px 40px rgba(0,0,0,.45);
    }
    .subtitle { color: var(--muted); margin-top: 10px; max-width: 900px; margin-inline: auto; }
    .cta { margin-top: 26px; display: inline-flex; gap: 10px; flex-wrap: wrap; }
    .cta a { text-decoration: none; }
    .btn-xl { padding: 14px 18px; font-size: 16px; border-radius: 14px; border: 1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.08)); box-shadow: 0 12px 30px rgba(0,0,0,.35); }
    .btn-xl.primary { color: var(--teal); border-color: color-mix(in oklab, var(--teal) 35%, transparent); }
    .btn-xl.secondary { color: #c3c7d1; }

    /* Floating blobs */
    .blob {
      position: absolute; width: 60vmax; height: 60vmax; border-radius: 50%; filter: blur(60px); opacity: .22; pointer-events: none;
      background: radial-gradient(circle at 40% 40%, rgba(45,212,191,.6), transparent 55%);
      animation: drift 24s ease-in-out infinite alternate;
    }
    .blob.b2 { background: radial-gradient(circle at 60% 60%, rgba(244,114,182,.6), transparent 55%); animation-duration: 28s; animation-delay: -4s; }
    .blob.b3 { background: radial-gradient(circle at 50% 50%, rgba(96,165,250,.6), transparent 55%); animation-duration: 30s; animation-delay: -8s; }
    @keyframes drift { from { transform: translate(-10%, -10%) scale(1); } to { transform: translate(10%, 10%) scale(1.08); } }

    /* Cards row with subtle entrance */
    .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; padding: 24px; max-width: 1100px; margin: 0 auto 40px; }
    .card.hero-card { opacity: 0; transform: translateY(10px); animation: rise .6s ease forwards; }
    .card.hero-card:nth-child(2) { animation-delay: .08s; }
    .card.hero-card:nth-child(3) { animation-delay: .16s; }
    @keyframes rise { to { opacity: 1; transform: translateY(0); } }
    /* Modal */
    .modal { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,.55); z-index: 50; }
    .modal.hidden { display: none; }
    .modal .sheet { width: min(720px, 92vw); background: linear-gradient(180deg, var(--panel), var(--panel-2)); border: 1px solid var(--border); border-radius: 16px; padding: 16px; box-shadow: 0 20px 60px rgba(0,0,0,.5); }
    .modal .sheet .hd { display:flex; align-items:center; justify-content:space-between; font-weight:600; color: var(--text); margin-bottom: 8px; }
    .modal .sheet .bd { color: var(--muted); }
    .modal .sheet .ft { display:flex; gap:8px; justify-content:flex-end; margin-top: 12px; }
    /* Down chevron at bottom of hero */
    .down-cta {
      position: absolute; left: 50%; bottom: 18px; transform: translateX(-50%);
      width: 44px; height: 44px; border-radius: 999px;
      display: grid; place-items: center;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.12));
      color: var(--text);
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
      cursor: pointer; transition: transform .15s ease, box-shadow .2s ease, border-color .2s ease;
      animation: bob 2.4s ease-in-out infinite;
    }
    .down-cta:hover { border-color: rgba(255,255,255,.2); box-shadow: 0 12px 34px rgba(0,0,0,.45), 0 0 0 4px rgba(158,241,209,.08); }
    .down-cta:active { transform: translateX(-50%) translateY(1px); }
    .down-cta svg { width: 20px; height: 20px; opacity: .9; }
    @keyframes bob { 0%,100%{ transform: translateX(-50%) translateY(0); } 50%{ transform: translateX(-50%) translateY(4px); } }
  </style>
  <script type="module">
    // Tiny confetti bursts on load that loop at random, firing from random sides/angles
    window.addEventListener('load', () => {
      const container = document.createElement('div');
      container.style.position = 'fixed';
      container.style.inset = '0';
      container.style.pointerEvents = 'none';
      container.style.overflow = 'hidden';
      document.body.appendChild(container);

      const colors = ['#60a5fa','#f472b6','#2dd4bf','#ffd54f'];
      const parts = [];

      function spawnBurst(count=50){
        // Random origin: top, bottom, left, right, or center
        const side = ['top','bottom','left','right','center'][Math.floor(Math.random()*5)];
        const w = window.innerWidth; const h = window.innerHeight;
        let ox = w/2, oy = h/2;
        if (side==='top')    { ox = Math.random()*w; oy = -20; }
        if (side==='bottom') { ox = Math.random()*w; oy = h+20; }
        if (side==='left')   { ox = -20; oy = Math.random()*h; }
        if (side==='right')  { ox = w+20; oy = Math.random()*h; }

        for (let i=0;i<count;i++){
          const el = document.createElement('div');
          el.style.position = 'absolute';
          el.style.width = '6px'; el.style.height = '10px'; el.style.borderRadius = '2px';
          el.style.left = ox + 'px'; el.style.top = oy + 'px';
          el.style.background = colors[i % colors.length];
          el.style.opacity = '.95';
          el.style.transform = `rotate(${Math.random()*360}deg)`;
          container.appendChild(el);
          // Random direction and speed
          const ang = Math.random()*Math.PI*2; // 0..2PI any direction
          const spd = 2 + Math.random()*4;     // pixels/frame (scaled later)
          const vx = Math.cos(ang)*spd;
          const vy = Math.sin(ang)*spd;
          const vr = (Math.random()-.5)*6;     // deg/frame
          parts.push({ el, x: ox, y: oy, vx, vy, r: Math.random()*360, vr, life: 120 + Math.random()*80 });
        }
      }

      let last = performance.now();
      function step(now){
        const dt = Math.min(32, now - last) / 16.6; // normalize to ~60fps steps
        last = now;
        for (let i = parts.length-1; i>=0; i--) {
          const p = parts[i];
          // simple drag and gravity-ish drift
          p.vx *= 0.995; p.vy = p.vy*0.995 + 0.06;
          p.x += p.vx * dt; p.y += p.vy * dt; p.r += p.vr * dt; p.life -= dt;
          p.el.style.left = p.x + 'px'; p.el.style.top = p.y + 'px'; p.el.style.transform = `rotate(${p.r}deg)`;
          // Cull when off-screen or out of life
          if (p.life <= 0 || p.x < -60 || p.x > window.innerWidth+60 || p.y < -80 || p.y > window.innerHeight+80) {
            p.el.remove(); parts.splice(i,1);
          }
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);

      // Kick off initial burst and then loop random bursts
      spawnBurst(60);
      function loop(){
        spawnBurst(40 + Math.floor(Math.random()*40));
        // Next burst between 3–8 seconds
        setTimeout(loop, 3000 + Math.random()*5000);
      }
      setTimeout(loop, 1800 + Math.random()*1200);
    });

    // Role selection modal
    const showRoleModal = async (role) => {
      const modal = document.getElementById('roleModal');
      const title = document.getElementById('roleTitle');
      const body = document.getElementById('roleBody');
      const play = document.getElementById('rolePlay');
      const cancel = document.getElementById('roleCancel');
      const isStreamer = role === 'streamer';
      title.textContent = isStreamer ? 'Play as Streamer' : 'Join as Zombie';
      // Streamer body with inline advanced config editor
      const streamerBody = `
        <div style="line-height:1.8">
          <div><strong>Move:</strong> WASD · <strong>Aim:</strong> Mouse · <strong>Shoot:</strong> Left‑click</div>
          <div><strong>Melee (bat):</strong> Right‑click or Q/E</div>
          <div><strong>Weapons:</strong> 1=Pistol · 2=SMG · 3=Shotgun</div>
          <div><strong>Dash:</strong> Space (1s CD) — brief burst</div>
          <div><strong>Scoring:</strong> Treasure adds <em>Score</em>. Dying clears current score.</div>
        </div>
        <details style="margin-top:10px">
          <summary style="cursor:pointer">Advanced: Edit Room Config (JSON)</summary>
          <div class="row" style="margin-top:8px">
            <textarea id="configEditor" class="mono" style="width:100%; height:220px"></textarea>
          </div>
          <div class="tip">Edit only what you need. Invalid JSON will be ignored.</div>
        </details>`;
      const zombieBody = `
        <div style="line-height:1.8">
          <div><strong>Move:</strong> WASD · <strong>Aim:</strong> Mouse · <strong>Ability:</strong> Left‑click</div>
          <div style="margin-top:6px"><strong>Classes:</strong></div>
          <div>• <span style=\"color:#64b5f6\">Runner</span>: Sprint burst on click (1.6× speed, 0.6× HP)</div>
          <div>• <span style=\"color:#ffa726\">Brute</span>: Charge toward cursor on click (0.7× speed, 2× HP, strong knockback)</div>
          <div>• <span style=\"color:#ba68c8\">Spitter</span>: Spit slow glob on click (damage + slow); also auto‑spits in range</div>
          <div style=\"margin-top:6px\">Touch the streamer to deal damage; coordinate to pin and overwhelm.</div>
        </div>`;
      body.innerHTML = isStreamer ? streamerBody : zombieBody;
      // Preload default config JSON if streamer
      if (isStreamer) {
        try {
          const res = await fetch('/config');
          if (res.ok) {
            const cfg = await res.json();
            const ed = document.getElementById('configEditor');
            if (ed) ed.value = JSON.stringify(cfg, null, 2);
          }
        } catch {}
      }
      play.onclick = async () => {
        if (isStreamer) {
          // Create room with optional overrides
          let overrides = undefined;
          const ed = document.getElementById('configEditor');
          if (ed && ed.value.trim()) {
            try { overrides = JSON.parse(ed.value); } catch { overrides = undefined; }
          }
          try {
            const res = await fetch('/create', { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify({ overrides }) });
            const data = await res.json();
            if (data && data.roomId) { window.location.href = `/streamer.html?room=${encodeURIComponent(data.roomId)}`; return; }
          } catch {}
          // Fallback
          window.location.href = '/streamer.html';
        } else {
          window.location.href = '/join.html';
        }
      };
      cancel.onclick = () => { modal.classList.add('hidden'); };
      modal.classList.remove('hidden');
    };

    document.addEventListener('click', (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      if (t.matches('#ctaStreamer')) { e.preventDefault(); showRoleModal('streamer'); }
      if (t.matches('#ctaZombie')) { e.preventDefault(); showRoleModal('zombie'); }
    });

    // Smooth scroll to How To Play
    const scrollBtn = document.getElementById('scrollDown');
    const howto = document.getElementById('howto');
    if (scrollBtn && howto) {
      scrollBtn.addEventListener('click', () => {
        try { howto.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
        catch { window.scrollTo({ top: howto.getBoundingClientRect().top + window.scrollY - 12, behavior: 'smooth' }); }
      });
    }
  </script>
</head>
<body>
  <div class="topbar">
    <div class="brand">Streamer vs. Chat</div>
    <div class="middle-controls">
      <span class="badge" id="status" data-state="disconnected">Welcome</span>
    </div>
    <div class="right-controls">
      <button class="primary" id="ctaStreamer">Streamer</button>
      <button id="ctaZombie">Join</button>
    </div>
  </div>
  <div class="hero">
    <div class="blob b1"></div>
    <div class="blob b2"></div>
    <div class="blob b3"></div>
    <div class="hero-inner">
      <div class="title">Streamer vs. Chat — Zombies</div>
      <div class="subtitle">A fast, top‑down arena: One streamer, many zombies. Loot treasure, survive the horde, and rack up a high score.</div>
      <div class="cta">
        <button class="btn-xl primary" id="ctaStreamer">Play as Streamer</button>
        <button class="btn-xl secondary" id="ctaZombie">Join as Zombie</button>
      </div>
    </div>
    <button id="scrollDown" class="down-cta" aria-label="Scroll to How To Play">
      <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    <div class="cards">
      <div class="card hero-card"><div class="card-title">20Hz Server</div><div class="tip">Authoritative sim with fair hits and clean rollback for inputs.</div></div>
      <div class="card hero-card"><div class="card-title">Relentless Pressure</div><div class="tip">Loot treasure to raise your score while dodging the swarm.</div></div>
      <div class="card hero-card"><div class="card-title">Chat vs. You</div><div class="tip">Hundreds of slow zombies, simple inputs, and satisfying chaos.</div></div>
    </div>
  </div>

  <div id="howto" class="cards" style="max-width:1100px; margin:0 auto 60px;">
    <div class="card hero-card">
      <div class="card-title">How To Play — Streamer</div>
      <div class="tip" style="line-height:1.7">
        <div><strong>Move:</strong> WASD · <strong>Aim:</strong> Mouse · <strong>Shoot:</strong> Left‑click</div>
        <div><strong>Melee (bat):</strong> Right‑click or Q/E · short arc</div>
        <div><strong>Weapons:</strong> 1=Pistol · 2=SMG · 3=Shotgun</div>
          <div><strong>Dash:</strong> Space (1s CD) · brief burst</div>
          <div><strong>Scoring:</strong> Treasure adds <em>Score</em>. Dying clears unbanked points.</div>
      </div>
    </div>
    <div class="card hero-card">
      <div class="card-title">How To Play — Zombie</div>
      <div class="tip" style="line-height:1.7">
        <div><strong>Move:</strong> WASD · <strong>Aim:</strong> Mouse</div>
        <div><strong>Ability (all classes):</strong> Left‑click</div>
        <div style="margin-top:6px"><strong>Classes:</strong></div>
        <div>• <span style="color:#64b5f6">Runner</span>: 1.6× speed, 0.6× HP. Left‑click = short sprint burst.</div>
        <div>• <span style="color:#ffa726">Brute</span>: 0.7× speed, 2× HP. Left‑click = charge toward cursor (strong knockback on hit).</div>
        <div>• <span style="color:#ba68c8">Spitter</span>: normal speed/HP. Left‑click = spit a slow purple glob (damage + slow). Also spits automatically in range.</div>
        <div style="margin-top:6px">Touching the streamer deals damage; coordinate to pin and overwhelm.</div>
      </div>
    </div>
  </div>

  <div class="cards" style="max-width:1100px; margin:0 auto 80px; grid-template-columns: 1fr;">
    <div class="card hero-card">
      <div class="card-title">Legend & Tips</div>
      <div class="tip" style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
        <div>
          <div><strong>Flow:</strong> Treasure increases score. Dying resets current score.</div>
          <div><strong>Minimap:</strong> Bottom‑right, zoomed to your position.</div>
        </div>
        <div>
          <div style="margin-bottom:4px"><strong>Zombie Class Rings:</strong></div>
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px"><span style="width:12px;height:12px;border-radius:999px;border:2px solid #64b5f6;display:inline-block"></span> Runner</div>
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px"><span style="width:12px;height:12px;border-radius:999px;border:3px solid #ffa726;display:inline-block"></span> Brute</div>
          <div style="display:flex; align-items:center; gap:8px"><span style="width:12px;height:12px;border-radius:999px;border:2px solid #ba68c8;display:inline-block"></span> Spitter</div>
        </div>
      </div>
    </div>
  </div>


  <!-- Role selection modal -->
  <div id="roleModal" class="modal hidden">
    <div class="sheet">
      <div class="hd"><span id="roleTitle">Play</span></div>
      <div class="bd" id="roleBody"></div>
      <div class="ft">
        <button id="roleCancel">Back</button>
        <button id="rolePlay" class="primary">Play</button>
      </div>
    </div>
  </div>
</body>
</html>
</file>

<file path="public/common.js">
export function connect(roomId) {
  let url;
  if (typeof window !== 'undefined' && window.WORKER_ORIGIN) {
    try {
      const u = new URL(`/ws/${roomId}`, window.WORKER_ORIGIN);
      u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
      url = u.href;
    } catch {
      // Fallback to same-origin if WORKER_ORIGIN is malformed
    }
  }
  if (!url) {
    const proto = location.protocol === "https:" ? "wss" : "ws";
    url = `${proto}://${location.host}/ws/${roomId}`;
  }
  return new WebSocket(url);
}

export function nameStorage() {
  return {
    get() { return localStorage.getItem("name") || ""; },
    set(n) { localStorage.setItem("name", n); }
  };
}

export function minimalCanvas(w, h) {
  const c = document.createElement("canvas");
  c.className = "arena";

  let stage = document.querySelector('.stage');
  if (!stage) { stage = document.createElement('div'); stage.className = 'stage'; document.body.appendChild(stage); }
  stage.appendChild(c);
  const ctx = c.getContext("2d");

  // DPI-aware internal resolution
  const resize = () => {
    // Force a reflow to ensure accurate measurements
    const parent = c.parentElement || document.body;
    parent.offsetHeight; // Force reflow
    
    // Get fresh parent dimensions
    const prect = parent.getBoundingClientRect();
    
    // Add padding to prevent overflow issues after fullscreen
    const padding = 20;
    const availableWidth = Math.max(100, prect.width - padding);
    const availableHeight = Math.max(100, prect.height - padding);
    
    // Fit canvas to available space while maintaining aspect ratio
    const targetAR = w / h;
    let cssW = availableWidth;
    let cssH = cssW / targetAR;
    if (cssH > availableHeight) {
      cssH = availableHeight;
      cssW = cssH * targetAR;
    }
    
    // Ensure minimum size
    cssW = Math.max(200, cssW);
    cssH = Math.max(200 / targetAR, cssH);
    
    c.style.width = cssW + 'px';
    c.style.height = cssH + 'px';

    // Force another reflow after setting canvas size
    c.offsetHeight;
    
    const rect = c.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const targetW = Math.max(1, Math.floor(rect.width * dpr));
    const targetH = Math.max(1, Math.floor(rect.height * dpr));
    if (c.width !== targetW || c.height !== targetH) {
      c.width = targetW; c.height = targetH;
    }
  };
  const roCanvas = new ResizeObserver(() => resize());
  const roParent = new ResizeObserver(() => resize());
  roCanvas.observe(c);
  roParent.observe(stage);
  window.addEventListener('orientationchange', resize);
  
  // Handle fullscreen changes with forced recalculation
  const handleFullscreenChange = () => {
    // Clear any cached dimensions and force recalculation
    c.style.width = '';
    c.style.height = '';
    
    // Multiple resize attempts with increasing delays
    setTimeout(() => {
      c.style.width = '';
      c.style.height = '';
      resize();
    }, 50);
    setTimeout(() => {
      c.style.width = '';
      c.style.height = '';
      resize();
    }, 150);
    setTimeout(() => {
      c.style.width = '';
      c.style.height = '';
      resize();
    }, 300);
    setTimeout(() => {
      c.style.width = '';
      c.style.height = '';
      resize();
    }, 500);
    
    // Force a window resize event to trigger all resize handlers
    setTimeout(() => {
      window.dispatchEvent(new Event('resize'));
    }, 100);
  };
  
  document.addEventListener('fullscreenchange', handleFullscreenChange);
  document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
  document.addEventListener('mozfullscreenchange', handleFullscreenChange);
  document.addEventListener('MSFullscreenChange', handleFullscreenChange);
  
  resize();

  // Capture keyboard focus so Space/Arrows don't trigger buttons/scroll
  c.tabIndex = 0;
  setTimeout(() => c.focus(), 0);
  c.addEventListener('pointerdown', () => c.focus());
  return { c, ctx };
}

export function inputController(opts={ mouse:true }) {
  const state = { up:false,down:false,left:false,right:false,shoot:false,melee:false,dash:false,aimX:0,aimY:0 };
  addEventListener("keydown", e => { if (e.repeat) return; if (e.key==="w"||e.key==="ArrowUp") state.up=true;
    if (e.key==="s"||e.key==="ArrowDown") state.down=true; if (e.key==="a"||e.key==="ArrowLeft") state.left=true; if (e.key==="d"||e.key==="ArrowRight") state.right=true; if (e.key==="q"||e.key==="e") state.melee=true; if (e.code==="Space") state.dash=true; });
  addEventListener("keyup", e => { if (e.key==="w"||e.key==="ArrowUp") state.up=false;
    if (e.key==="s"||e.key==="ArrowDown") state.down=false; if (e.key==="a"||e.key==="ArrowLeft") state.left=false; if (e.key==="d"||e.key==="ArrowRight") state.right=false; if (e.key==="q"||e.key==="e") state.melee=false; if (e.code==="Space") state.dash=false; });
  if (opts.mouse) {
    addEventListener("mousemove", e => { const rect = document.querySelector("canvas.arena").getBoundingClientRect(); state.aimX = e.clientX - rect.left; state.aimY = e.clientY - rect.top; });
    // Pointer/mouse shooting handling
    addEventListener("mousedown", (e) => { if (e.button===0) state.shoot = true; if (e.button===2) { state.melee = true; e.preventDefault(); } });
    addEventListener("mouseup", (e) => { if (e.button===0) state.shoot = false; if (e.button===2) { state.melee = false; e.preventDefault(); } });
    // prevent context menu on canvas for right-click melee
    document.addEventListener('contextmenu', (e) => {
      const c = document.querySelector('canvas.arena');
      if (c && c.contains(e.target)) e.preventDefault();
    });
    // Touch support (basic)
    addEventListener("touchstart", (e) => { const t=e.touches[0]; const rect = document.querySelector("canvas.arena").getBoundingClientRect(); state.aimX=t.clientX-rect.left; state.aimY=t.clientY-rect.top; state.shoot=true; }, { passive:true });
    addEventListener("touchend", () => { state.shoot=false; }, { passive:true });
  }
  const resetAll = () => { state.up=false; state.down=false; state.left=false; state.right=false; state.shoot=false; state.melee=false; state.dash=false; };
  addEventListener("blur", () => { resetAll(); });
  document.addEventListener("visibilitychange", () => { if (document.hidden) resetAll(); });
  return state;
}

// Prevent browser defaults (scrolling / button activation) for game keys
export function suppressPageHotkeys() {
  window.addEventListener('keydown', (e) => {
    const code = e.code;
    const isGameKey = code === 'Space' || code === 'ArrowUp' || code === 'ArrowDown' || code === 'ArrowLeft' || code === 'ArrowRight' || e.key === ' ';
    const tag = (document.activeElement && document.activeElement.tagName) || '';
    const typing = tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (document.activeElement && document.activeElement.getAttribute && document.activeElement.getAttribute('contenteditable') === 'true');
    if (isGameKey && !typing) {
      e.preventDefault();
    }
  }, { capture: true });
}

// Client-side prediction for movement
export function createPredictionSystem() {
  let predictedPos = { x: 0, y: 0 };
  let lastServerPos = { x: 0, y: 0 };
  let lastServerTime = 0;
  let inputHistory = [];
  
  return {
    // Predict movement locally
    predictMovement(input, dt) {
      const speed = 200; // pixels per second
      const dx = (input.right ? 1 : 0) - (input.left ? 1 : 0);
      const dy = (input.down ? 1 : 0) - (input.up ? 1 : 0);
      
      // Normalize diagonal movement
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len > 0) {
        predictedPos.x += (dx / len) * speed * dt;
        predictedPos.y += (dy / len) * speed * dt;
      }
      
      // Store input for reconciliation
      inputHistory.push({
        input: { ...input },
        timestamp: performance.now(),
        predictedPos: { ...predictedPos }
      });
      
      // Keep only recent history (1 second)
      const cutoff = performance.now() - 1000;
      inputHistory = inputHistory.filter(h => h.timestamp > cutoff);
      
      return { ...predictedPos };
    },
    
    // Reconcile with server state
    reconcile(serverPos, serverTime) {
      lastServerPos = { ...serverPos };
      lastServerTime = serverTime;
      
      // Find inputs that happened after server state
      const replayInputs = inputHistory.filter(h => h.timestamp > serverTime);
      
      // Reset to server position and replay inputs
      predictedPos = { ...serverPos };
      for (const h of replayInputs) {
        const dt = 0.05; // Assume 50ms intervals
        const speed = 200;
        const dx = (h.input.right ? 1 : 0) - (h.input.left ? 1 : 0);
        const dy = (h.input.down ? 1 : 0) - (h.input.up ? 1 : 0);
        
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
          predictedPos.x += (dx / len) * speed * dt;
          predictedPos.y += (dy / len) * speed * dt;
        }
      }
      
      return { ...predictedPos };
    },
    
    getCurrentPos() {
      return { ...predictedPos };
    },
    
    setPos(pos) {
      predictedPos = { ...pos };
    }
  };
}

// Connection quality monitoring
export function createLatencyMonitor(ws) {
  let pingHistory = [];
  let lastPingTime = 0;
  
  return {
    sendPing() {
      const now = performance.now();
      lastPingTime = now;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'ping', timestamp: now }));
      }
    },
    
    handlePong(serverTimestamp) {
      const now = performance.now();
      const rtt = now - serverTimestamp;
      pingHistory.push({ rtt, timestamp: now });
      
      // Keep only recent pings (30 seconds)
      const cutoff = now - 30000;
      pingHistory = pingHistory.filter(p => p.timestamp > cutoff);
      
      return rtt;
    },
    
    getAverageLatency() {
      if (pingHistory.length === 0) return 0;
      const sum = pingHistory.reduce((acc, p) => acc + p.rtt, 0);
      return sum / pingHistory.length;
    },
    
    getLatencyStats() {
      if (pingHistory.length === 0) return { avg: 0, min: 0, max: 0, jitter: 0 };
      
      const rtts = pingHistory.map(p => p.rtt);
      const avg = rtts.reduce((a, b) => a + b) / rtts.length;
      const min = Math.min(...rtts);
      const max = Math.max(...rtts);
      
      // Calculate jitter (standard deviation)
      const variance = rtts.reduce((acc, rtt) => acc + Math.pow(rtt - avg, 2), 0) / rtts.length;
      const jitter = Math.sqrt(variance);
      
      return { avg, min, max, jitter };
    }
  };
}

// Minimal toast helper
export function toast(msg, ms=5000) { // time = 5000ms = 5s
  let t = document.querySelector('.toast');
  if (!t) { t = document.createElement('div'); t.className='toast'; document.body.appendChild(t); }
  t.textContent = msg; t.classList.add('show');
  clearTimeout(t._hide);
  t._hide = setTimeout(()=>t.classList.remove('show'), ms);
}
</file>

<file path="src/config.ts">
export type GameConfig = {
  arena: { width: number; height: number };
  ticks: { mainMs: number; pickupMs: number };
  round: { durationMs: number };
  speeds: { streamer: number; zombie: number; zombieBoostMultiplier: number; zombieSlowMultiplier: number };
  streamer: { maxHp: number };
  combat: { zombieTouchDamage: number; knockbackStep: number; respawnMs: number };
  weapons: {
    damage: { pistol: number; smg: number; shotgun: number; melee: number };
    cooldownMs: { pistol: { base: number; boosted: number }; smg: { base: number; boosted: number }; shotgun: { base: number; boosted: number } };
    projectile: { pistol: { speed: number; ttl: number }; smg: { speed: number; ttl: number }; shotgun: { speed: number; ttl: number; pellets: number } };
    ammo: { initial: { pistol: number; smg: number; shotgun: number }; pickupGain: { pistol: number; smg: number; shotgun: number }; max: { pistol: number; smg: number; shotgun: number } };
  };
  melee: { cooldownMs: number; reach: number; arcRad: number; knockbackStep: number };
  dash: { cooldownMs: number; durationMs: number; speedMultiplier: number };
  pickups: {
    spawnIntervalMs: number;
    totalCap: number;
    minDistance: number;
    caps: Record<string, number>;
    treasureScore: number;
    blastRadius: number;
  };
  effects: { weaponBoostMs: number; shieldMs: number; magnetMs: number; zombieBoostMs: number; freezeMs: number };
  extraction: { radius: number; countMin: number; countMax: number; minActiveMs: number; maxActiveMs: number };
  radii: { streamer: number; zombie: number; bulletMargin: number };
  zombies: {
    baseHp: number;
    weights: { runner: number; brute: number; spitter: number; stalker: number; bomber: number };
    speedMul: { runner: number; brute: number; spitter: number; stalker: number; bomber: number };
    hpMul: { runner: number; brute: number; spitter: number; stalker: number; bomber: number };
    detectionRange: { runner: number; brute: number; spitter: number; stalker: number; bomber: number };
    chaseRange: { runner: number; brute: number; spitter: number; stalker: number; bomber: number };
    brute: { extraKnockbackMul: number };
    spitter: { cooldownMsMin: number; cooldownMsMax: number; manualCooldownMs: number; projectileSpeed: number; projectileTtl: number; hitDamage: number; slowMs: number; streamerSlowMul: number; range: number };
    stalker: { cloakDurationMs: number; uncloakDurationMs: number; attackCooldownMs: number; cloakAlpha: number };
    bomber: { explosionRadius: number; explosionDamage: number; fuseTimeMs: number; warningRadius: number };
    runnerAbility: { cooldownMs: number; durationMs: number };
    bruteAbility: { cooldownMs: number; durationMs: number; speed: number };
  };
  aiZombies: {
    maxCount: number;
    spawnCooldownMs: number;
    dropChance: number;
    ammoDropChance: number;
    treasureDropChance: number;
    treasureValues: Record<string, number>;
    treasureDropRates: Record<string, number>;
  };
  tiles: { 
    size: number; 
    theme: "dungeon" | "cave" | "lab";
    traps: {
      waterFrequency: number;    // Multiplier for water trap spawn rate
      pitFrequency: number;      // Multiplier for death pit spawn rate  
      spikeFrequency: number;    // Multiplier for spike trap spawn rate
      poisonFrequency: number;   // Multiplier for poison pool spawn rate
    };
  };
  bosses: {
    spawnIntervalMs: number;     // Time between boss spawns
    maxActive: number;           // Maximum bosses active at once
    announceMs: number;          // Warning time before boss spawns
    types: {
      necromancer: {
        hp: number;
        speed: number;
        radius: number;
        damage: number;
        visual: {
          color: string;
          secondaryColor: string;
          symbol: string;
          minimapIcon: string;
          glowColor: string;
        };
        abilities: {
          summon: { cooldownMs: number; minionCount: number; minionHp: number };
          teleport: { cooldownMs: number; range: number };
          poisonField: { cooldownMs: number; radius: number; durationMs: number; dps: number };
        };
      };
      bruteKing: {
        hp: number;
        speed: number;
        radius: number;
        damage: number;
        visual: {
          color: string;
          secondaryColor: string;
          symbol: string;
          minimapIcon: string;
          glowColor: string;
        };
        abilities: {
          charge: { cooldownMs: number; speed: number; durationMs: number; damage: number };
          groundSlam: { cooldownMs: number; radius: number; damage: number; stunMs: number };
          enrage: { hpThreshold: number; speedMul: number; damageMul: number };
        };
      };
      shadowLord: {
        hp: number;
        speed: number;
        radius: number;
        damage: number;
        visual: {
          color: string;
          secondaryColor: string;
          symbol: string;
          minimapIcon: string;
          glowColor: string;
        };
        abilities: {
          phase: { cooldownMs: number; durationMs: number; alpha: number };
          shadowClone: { cooldownMs: number; cloneCount: number; cloneHp: number; durationMs: number };
          lifeDrain: { cooldownMs: number; range: number; dps: number; healMul: number };
        };
      };
    };
    lootDrops: {
      guaranteedDrops: number;   // Minimum drops on death
      bonusDropChance: number;   // Chance for extra drops
      maxBonusDrops: number;     // Maximum bonus drops
      treasureMultiplier: number; // Multiplier for treasure value
      specialDrops: {
        legendaryChance: number;  // Chance for legendary items
        weaponUpgradeChance: number; // Chance for weapon upgrades
        keyDropChance: number;    // Chance for keys
      };
    };
  };
};

export const CONFIG: GameConfig = {
  arena: { width: 7200, height: 4050 },
  ticks: { mainMs: 50, pickupMs: 500 },
  round: { durationMs: 5 * 60 * 1000 },
  speeds: { streamer: 175, zombie: 65, zombieBoostMultiplier: 1.75, zombieSlowMultiplier: 0.55 },
  streamer: { maxHp: 100 },
  combat: { zombieTouchDamage: 10, knockbackStep: 12, respawnMs: 800 },
  weapons: {
    damage: {
      pistol: 100,
      smg: 100,
      shotgun: 100, // Per pellet
      melee: 100,
    },
    cooldownMs: {
      pistol: { base: 320, boosted: 200 },
      smg: { base: 90, boosted: 60 },
      shotgun: { base: 800, boosted: 550 },
    },
    projectile: {
      pistol: { speed: 360, ttl: 1200 },
      smg: { speed: 340, ttl: 900 },
      shotgun: { speed: 300, ttl: 600, pellets: 6 },
    },
    ammo: {
      initial: { pistol: 60, smg: 120, shotgun: 24 },
      pickupGain: { pistol: 15, smg: 30, shotgun: 6 },
      max: { pistol: 120, smg: 240, shotgun: 48 },
    },
  },
  melee: { cooldownMs: 500, reach: 32, arcRad: Math.PI / 1.2, knockbackStep: 8 },
  dash: { cooldownMs: 1000, durationMs: 180, speedMultiplier: 3.5 },
  pickups: {
    spawnIntervalMs: 12000,
    totalCap: 12,
    minDistance: 48,
    caps: { health: 3, speed: 3, ammo: 3, weapon: 2, shield: 2, magnet: 2, freeze: 1, blast: 2, treasure: 3, key: 1 },
    treasureScore: 3,
    blastRadius: 90,
  },
  effects: { weaponBoostMs: 8000, shieldMs: 6000, magnetMs: 8000, zombieBoostMs: 7000, freezeMs: 6000 },
  extraction: { radius: 28, countMin: 1, countMax: 2, minActiveMs: 60_000, maxActiveMs: 90_000 },
  radii: { streamer: 10, zombie: 12, bulletMargin: 2 },
  zombies: {
    baseHp: 100,
    weights: { runner: 6, brute: 2, spitter: 2, stalker: 1, bomber: 1 },
    speedMul: { runner: 2.5, brute: 0.5, spitter: 1.5, stalker: 2.0, bomber: 1.0 },
    hpMul: { runner: 1.5, brute: 5, spitter: 2, stalker: 1.2, bomber: 2.5 },
    detectionRange: { runner: 300, brute: 300, spitter: 300, stalker: 400, bomber: 250 },
    chaseRange: { runner: 180, brute: 150, spitter: 200, stalker: 220, bomber: 120 },
    brute: { extraKnockbackMul: 1.4 },
    spitter: { cooldownMsMin: 1800, cooldownMsMax: 3000, manualCooldownMs: 900, projectileSpeed: 160, projectileTtl: 1800, hitDamage: 6, slowMs: 1600, streamerSlowMul: 0.65, range: 360 },
    stalker: { cloakDurationMs: 8000, uncloakDurationMs: 2000, attackCooldownMs: 1500, cloakAlpha: 0.15 },
    bomber: { explosionRadius: 80, explosionDamage: 40, fuseTimeMs: 2000, warningRadius: 100 },
    runnerAbility: { cooldownMs: 1200, durationMs: 280 },
    bruteAbility: { cooldownMs: 1600, durationMs: 320, speed: 240 },
  },
  aiZombies: {
    maxCount: 30,
    spawnCooldownMs: 5000,
    dropChance: 0.45, // overall chance that ANY drop happens at all
    ammoDropChance: 0.5, // chance of ammo drop (if drop happens)
    treasureDropChance: 0.3, // chance of treasure drop (if drop happens)
    treasureValues: {
      coin: 10,
      gem: 25,
      crystal: 50,
      orb: 75,
      relic: 100,
      artifact: 150,
      medallion: 250,
      scroll: 400,
      crown: 1000
    },
    treasureDropRates: {
      coin: 0.25,        // Common (25%)
      gem: 0.20,         // Common (20%)
      crystal: 0.15,     // Uncommon (15%)
      orb: 0.13,         // Uncommon (13%)
      relic: 0.11,       // Rare (11%)
      artifact: 0.08,    // Rare (8%)
      medallion: 0.05,   // Epic (5%)
      scroll: 0.02,      // Epic (2%)
      crown: 0.01        // Legendary (1%)
    }
  },
  tiles: { 
    size: 24, 
    theme: "dungeon",
    traps: {
      waterFrequency: 0.15,    // 15% of rooms get water traps
      pitFrequency: 0.12,      // 12% of rooms get death pits
      spikeFrequency: 0.08,    // 8% of rooms get spike traps
      poisonFrequency: 0.06,   // 6% of rooms get poison pools
    }
  },
  bosses: {
    spawnIntervalMs: 120000,   // 2 minutes between boss spawns
    maxActive: 1,              // Only one boss at a time
    announceMs: 10000,         // 10 second warning before spawn
    types: {
      necromancer: {
        hp: 2000,
        speed: 80,
        radius: 20,
        damage: 25,
        visual: {
          color: "#4A0E4E",           // Dark purple
          secondaryColor: "#8B008B",  // Dark magenta
          symbol: "💀",               // Skull emoji
          minimapIcon: "⚫",          // Black circle
          glowColor: "#9932CC",       // Dark orchid glow
        },
        abilities: {
          summon: { cooldownMs: 15000, minionCount: 3, minionHp: 150 },
          teleport: { cooldownMs: 8000, range: 300 },
          poisonField: { cooldownMs: 12000, radius: 100, durationMs: 8000, dps: 8 },
        },
      },
      bruteKing: {
        hp: 3500,
        speed: 60,
        radius: 25,
        damage: 40,
        visual: {
          color: "#8B0000",           // Dark red
          secondaryColor: "#FF4500",  // Orange red
          symbol: "👑",               // Crown emoji
          minimapIcon: "🔴",          // Red circle
          glowColor: "#DC143C",       // Crimson glow
        },
        abilities: {
          charge: { cooldownMs: 10000, speed: 250, durationMs: 2000, damage: 60 },
          groundSlam: { cooldownMs: 15000, radius: 120, damage: 50, stunMs: 2000 },
          enrage: { hpThreshold: 0.3, speedMul: 1.5, damageMul: 1.8 },
        },
      },
      shadowLord: {
        hp: 2500,
        speed: 100,
        radius: 18,
        damage: 30,
        visual: {
          color: "#2F2F2F",           // Dark gray
          secondaryColor: "#4B0082",  // Indigo
          symbol: "👤",               // Silhouette emoji
          minimapIcon: "🟣",          // Purple circle
          glowColor: "#6A0DAD",       // Purple glow
        },
        abilities: {
          phase: { cooldownMs: 12000, durationMs: 4000, alpha: 0.2 },
          shadowClone: { cooldownMs: 20000, cloneCount: 2, cloneHp: 400, durationMs: 15000 },
          lifeDrain: { cooldownMs: 8000, range: 150, dps: 15, healMul: 0.8 },
        },
      },
    },
    lootDrops: {
      guaranteedDrops: 8,        // Always drop 8 items
      bonusDropChance: 0.7,      // 70% chance for bonus drops
      maxBonusDrops: 5,          // Up to 5 bonus drops
      treasureMultiplier: 3.0,   // 3x treasure value
      specialDrops: {
        legendaryChance: 0.15,   // 15% chance for legendary treasures
        weaponUpgradeChance: 0.25, // 25% chance for weapon upgrades
        keyDropChance: 0.8,      // 80% chance for keys
      },
    },
  },
};

export type TileId = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7; // floor, wall, pit, water, doorClosed, doorOpen, spikes, poison
</file>

<file path="public/join.html">
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arena Shooter — Join as Zombie</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="game">
  <div class="topbar">
    <div class="brand">Arena Shooter</div>
    <div class="middle-controls">
      <span class="badge" id="status" data-state="disconnected">disconnected</span>
    </div>
    <div class="right-controls">
      <button id="fullscreen">Fullscreen</button>
      <button id="nerdToggle">Nerd Stats</button>
    </div>
  </div>

  <div class="app">
    <div class="main">
      <div class="stage"></div>
    </div>
    <aside class="sidebar">
      <div class="card">
        <div class="card-title">Join</div>
        <div class="row">
          <label for="name" class="badge">Name</label>
          <input id="name" />
        </div>
        <div class="row">
          <button id="shuffle">Random</button>
          <button id="join">Join</button>
          <span class="badge" id="timer">Time: --</span>
        </div>
        <div class="tip">WASD to move. You are a slow zombie; touch the streamer to drain their score.</div>
      </div>

      <div class="card">
        <div class="card-title">Emotes</div>
        <div id="emoteBar">
          <button class="emote">🧟</button>
          <button class="emote">💀</button>
          <button class="emote">🔥</button>
          <button class="emote">😂</button>
          <button class="emote">❤️</button>
          <button class="emote">💢</button>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Players</div>
        <div class="pill-list" id="players"></div>
      </div>

      <div class="card">
        <div class="card-title">Chat</div>
        <div id="chatMessages" class="chat-messages"></div>
        <div class="row"><input id="chatInput" placeholder="Chat..." /></div>
      </div>
    </aside>
  </div>

  <script type="module">
    import { connect, nameStorage, minimalCanvas, suppressPageHotkeys, inputController, createLatencyMonitor } from '/common.js';

    const params = new URLSearchParams(location.search);
    let roomId = params.get('room') || '';

    const { c, ctx } = minimalCanvas(1440, 810);
    suppressPageHotkeys();
    let ws, playerId, arena={w:960,h:540};
    let state = { players:[], bullets:[], arena, remainingTime: 0 };
    let gameMap = null; // {w,h,size,theme,tiles:Uint8Array, props, lights}
    const input = inputController({ mouse:true });
    const effects = [];
    // Damage numbers for floating damage display
    let damageNumbers = [];
    // Smoothing for 20Hz -> 60fps render
    const smooth = new Map(); // id -> {x,y}
    const SMOOTH_TAU = 90; // ms
    function getSmoothedPos(id, tx, ty, dt){
      let s = smooth.get(id);
      if (!s) { s = { x: tx, y: ty }; smooth.set(id, s); return { x: tx, y: ty }; }
      const alpha = 1 - Math.exp(-dt / Math.max(1, SMOOTH_TAU));
      s.x += (tx - s.x) * alpha;
      s.y += (ty - s.y) * alpha;
      return { x: s.x, y: s.y };
    }
    // Dash trails for streamer visibility from zombie clients
    const trails = new Map(); // id -> Array<{x:number,y:number,t:number}>
    const TRAIL_TTL = 260; const TRAIL_MAX = 22;
    let prevBulletPos = new Map();

    const status = document.getElementById('status');
    const playersEl = document.getElementById('players');
    const nameEl = document.getElementById('name');
    const joinBtn = document.getElementById('join');
    // Join URL / code input
    const roomUrlInput = document.createElement('input');
    roomUrlInput.id = 'roomUrl';
    roomUrlInput.className = 'mono';
    roomUrlInput.placeholder = 'Room URL or code';
    // Insert into the Join card under name row
    const joinCard = document.querySelector('.sidebar .card');
    if (joinCard) {
      const row = document.createElement('div'); row.className = 'row'; row.appendChild(roomUrlInput);
      joinCard.insertBefore(row, joinCard.children[2]);
    }
    if (roomId) roomUrlInput.value = `${location.origin}/join.html?room=${roomId}`;
    roomUrlInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') joinBtn.click(); });
    const shuffleBtn = document.getElementById('shuffle');
    const timerEl = document.getElementById('timer');
    const emoteBar = document.getElementById('emoteBar');
    const chatInput = document.getElementById('chatInput');
    const chatMessagesEl = document.getElementById('chatMessages');
    const nerdToggleBtn = document.getElementById('nerdToggle');
    // Nerd panel overlay element
    const nerdPanel = document.createElement('div');
    nerdPanel.id = 'nerdPanel';
    nerdPanel.className = 'nerd-panel hidden mono';
    document.body.appendChild(nerdPanel);

    let nerdOn = localStorage.getItem('nerdStats') === '1';
    function setNerd(on){
      nerdOn = !!on;
      localStorage.setItem('nerdStats', nerdOn ? '1' : '0');
      nerdPanel.classList.toggle('hidden', !nerdOn);
      nerdToggleBtn.classList.toggle('active', nerdOn);
    }
    setNerd(nerdOn);
    nerdToggleBtn.onclick = () => setNerd(!nerdOn);

    // preload name
    nameEl.value = nameStorage().get() || '';

    function randomName(){
      const pool = ("KibaRogue,WoodsScav,ShorelineRat,FactoryGhost,LabsRunner,InterchangeChad,DormsGoblin,ReserveMole,FleaFlipper,TetrizHoarder,LedXHunter,SlickSeeker,RSASSEnjoyer,M995Enjoyer,GrenadierGoon,SanitarStan,KillaChaser,TagillaTapper,GluharGuy,ShturmanScout,KnightWatcher,RogueRaider,USECFriend,BEARBuddy,JaegerPal,FenceFella,TherapistAlly,RagmanRigger,SkierSlinger,PraporPatron,MechanicMain,PeacekeeperPro,LabsRat,MarkedRoomMole,StashGremlin,MoonshineMax,ScavJunkie,OmComEnjoyer,SJ6Sprinter,AltynAddict,ThermalAndy,GreenBatteryGuy,DormsKeyKing,GPUGoblin,AmmoArbiter,WaffleFilter").split(",");
      return pool[Math.floor(Math.random()*pool.length)];
    }

    document.getElementById('shuffle').onclick = (ev) => { nameEl.value = randomName(); if (ev.currentTarget && ev.currentTarget.blur) ev.currentTarget.blur(); };

    function sendChat(msg) {
      if (ws && ws.readyState===1) ws.send(JSON.stringify({ type:'chat', message: msg }));
    }

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && chatInput.value.trim()) {
        sendChat(chatInput.value.trim());
        chatInput.value = '';
      }
    });

    function appendChat(from, message) {
      chatMessagesEl.innerHTML += `<div>${from}: ${message}</div>`;
      while (chatMessagesEl.children.length > 10) {
        chatMessagesEl.removeChild(chatMessagesEl.firstChild);
      }
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    let sendNeutralHandler = null; let visHandler = null; let inputIv = null;
    let pingIv = null; let latency = null; let stateMsgCount = 0; let statesPerSec = 0; let lastStateRateAt = performance.now();
    function leave(){
      if (ws) { try { if (ws.readyState===1) ws.close(1000,'leave'); } catch{} ws=null; }
      status.textContent = 'disconnected';
      status.dataset.state = 'disconnected';
      document.body.classList.remove('connected');
      joinBtn.textContent = 'Join';
      nameEl.disabled = false; shuffleBtn.disabled = false;
      if (inputIv) { clearInterval(inputIv); inputIv = null; }
      if (pingIv) { clearInterval(pingIv); pingIv = null; }
      if (sendNeutralHandler) { window.removeEventListener('blur', sendNeutralHandler); sendNeutralHandler=null; }
      if (visHandler) { document.removeEventListener('visibilitychange', visHandler); visHandler=null; }
    }

    function extractRoomId(val){
      const s = String(val||'').trim();
      if (!s) return '';
      try {
        const u = new URL(s);
        const q = u.searchParams.get('room');
        if (q) return q;
      } catch {}
      // fallback: treat as code
      return s;
    }

    joinBtn.onclick = (ev) => {
      if (ws && ws.readyState===1) { leave(); return; }
      const provided = extractRoomId(roomUrlInput.value);
      if (provided) roomId = provided;
      if (!roomId) { alert('Missing room id'); return; }
      const name = (nameEl.value||'').slice(0,20);
      nameStorage().set(name);
      if (ev.currentTarget && ev.currentTarget.blur) ev.currentTarget.blur();
      ws = connect(roomId);
      ws.addEventListener('open', () => {
        status.textContent = 'connected';
        status.dataset.state = 'connected';
        document.body.classList.add('connected');
        ws.send(JSON.stringify({ type:'join_room', role:'zombie', name }));
        joinBtn.textContent = 'Leave';
        nameEl.disabled = true; shuffleBtn.disabled = true;
      });
      latency = createLatencyMonitor(ws);
      if (pingIv) { clearInterval(pingIv); pingIv = null; }
      pingIv = setInterval(() => { try { latency.sendPing(); } catch {} }, 1000);
      ws.addEventListener('message', (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'map') {
          try {
            const m = msg.map; const bin = atob(m.tilesBase64);
            const u8 = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
            gameMap = { w:m.w, h:m.h, size:m.size, theme:m.theme, tiles:u8, props:m.props||[], lights:m.lights||[] };
          } catch {}
        }
        if (msg.type === 'joined') { arena = msg.arena; playerId = msg.playerId; }
        if (msg.type === 'state') {
          stateMsgCount++;
          // impact effects
          const curMap = new Map(msg.bullets.map(b=>[b.id,{x:b.x,y:b.y}]));
          for (const [id,pos] of prevBulletPos) {
            if (!curMap.has(id)) effects.push({x:pos.x,y:pos.y,ttl:220});
          }
          prevBulletPos = curMap;

          // Process damage numbers
          if (msg.damageNumbers) {
            for (const dn of msg.damageNumbers) {
              // Check if we already have this damage number
              if (!damageNumbers.some(existing => existing.id === dn.id)) {
                damageNumbers.push({
                  id: dn.id,
                  x: dn.x,
                  y: dn.y,
                  damage: dn.damage,
                  isCrit: dn.isCrit,
                  isDot: dn.isDot,
                  timestamp: dn.timestamp,
                  startTime: Date.now(),
                  offsetY: 0
                });
              }
            }
          }

          state = msg; const ping = Math.max(0, Date.now() - (msg.t||Date.now()));
          status.textContent = `connected • ${ping} ms • players: ${msg.players.length}`; 
          status.dataset.state = 'connected';
          state.remainingTime = msg.remainingTime;
          updateTimer(state.remainingTime);
          updatePlayerList(msg.players);
          // Respect chat enabled/disabled from server
          if (typeof msg.chatEnabled === 'boolean') {
            chatInput.disabled = !msg.chatEnabled;
            chatInput.placeholder = msg.chatEnabled ? 'Chat...' : 'Chat disabled by streamer';
            const chatCard = chatMessagesEl.closest('.card');
          if (chatCard) chatCard.classList.toggle('hidden', !msg.chatEnabled);
          }
        }
        if (msg.type === 'pong') {
          if (latency) latency.handlePong(Number(msg.timestamp)||0);
        }
        if (msg.type === 'chat') {
          appendChat(msg.from, msg.message);
        }
        if (msg.type === 'notice') {
          appendChat('System', msg.message);
        }
      });
      // Send continuous movement state for smooth input like streamer
      inputIv = setInterval(() => {
        if (ws && ws.readyState===1) {
          const { up,down,left,right,shoot } = input;
          const aimWX = camX + (input.aimX / zoom);
          const aimWY = camY + (input.aimY / zoom);
          ws.send(JSON.stringify({ type:'input', up, down, left, right, shoot, melee:false, dash:false, aimX:aimWX, aimY:aimWY }));
        }
      }, 50);

      // If the tab loses focus while holding a key, send a neutral input
      sendNeutralHandler = () => { if (ws && ws.readyState===1) ws.send(JSON.stringify({ type:'input', up:false, down:false, left:false, right:false, shoot:false, melee:false, dash:false, aimX:0, aimY:0 })); };
      visHandler = () => { if (document.hidden) sendNeutralHandler(); };
      window.addEventListener('blur', sendNeutralHandler);
      document.addEventListener('visibilitychange', visHandler);

      ws.addEventListener('close', () => { leave(); }, { once: true });
    };

    // Emote palette: send selected emoji to server (zombies only)
    emoteBar.addEventListener('click', (e) => {
      const target = e.target;
      if (!target || !(target instanceof HTMLElement) || !target.classList.contains('emote')) return;
      const symbol = target.textContent || '';
      if (!ws || ws.readyState !== 1) return;
      ws.send(JSON.stringify({ type: 'emote', symbol }));
    });

    // Simple camera for zombies: follow self
    let camX = 0, camY = 0;
    const zoom = 2.4; // match streamer view
    function draw(dt=16){
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
      const rect = c.getBoundingClientRect();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,c.width,c.height);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      // Fill background with dungeon-themed dark color in CSS px
      ctx.fillStyle = "#0a0c0f";
      ctx.fillRect(0,0,rect.width,rect.height);
      // Update camera target (follow me)
      let meRaw = state.players.find(p=>p.id===playerId);
      if (!meRaw && state.players && state.players.length) {
        meRaw = state.players.find(p=>p.role==='zombie') || state.players[0];
      }
      const meCam = meRaw ? getSmoothedPos(meRaw.id, meRaw.x, meRaw.y, dt) : null;
      if (meCam) {
        const viewW = rect.width / zoom, viewH = rect.height / zoom;
        const targetX = Math.min(Math.max(0, meCam.x - viewW/2), Math.max(0, arena.w - viewW));
        const targetY = Math.min(Math.max(0, meCam.y - viewH/2), Math.max(0, arena.h - viewH));
        const k = Math.min(1, (dt/16) * 0.12);
        camX = camX + (targetX - camX) * k;
        camY = camY + (targetY - camY) * k;
      }

      // World transform
      ctx.save();
      ctx.scale(zoom, zoom);
      ctx.translate(-camX, -camY);
      // Tiles first
      if (gameMap) drawTiles(camX, camY, rect.width/zoom, rect.height/zoom);
      // Walls/rooms
      if (state.walls){
        ctx.fillStyle = '#2a2f36';
        for (const w of state.walls){ ctx.fillRect(w.x,w.y,w.w,w.h); }
      }
      // Extractions removed
      // Pickups
      if (state.pickups){
        for (const pk of state.pickups){
          ctx.save();
          ctx.shadowColor = 'rgba(255,255,255,.18)'; ctx.shadowBlur = 8;
          if (pk.type==='health'){
            ctx.strokeStyle = '#66bb6a'; ctx.lineWidth = 2; ctx.strokeRect(pk.x-8, pk.y-8, 16, 16);
            ctx.beginPath(); ctx.moveTo(pk.x-6, pk.y); ctx.lineTo(pk.x+6, pk.y); ctx.moveTo(pk.x, pk.y-6); ctx.lineTo(pk.x, pk.y+6); ctx.stroke();
          } else if (pk.type==='speed') {
            ctx.strokeStyle = '#64b5f6'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(pk.x-5, pk.y-8); ctx.lineTo(pk.x+2, pk.y-2); ctx.lineTo(pk.x-2, pk.y-2); ctx.lineTo(pk.x+5, pk.y+8); ctx.stroke();
          } else if (pk.type==='ammo') {
            ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2; ctx.strokeRect(pk.x-7, pk.y-5, 14, 10);
            ctx.beginPath(); ctx.moveTo(pk.x-4, pk.y+1); ctx.lineTo(pk.x-4, pk.y-1); ctx.moveTo(pk.x, pk.y+1); ctx.lineTo(pk.x, pk.y-1); ctx.moveTo(pk.x+4, pk.y+1); ctx.lineTo(pk.x+4, pk.y-1); ctx.stroke();
          } else if (pk.type==='weapon') {
            ctx.strokeStyle = '#ffa726'; ctx.beginPath(); ctx.moveTo(pk.x-6,pk.y); ctx.lineTo(pk.x,pk.y-8); ctx.lineTo(pk.x+2,pk.y-2); ctx.lineTo(pk.x+8,pk.y-2); ctx.lineTo(pk.x,pk.y+8); ctx.lineTo(pk.x+2,pk.y+2); ctx.lineTo(pk.x-6,pk.y); ctx.stroke();
          } else if (pk.type==='shield') {
            ctx.strokeStyle = '#26c6da'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(pk.x, pk.y, 9, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(pk.x, pk.y-6); ctx.lineTo(pk.x, pk.y+6); ctx.stroke();
          } else if (pk.type==='magnet') {
            ctx.strokeStyle = '#ab47bc'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pk.x-3, pk.y, 6, -Math.PI/2, Math.PI/2);
            ctx.arc(pk.x+3, pk.y, 6, Math.PI/2, -Math.PI/2);
            ctx.stroke();
          } else if (pk.type==='freeze') {
            ctx.strokeStyle = '#90caf9'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pk.x, pk.y-7); ctx.lineTo(pk.x, pk.y+7);
            ctx.moveTo(pk.x-7, pk.y); ctx.lineTo(pk.x+7, pk.y);
            ctx.moveTo(pk.x-5, pk.y-5); ctx.lineTo(pk.x+5, pk.y+5);
            ctx.moveTo(pk.x-5, pk.y+5); ctx.lineTo(pk.x+5, pk.y-5);
            ctx.stroke();
          } else if (pk.type==='blast') {
            ctx.strokeStyle = '#ff7043'; ctx.lineWidth = 2;
            for (let i=0;i<8;i++){ const a=i*Math.PI/4; ctx.beginPath(); ctx.moveTo(pk.x+Math.cos(a)*3, pk.y+Math.sin(a)*3); ctx.lineTo(pk.x+Math.cos(a)*10, pk.y+Math.sin(a)*10); ctx.stroke(); }
            ctx.beginPath(); ctx.arc(pk.x, pk.y, 3, 0, Math.PI*2); ctx.stroke();
          } else if (pk.type==='treasure') {
            ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2;
            ctx.strokeRect(pk.x-8, pk.y-6, 16, 12);
            ctx.beginPath(); ctx.moveTo(pk.x-8, pk.y-2); ctx.lineTo(pk.x+8, pk.y-2); ctx.stroke();
            ctx.beginPath(); ctx.arc(pk.x, pk.y+1, 2, 0, Math.PI*2); ctx.stroke();
          }
          // label under pickup
          ctx.font = '10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.save(); ctx.globalAlpha = 0.18; ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(pk.x, pk.y, 3, 0, Math.PI*2); ctx.fill(); ctx.restore();
          ctx.fillStyle = '#cfd8dc'; ctx.globalAlpha = 0.95;
          const labelMap = { health:'HEALTH', speed:'SPEED', ammo:'AMMO', weapon:'WEAPON', shield:'SHIELD', magnet:'MAGNET', freeze:'FREEZE', blast:'BLAST', treasure:'TREASURE', key:'KEY' };
          const lbl = labelMap[pk.type] || String(pk.type).toUpperCase();
          if (lbl) ctx.fillText(lbl, pk.x, pk.y + 14);
          ctx.restore();
        }
        ctx.lineWidth = 1;
      }
      // Bullets
      ctx.fillStyle = '#ffd54f';
      for (const b of state.bullets){
        ctx.save();
        ctx.shadowColor = 'rgba(255,213,79,.6)';
        ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
      // Spitter globs
      if (state.globs){
        ctx.fillStyle = '#ce93d8';
        for (const g of state.globs){
          ctx.save(); ctx.shadowColor='rgba(206,147,216,.6)'; ctx.shadowBlur=8; ctx.beginPath(); ctx.arc(g.x,g.y,4,0,Math.PI*2); ctx.fill(); ctx.restore();
        }
      }
      // Bullet impact effects
      for (let i=effects.length-1;i>=0;i--){ const e=effects[i]; e.ttl-=dt; if (e.ttl<=0){ effects.splice(i,1); continue; } ctx.save(); const a=Math.max(0,e.ttl/220); ctx.globalAlpha=a; ctx.strokeStyle='#ffd54f'; ctx.beginPath(); ctx.arc(e.x,e.y,(1-a)*12+2,0,Math.PI*2); ctx.stroke(); ctx.restore(); }

      // Damage numbers
      const now = Date.now();
      for (let i = damageNumbers.length - 1; i >= 0; i--) {
        const dn = damageNumbers[i];
        const age = now - dn.startTime;
        const maxAge = 1500; // 1.5 seconds
        
        if (age > maxAge) {
          damageNumbers.splice(i, 1);
          continue;
        }
        
        // Animation: float up and fade out
        const progress = age / maxAge;
        const alpha = Math.max(0, 1 - progress * progress); // Quadratic fade
        dn.offsetY = -progress * 60; // Float up 60 pixels
        
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Different styles for different damage types
        if (dn.isCrit) {
          ctx.font = 'bold 18px monospace';
          ctx.fillStyle = '#ff4444';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.strokeText(dn.damage.toString(), dn.x, dn.y + dn.offsetY);
          ctx.fillText(dn.damage.toString(), dn.x, dn.y + dn.offsetY);
        } else if (dn.isDot) {
          ctx.font = '12px monospace';
          ctx.fillStyle = '#88ff44';
          ctx.fillText(dn.damage.toString(), dn.x, dn.y + dn.offsetY);
        } else {
          ctx.font = '14px monospace';
          ctx.fillStyle = '#ffffff';
          ctx.fillText(dn.damage.toString(), dn.x, dn.y + dn.offsetY);
        }
        
        ctx.restore();
      }
      // Players' dash trails under characters
      const nowT = performance.now();
      if (state.players){
        for (const p of state.players){
          const sp = getSmoothedPos(p.id, p.x, p.y, 0);
          let arr = trails.get(p.id) || [];
          if (p.dashing){ arr.push({ x: sp.x, y: sp.y, t: nowT }); if (arr.length > TRAIL_MAX) arr.shift(); }
          arr = arr.filter(pt => nowT - pt.t <= TRAIL_TTL);
          trails.set(p.id, arr);
          if (arr.length >= 2){
            for (let i=0;i<arr.length;i++){
              const age = nowT - arr[i].t;
              const a = Math.max(0, 1 - (age / TRAIL_TTL));
              const r = 6 + 10 * a;
              ctx.save(); ctx.globalAlpha = 0.22 + 0.4*a; ctx.fillStyle='rgba(158,241,209,1)'; ctx.shadowColor='rgba(158,241,209,.7)'; ctx.shadowBlur=12*a; ctx.beginPath(); ctx.arc(arr[i].x,arr[i].y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
            }
          }
        }
      }

      // Players
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'center';
      for (const p of state.players){
        const sp = getSmoothedPos(p.id, p.x, p.y, dt);
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,.6)'; ctx.shadowBlur = 0;
        if (p.role==='streamer'){
          ctx.strokeStyle = '#4caf50';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(sp.x,sp.y,10,0,Math.PI*2); ctx.stroke();
          ctx.fillStyle = '#4caf50'; ctx.globalAlpha = .95; ctx.fillText(p.name, sp.x, sp.y - 16);
        } else {
          ctx.fillStyle = p.alive? '#ef5350' : 'rgba(239,83,80,.25)';
          ctx.beginPath(); ctx.arc(sp.x,sp.y,12,0,Math.PI*2); ctx.fill();
          // Class outline
          if (p.zClass === 'runner') { ctx.strokeStyle = '#64b5f6'; ctx.lineWidth = 1.5; }
          else if (p.zClass === 'brute') { ctx.strokeStyle = '#ffa726'; ctx.lineWidth = 3; }
          else if (p.zClass === 'spitter') { ctx.strokeStyle = '#ba68c8'; ctx.lineWidth = 2; }
          else if (p.zClass === 'stalker') { ctx.strokeStyle = '#9c27b0'; ctx.lineWidth = 2; }
          else if (p.zClass === 'bomber') { ctx.strokeStyle = '#f44336'; ctx.lineWidth = 2.5; }
          else { ctx.strokeStyle = '#e57373'; ctx.lineWidth = 1; }
          ctx.globalAlpha = .9; ctx.beginPath(); ctx.arc(sp.x,sp.y, (p.zClass==='brute')?14:13, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
          if (p.boosted){ ctx.strokeStyle = '#64b5f6'; ctx.globalAlpha=.8; ctx.beginPath(); ctx.arc(sp.x,sp.y,16,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
          ctx.fillStyle = '#e57373'; ctx.globalAlpha = .95; ctx.fillText(p.name, sp.x, sp.y - 16);
          // Emote above zombie head for 5s
          if (p.emote && (p.emoteUntil||0) > Date.now()){
            ctx.font = '18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
            ctx.globalAlpha = 1;
            ctx.fillText(p.emote, sp.x, sp.y - 32);
            ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          }
        }
        // Bat swing arc visual (short-lived)
        const swingAge = (state.t||Date.now()) - (p.meleeAt||0);
        if (swingAge >= 0 && swingAge < 220) {
          const alpha = 1 - (swingAge / 220);
          const ang = Math.atan2(p.meleeDirY||0, p.meleeDirX||1);
          const span = Math.PI / 1.8; // ~100°
          const r0 = 14, r1 = 34;
          ctx.save();
          ctx.globalAlpha = Math.max(0, alpha*0.9);
          ctx.fillStyle = 'rgba(255,213,79,0.35)';
          ctx.beginPath();
          ctx.moveTo(sp.x + Math.cos(ang - span/2)*r0, sp.y + Math.sin(ang - span/2)*r0);
          ctx.arc(sp.x, sp.y, r1, ang - span/2, ang + span/2);
          ctx.lineTo(sp.x + Math.cos(ang + span/2)*r0, sp.y + Math.sin(ang + span/2)*r0);
          ctx.arc(sp.x, sp.y, r0, ang + span/2, ang - span/2, true);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }

      ctx.restore();

      // Crosshair (screen-space, centered at aim cursor)
      {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
        ctx.setTransform(dpr,0,0,dpr,0,0);
        const cx = input.aimX || 0; const cy = input.aimY || 0;
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#cfd8dc';
        // Outer ring
        ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.stroke();
        // Gap cross
        const arm = 14, gap = 6, len = 9;
        // left
        ctx.beginPath(); ctx.moveTo(cx - arm, cy); ctx.lineTo(cx - gap, cy); ctx.stroke();
        // right
        ctx.beginPath(); ctx.moveTo(cx + gap, cy); ctx.lineTo(cx + arm, cy); ctx.stroke();
        // top
        ctx.beginPath(); ctx.moveTo(cx, cy - arm); ctx.lineTo(cx, cy - gap); ctx.stroke();
        // bottom
        ctx.beginPath(); ctx.moveTo(cx, cy + gap); ctx.lineTo(cx, cy + arm); ctx.stroke();
        // Subtle center dot
        ctx.globalAlpha = 0.7; ctx.fillStyle = '#cfd8dc'; ctx.beginPath(); ctx.arc(cx, cy, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // Extractions removed

      // Mini-map (bottom-right)
      drawMiniMap();

      // Screen border on top
      ctx.save(); ctx.lineWidth = 2; ctx.strokeStyle = '#808080'; ctx.strokeRect(1,1,rect.width-2,rect.height-2); ctx.restore();
      // Class legend (bottom-right above minimap)
      drawClassLegend();
    }

    function updatePlayerList(players){
      playersEl.innerHTML = players.map(p=>`<span class="pill ${p.role}">${p.role==='streamer'?'🟢':'🧟'} ${p.name}${p.role==='streamer'?' · '+p.score:''}</span>`).join(' ');
    }

    function updateTimer(seconds) {
      const min = Math.floor(seconds / 60);
      const sec = seconds % 60;
      timerEl.textContent = `Time: ${min}:${sec.toString().padStart(2, '0')}`;
    }

    // Animation loop + nerd stats
    let last = performance.now();
    const fpsSamples = [];
    const fpsWindow = 120; // ~2s at 60fps
    let lastNerdUpdate = 0;
    function loop(){
      const now=performance.now(); const dt=now-last; last=now; draw(dt);
      const fps = dt>0 ? 1000/dt : 0; fpsSamples.push(fps); if (fpsSamples.length>fpsWindow) fpsSamples.shift();
      if (now - lastStateRateAt >= 1000){ statesPerSec = stateMsgCount; stateMsgCount = 0; lastStateRateAt = now; }
      if (nerdOn && now - lastNerdUpdate > 250){
        const avgFps = fpsSamples.length ? (fpsSamples.reduce((a,b)=>a+b,0)/fpsSamples.length) : 0;
        const minFps = fpsSamples.length ? Math.min(...fpsSamples) : 0;
        const maxFps = fpsSamples.length ? Math.max(...fpsSamples) : 0;
        const lat = latency ? latency.getLatencyStats() : { avg:0, min:0, max:0, jitter:0 };
        const players = state.players?.length||0;
        const zombies = state.players?.filter(p=>p.role==='zombie').length||0;
        const bullets = state.bullets?.length||0;
        const pickups = state.pickups?.length||0;
        const walls = state.walls?.length||0;
        const wsBuf = ws && ws.bufferedAmount || 0;
        nerdPanel.innerHTML = `
          <div><strong>Nerd Stats</strong></div>
          <div>FPS: ${avgFps.toFixed(1)} (min ${minFps.toFixed(0)} max ${maxFps.toFixed(0)})</div>
          <div>Latency: ${lat.avg.toFixed(1)} ms (min ${lat.min.toFixed(0)} max ${lat.max.toFixed(0)}) jitter ${lat.jitter.toFixed(1)} ms</div>
          <div>States/s: ${statesPerSec.toFixed(0)}</div>
          <div>Entities: players ${players} (z ${zombies}) bullets ${bullets} pickups ${pickups} walls ${walls}</div>
          <div>WS buf: ${wsBuf}</div>
        `;
        lastNerdUpdate = now;
      }
      requestAnimationFrame(loop);
    }
    loop();

    // Fullscreen
    document.getElementById('fullscreen').onclick = async () => {
      if (!document.fullscreenElement) { await document.documentElement.requestFullscreen().catch(()=>{}); }
      else { await document.exitFullscreen().catch(()=>{}); }
    };

    function drawMiniMap(){
      const rect = c.getBoundingClientRect();
      const mmSize = 160; const pad = 12; const cx = rect.width - pad - mmSize/2; const cy = rect.height - pad - mmSize/2;
      const R = (mmSize/2) - 4;
      const W = (state.arena && state.arena.w) || 960; const H = (state.arena && state.arena.h) || 540;
      // Zoom in and center around local player for context
      const meMM = state.players && state.players.find(p=>p.id===playerId);
      const centerX = meMM ? meMM.x : W/2;
      const centerY = meMM ? meMM.y : H/2;
      const MM_ZOOM = 1.6;
      const scale = (2*R*MM_ZOOM) / Math.max(W, H);
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = 'rgba(18,20,24,.86)';
      ctx.beginPath(); ctx.arc(cx, cy, mmSize/2, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth = 2; ctx.stroke();
      ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.clip();
      if (state.walls) {
        ctx.strokeStyle = 'rgba(255,255,255,.25)'; ctx.lineWidth = 1;
        for (const w of state.walls){
          const x = cx + (w.x - centerX) * scale; const y = cy + (w.y - centerY) * scale;
          const ww = w.w * scale; const hh = w.h * scale;
          ctx.strokeRect(x, y, ww, hh);
        }
      }
      // Extractions removed
      if (state.players){
        for (const p of state.players){
          const px = cx + (p.x - centerX) * scale; const py = cy + (p.y - centerY) * scale;
          const r = p.role==='streamer' ? 3 : 2;
          ctx.beginPath();
          ctx.fillStyle = p.role==='streamer' ? '#4caf50' : (p.alive ? '#ef5350' : 'rgba(239,83,80,.4)');
          ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
          if (p.id === playerId) { ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1; ctx.stroke(); }
        }
      }
      ctx.restore(); ctx.restore();
    }

    function drawTiles(viewX, viewY, viewW, viewH){
      const m = gameMap; if (!m) return; const sz = m.size;
      const theme = m.theme||'dungeon';
      const pal = theme==='dungeon' ? {
        floor:'#0e1115', wall:'#2a2f36', pit:'#0b0d11', water:'#0d1b2a', edge:'#9aa4b2', propCrate:'#6d4c41', propPillar:'#b0bec5', propBone:'#8d6e63'
      } : theme==='cave' ? {
        floor:'#0d1113', wall:'#263238', pit:'#0a0e10', water:'#0b1f2d', edge:'#90a4ae', propCrate:'#546e7a', propPillar:'#90caf9', propBone:'#80cbc4'
      } : {
        floor:'#111416', wall:'#3c4148', pit:'#0b0c0d', water:'#14212e', edge:'#b0bec5', propCrate:'#90a4ae', propPillar:'#cfd8dc', propBone:'#b0bec5'
      };
      const sx = Math.max(0, Math.floor(viewX/sz)-1), sy = Math.max(0, Math.floor(viewY/sz)-1);
      const ex = Math.min(m.w-1, Math.ceil((viewX+viewW)/sz)+1), ey = Math.min(m.h-1, Math.ceil((viewY+viewH)/sz)+1);
      // Floor
      for (let y=sy;y<=ey;y++){
        for (let x=sx;x<=ex;x++){
          const id = m.tiles[y*m.w + x];
          if (id===0){ ctx.fillStyle = pal.floor; ctx.fillRect(x*sz, y*sz, sz, sz); ctx.globalAlpha=.06; ctx.fillStyle='#ffffff'; ctx.fillRect(x*sz+4,y*sz+4,3,3); ctx.globalAlpha=1; }
        }
      }
      // Pits/Water
      for (let y=sy;y<=ey;y++) for (let x=sx;x<=ex;x++){ const id=m.tiles[y*m.w+x]; if (id===2){ ctx.fillStyle='#101318'; ctx.fillRect(x*sz,y*sz,sz,sz);} if (id===3){ ctx.fillStyle='#0d1b2a'; ctx.fillRect(x*sz,y*sz,sz,sz);} }
      // Walls outline
      const isWall=(ix,iy)=> ix>=0&&iy>=0&&ix<m.w&&iy<m.h && m.tiles[iy*m.w+ix]===1;
      ctx.fillStyle = pal.wall;
      for (let y=sy;y<=ey;y++){
        for (let x=sx;x<=ex;x++){
          if (!isWall(x,y)) continue; const px=x*sz, py=y*sz; ctx.fillRect(px,py,sz,sz);
          ctx.strokeStyle=pal.edge; ctx.lineWidth=1; ctx.globalAlpha=.15;
          if (!isWall(x,y-1)){ ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px+sz,py); ctx.stroke(); }
          if (!isWall(x+1,y)){ ctx.beginPath(); ctx.moveTo(px+sz,py); ctx.lineTo(px+sz,py+sz); ctx.stroke(); }
          if (!isWall(x,y+1)){ ctx.beginPath(); ctx.moveTo(px,py+sz); ctx.lineTo(px+sz,py+sz); ctx.stroke(); }
          if (!isWall(x-1,y)){ ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px,py+sz); ctx.stroke(); }
          ctx.globalAlpha=1;
        }
      }
      // Props
      for (const p of (m.props||[])){
        const px=p.x*sz, py=p.y*sz; ctx.save(); ctx.globalAlpha=.9; ctx.fillStyle=p.type==='crate'?pal.propCrate:p.type==='pillar'?pal.propPillar:pal.propBone; ctx.fillRect(px+4,py+4,sz-8,sz-8); ctx.restore();
      }
      // Lights
      for (const l of (m.lights||[])){
        const cx=l.x*sz+sz/2, cy=l.y*sz+sz/2, rr=l.r*sz; const g=ctx.createRadialGradient(cx,cy,2,cx,cy,rr); g.addColorStop(0,`rgba(255,255,200,${0.35*l.a})`); g.addColorStop(1,'rgba(255,255,200,0)'); ctx.save(); ctx.fillStyle=g; ctx.fillRect(cx-rr,cy-rr,rr*2,rr*2); ctx.restore();
      }
    }

    // Simple lighting overlay for zombies — lighter than streamer
    function drawLighting(viewX, viewY, viewW, viewH, me){
      ctx.save(); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(viewX,viewY,viewW,viewH); ctx.globalCompositeOperation='destination-out';
      const add=(x,y,r,a=1)=>{ const g=ctx.createRadialGradient(x,y,2,x,y,r); g.addColorStop(0,`rgba(255,255,220,${0.6*a})`); g.addColorStop(1,'rgba(255,255,220,0)'); ctx.fillStyle=g; ctx.fillRect(x-r,y-r,r*2,r*2); };
      if (gameMap){ const sz=gameMap.size; for(const l of (gameMap.lights||[])) add(l.x*sz+sz/2,l.y*sz+sz/2,(l.r||6)*sz,l.a||0.2); }
      if (me) add(me.x, me.y, 110, 1);
      for (const b of (state.bullets||[])) add(b.x,b.y,22,.6);
      ctx.restore();
    }

    function drawClassLegend(){
      const rect = c.getBoundingClientRect();
      const pad = 12;
      const boxW = 160, boxH = 114;
      const x = rect.width - boxW - pad;
      const y = rect.height - 160 - boxH - pad;
      ctx.save();
      ctx.globalAlpha = .95; ctx.fillStyle = 'rgba(18,20,24,.86)'; ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.roundRect ? ctx.roundRect(x,y,boxW,boxH,10) : (ctx.moveTo(x+10,y),ctx.lineTo(x+boxW-10,y),ctx.quadraticCurveTo(x+boxW,y,x+boxW,y+10),ctx.lineTo(x+boxW,y+boxH-10),ctx.quadraticCurveTo(x+boxW,y+boxH,x+boxW-10,y+boxH),ctx.lineTo(x+10,y+boxH),ctx.quadraticCurveTo(x,y+boxH,x,y+boxH-10),ctx.lineTo(x,y+10),ctx.quadraticCurveTo(x,y,x+10,y));
      ctx.fill(); ctx.stroke();
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif'; ctx.fillStyle = '#cfd8dc';
      const rows = [
        { label: 'Runner', color: '#64b5f6', lw: 1.5 },
        { label: 'Brute', color: '#ffa726', lw: 3 },
        { label: 'Spitter', color: '#ba68c8', lw: 2 },
        { label: 'Stalker', color: '#9c27b0', lw: 2 },
        { label: 'Bomber', color: '#f44336', lw: 2.5 },
      ];
      let yy = y + 18;
      for (const r of rows){
        ctx.save(); ctx.strokeStyle = r.color; ctx.lineWidth = r.lw; ctx.beginPath(); ctx.arc(x+14, yy-4, 6, 0, Math.PI*2); ctx.stroke(); ctx.restore();
        ctx.fillText(r.label, x+28, yy-2);
        yy += 22;
      }
      ctx.restore();
    }
  </script>
</body>
</html>
</file>

<file path="public/styles.css">
:root {
  color-scheme: dark;

  --bg: #0a0b0f;

  --bg-2: #0b0c10;

  --panel: #121418;

  --panel-2: #161920;

  --border: #252a33;

  --muted: #98a2b3;

  --text: #e7eaee;

  /* Accent palette */

  --green: #4caf50;

  --red: #ef5350;

  --blue: #60a5fa;

  --amber: #ffd54f;

  --orange: #ffa726;

  --teal: #2dd4bf;

  --pink: #f472b6;

  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
    Helvetica, Arial, sans-serif;
}

* {
  box-sizing: border-box;
}

html,
body {
  height: 100dvh;
}

body {
  margin: 0;

  min-height: 100dvh;

  background: radial-gradient(
      1200px 600px at 20% -10%,
      rgba(45, 212, 191, 0.12),
      transparent 60%
    ),
    radial-gradient(
      1000px 600px at 110% 10%,
      rgba(244, 114, 182, 0.1),
      transparent 60%
    ),
    linear-gradient(180deg, var(--bg) 0%, #090a0e 65%, #08090c 100%);

  color: var(--text);

  letter-spacing: 0.2px;
}

/* ——— Topbar ——— */

.topbar {
  position: fixed;

  inset: 0 0 auto 0;

  display: grid;

  grid-template-columns: auto 1fr auto;

  gap: 12px;

  align-items: center;

  padding: 10px 14px;

  background: linear-gradient(
    180deg,
    rgba(12, 14, 18, 0.75),
    rgba(12, 14, 18, 0.45) 60%,
    rgba(12, 14, 18, 0)
  );

  -webkit-backdrop-filter: blur(10px);

  backdrop-filter: blur(10px);

  border-bottom: 1px solid rgba(255, 255, 255, 0.04);

  z-index: 10;
}

.brand {
  font-weight: 700;

  font-size: 15px;

  letter-spacing: 0.3px;

  background: linear-gradient(90deg, #fff, #9db2ff 40%, #9ef1d1 80%);

  -webkit-background-clip: text;

  background-clip: text;

  color: transparent;

  opacity: 0.9;
}

.middle-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
}

.right-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

/* ——— App Layout ——— */

.app {
  position: relative;

  display: grid;

  grid-template-columns: 1fr 300px;

  gap: 16px;

  padding: 72px 20px 12px; /* match fixed topbar height space */

  height: calc(100dvh - 72px);

  overflow: hidden;

  align-items: start;
}

.main {
  min-width: 0;
  height: 100%;
}

.stage {
  height: 100%;
}

.sidebar {
  display: flex;
  flex-direction: column;
  gap: 12px;
  min-width: 0;
  height: 100%;
  overflow: auto;
}

@media (max-width: 1100px) {
  .app {
    grid-template-columns: 1fr;
  }

  .sidebar {
    order: -1;
  }
}

/* ——— Cards ——— */

.card {
  background: linear-gradient(180deg, var(--panel), var(--panel-2));

  border: 1px solid var(--border);

  border-radius: 14px;

  padding: 12px;

  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
}

.card-title {
  display: flex;
  align-items: center;
  justify-content: space-between;

  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--muted);

  margin-bottom: 8px;
}

/* ——— Panels / rows ——— */

.row {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}

.row.small {
  font-size: 12px;
  opacity: 0.9;
}

.tip {
  opacity: 0.75;
}

/* Utility */

.hidden {
  display: none !important;
}

/* ——— Nerd stats overlay ——— */

#nerdPanel.nerd-panel {
  position: fixed;

  bottom: 12px;

  left: 12px;

  z-index: 1000;

  padding: 8px 10px;

  border-radius: 12px;

  border: 1px solid var(--border);

  background: linear-gradient(180deg, var(--panel), var(--panel-2));

  box-shadow: 0 8px 18px rgba(0, 0, 0, 0.28);

  font-size: 12px;

  color: var(--muted);

  pointer-events: none;

  white-space: nowrap;
}

.right-controls #nerdToggle.active {
  color: var(--teal);
  border-color: color-mix(in oklab, var(--teal) 35%, transparent);
}

/* ——— Chat + Emotes ——— */

#chatInput {
  width: 100%;
}

.chat-messages {
  width: 100%;

  max-height: 200px;

  min-height: 120px;

  overflow-y: auto;

  padding: 8px 10px;

  border: 1px solid var(--border);

  border-radius: 12px;

  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.02),
    rgba(0, 0, 0, 0.14)
  );

  box-shadow: 0 1px 0 rgba(255, 255, 255, 0.04) inset;
}

#emotes {
  gap: 4px;
}

#emotes .emote {
  padding: 4px 8px;

  font-size: 16px;

  line-height: 1;

  border-radius: 8px;
}

/* New emote bar id for redesigned layout */

#emoteBar {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

#emoteBar .emote {
  padding: 6px 10px;

  font-size: 18px;

  line-height: 1;

  border-radius: 8px;
}

/* ——— Lists ——— */

.pill-list {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

/* ——— Inputs / buttons ——— */

button,
input {
  padding: 9px 12px;

  border-radius: 12px;

  border: 1px solid var(--border);

  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.04),
    rgba(0, 0, 0, 0.08)
  );

  color: var(--text);

  outline: none;
}

input {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.02),
    rgba(0, 0, 0, 0.12)
  );
}

@keyframes ammoPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.5); color: var(--amber); }
  100% { transform: scale(1); }
}

@keyframes damagePulse {
  0% { transform: scale(1); color: var(--red); }
  50% { transform: scale(1.5); color: #ff9999; }
  100% { transform: scale(1); color: var(--red); }
}

.ammo-pulse {
  animation: ammoPulse 0.3s ease-out;
  display: inline-block;
}

.hp-damage-pulse {
  animation: damagePulse 0.4s ease-out;
  display: inline-block;
}

.hud-hp-damage-pulse {
  animation: damagePulse 0.4s ease-out;
  display: inline-block;
}

.mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  width: 100%;
}

button {
  cursor: pointer;

  transition: transform 0.06s ease, box-shadow 0.2s ease, background 0.2s ease,
    border-color 0.2s ease;

  box-shadow: 0 1px 0 rgba(255, 255, 255, 0.06) inset,
    0 8px 18px rgba(0, 0, 0, 0.28);
}

button:hover {
  border-color: rgba(255, 255, 255, 0.18);

  box-shadow: 0 1px 0 rgba(255, 255, 255, 0.08) inset,
    0 10px 22px rgba(0, 0, 0, 0.3), 0 0 0 3px rgba(158, 241, 209, 0.08);
}

button:active {
  transform: translateY(1px);
}

button[disabled] {
  opacity: 0.5;
  cursor: default;
}

/* Weapon state styles */

.weapon {
  opacity: 0.95;
}

.weapon.equipped {
  border-color: color-mix(in oklab, var(--teal) 35%, transparent);
  color: var(--teal);
}

.weapon.owned {
  border-color: rgba(255, 255, 255, 0.18);
}

.weapon.locked {
  opacity: 0.6;
}

/* ——— Badges / pills ——— */

.badge {
  padding: 5px 9px;

  border-radius: 999px;

  border: 1px solid var(--border);

  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.02),
    rgba(0, 0, 0, 0.14)
  );

  color: var(--muted);
}

#status[data-state="connected"] {
  color: var(--teal);
  border-color: color-mix(in oklab, var(--teal) 35%, transparent);
}

#status[data-state="disconnected"] {
  color: #c3c7d1;
  opacity: 0.85;
}

.pill {
  position: relative;

  padding: 4px 10px 4px 22px;

  border-radius: 999px;

  border: 1px solid var(--border);

  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.02),
    rgba(0, 0, 0, 0.12)
  );
}

.pill::before {
  content: "";

  position: absolute;

  left: 8px;
  top: 50%;
  transform: translateY(-50%);

  width: 8px;
  height: 8px;
  border-radius: 999px;

  background: #888;

  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.06) inset;
}

.pill.streamer {
  color: var(--green);
  border-color: color-mix(in oklab, var(--green) 35%, transparent);
}

.pill.streamer::before {
  background: var(--green);
}

.pill.zombie {
  color: var(--red);
  border-color: color-mix(in oklab, var(--red) 35%, transparent);
}

.pill.zombie::before {
  background: var(--red);
}

/* ——— Canvas / stage ——— */

.stage {
  position: relative;
  display: grid;
  place-items: center;
  padding: 0;
  /* Ensure stage contains positioned children */
  contain: layout;
}

canvas.arena {
  position: relative;

  /* size is controlled by JS to fit container while preserving AR */

  outline: 1px solid rgba(255, 255, 255, 0.04);

  border-radius: 18px;

  background: radial-gradient(
        transparent 0 7px,
        rgba(255, 255, 255, 0.06) 8px 8px
      )
      0 0 / 32px 32px,
    linear-gradient(180deg, #1a1f27, #11161c);

  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03),
    0 12px 36px rgba(0, 0, 0, 0.55);

  animation: grid-pan 26s linear infinite;
}

/* Hide system cursor when hovering the game canvas */

canvas.arena:hover {
  cursor: none;
}

canvas.arena:focus {
  outline: none;
}

canvas.arena::after {
  content: "";

  position: absolute;
  inset: 0;

  border-radius: inherit;

  pointer-events: none;

  background: radial-gradient(
      80% 60% at 50% 40%,
      transparent,
      rgba(0, 0, 0, 0.22)
    ),
    radial-gradient(
      circle at 50% 50%,
      rgba(255, 255, 255, 0.06),
      transparent 40%
    );

  mix-blend-mode: overlay;

  opacity: 0.8;
}

@keyframes grid-pan {
  0% {
    background-position: 0 0, 0 0;
  }

  100% {
    background-position: 64px 64px, 0 0;
  }
}

body.connected canvas.arena {
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03),
    0 12px 36px rgba(0, 0, 0, 0.55), 0 0 22px rgba(45, 212, 191, 0.22);
}

/* ——— Hit flash / toast ——— */

.hit-flash {
  position: fixed;
  inset: 0;
  pointer-events: none;

  background: radial-gradient(
    circle at center,
    rgba(239, 83, 80, 0.18),
    transparent 60%
  );

  opacity: 0;
  transition: opacity 0.22s ease;
}

.hit-flash.show {
  opacity: 1;
}

.toast {
  position: fixed;
  bottom: 18px;
  left: 50%;

  transform: translateX(-50%);

  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.02),
    rgba(0, 0, 0, 0.18)
  );

  color: var(--text);

  padding: 10px 14px;

  border: 1px solid var(--border);

  border-radius: 12px;

  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);

  opacity: 0;
  pointer-events: none;

  transition: opacity 0.2s ease, transform 0.2s ease;
}

.toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(-4px);
}

/* Limit scrolling only on gameplay pages */

body.game {
  overflow: hidden;
}

/* ??? HUD overlay ??? */

.hud-layer {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 2;
  /* Position relative to canvas bounds */
  width: 100%;
  height: 100%;
}

.hud-stack {
  position: absolute;

  display: flex;

  flex-direction: column;

  gap: 14px;

  pointer-events: none;
}

.hud-top-right {
  top: 20px;
  right: 20px;
  align-items: flex-end;
  max-width: min(320px, 30vw);
}

.hud-top-left {
  top: 20px;
  left: 20px;
  align-items: flex-start;
  max-width: min(360px, 36vw);
}

.hud-bottom-left {
  bottom: 20px;
  left: 20px;
  align-items: flex-start;
  max-width: min(360px, 36vw);
}

.hud-bottom-right {
  bottom: 20px;
  right: 20px;
  align-items: flex-end;
  max-width: min(360px, 36vw);
}

.hud-middle-left {
  top: 50%;
  left: 20px;
  transform: translateY(-50%);
  align-items: flex-start;
  max-width: min(360px, 36vw);
}

.hud-panel {
  pointer-events: auto;

  width: clamp(240px, 28vw, 320px);

  display: flex;

  flex-direction: column;

  gap: 10px;

  padding: 16px 18px;

  border-radius: 20px;

  border: 1px solid var(--border);

  background: linear-gradient(
    180deg,
    rgba(14, 16, 20, 0.94),
    rgba(9, 11, 15, 0.84)
  );

  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.46);
}

/* Segmented Health Bar */
.health-bar-container {
  margin-bottom: 8px;
  pointer-events: none;
  display: flex;
  align-items: center;
  gap: 8px;
}

.health-icon {
  font-size: 18px;
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
  animation: healthIconPulse 2s ease-in-out infinite;
}

@keyframes healthIconPulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
}

.health-bar {
  position: relative;
  width: 200px;
  height: 20px;
  border-radius: 10px;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.6);
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
}

.health-bar-bg {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, 
    rgba(40, 40, 40, 0.8) 0%, 
    rgba(30, 30, 30, 0.8) 100%
  );
}

.health-segments {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  z-index: 1;
}

.health-segment {
  flex: 1;
  margin-right: 1px;
  background: linear-gradient(90deg, 
    #4a9eff 0%, 
    #6bb6ff 50%, 
    #4a9eff 100%
  );
  border-radius: 2px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
}

.health-segment:last-child {
  margin-right: 0;
}

.health-segment.depleting {
  animation: healthDeplete 0.4s ease-out forwards;
}

.health-segment.filling {
  animation: healthFill 0.4s ease-out forwards;
}

.health-segment.low-health {
  background: linear-gradient(90deg, 
    #ff6b4a 0%, 
    #ff8a6b 50%, 
    #ff6b4a 100%
  );
}

.health-segment.critical-health {
  background: linear-gradient(90deg, 
    #ff4a4a 0%, 
    #ff6b6b 50%, 
    #ff4a4a 100%
  );
  animation: criticalPulse 1s ease-in-out infinite alternate;
}

.health-segment::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255, 255, 255, 0.4) 50%, 
    transparent 100%
  );
  transition: left 0.6s ease-out;
}

.health-segment.filling::before {
  left: 100%;
}

@keyframes healthDeplete {
  0% {
    transform: scaleX(1);
    opacity: 1;
  }
  50% {
    transform: scaleX(0.8);
    opacity: 0.7;
  }
  100% {
    transform: scaleX(0);
    opacity: 0;
  }
}

@keyframes healthFill {
  0% {
    transform: scaleX(0);
    opacity: 0;
  }
  50% {
    transform: scaleX(1.1);
    opacity: 0.8;
  }
  100% {
    transform: scaleX(1);
    opacity: 1;
  }
}

@keyframes criticalPulse {
  0% {
    box-shadow: inset 0 0 5px rgba(255, 74, 74, 0.5);
  }
  100% {
    box-shadow: inset 0 0 15px rgba(255, 74, 74, 0.8);
  }
}

.hud-panel-title {
  font-size: 11px;

  text-transform: uppercase;

  letter-spacing: 0.6px;

  color: var(--muted);
}

#upgradeOverlay .choices {
  display: flex;

  flex-direction: column;

  gap: 8px;

  max-height: 220px;

  overflow-y: auto;

  padding-right: 4px;
}

#upgradeOverlay .choice {
  text-align: left;

  white-space: normal;

  padding: 10px 12px;

  border-radius: 12px;

  font-size: 13px;

  line-height: 1.4;
}

#upgradeOverlay .tip {
  font-size: 12px;

  color: var(--muted);

  text-align: center;

  opacity: 0.85;
}

.hud-buff-list {
  display: flex;

  flex-direction: column;

  gap: 6px;

  max-height: 280px;

  overflow-y: auto;

  padding-right: 4px;
}

.hud-buff {
  display: flex;

  justify-content: space-between;

  align-items: center;

  gap: 12px;

  font-size: 12px;

  border: 1px solid var(--border);

  border-radius: 10px;

  padding: 6px 8px;

  background: rgba(13, 15, 20, 0.72);

  color: var(--muted);
}

.hud-buff .stacks {
  font-weight: 600;

  color: var(--text);

  font-variant-numeric: tabular-nums;
}

.hud-buff[data-rarity="uncommon"] {
  border-color: color-mix(in oklab, var(--teal) 40%, transparent);
  color: var(--teal);
}

.hud-buff[data-rarity="rare"] {
  border-color: color-mix(in oklab, var(--blue) 45%, transparent);
  color: var(--blue);
}

.hud-buff[data-rarity="epic"] {
  border-color: color-mix(in oklab, var(--pink) 45%, transparent);
  color: var(--pink);
}

.hud-buff[data-rarity="legendary"] {
  border-color: color-mix(in oklab, var(--amber) 60%, transparent);
  color: var(--amber);
}

.hud-pill {
  pointer-events: none;

  display: flex;

  flex-wrap: wrap;

  justify-content: flex-start;

  gap: 12px;

  align-items: center;

  border-radius: 999px;

  border: 1px solid var(--border);

  padding: 12px 18px;

  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.05),
    rgba(0, 0, 0, 0.36)
  );

  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.42);

  font-size: 13px;

  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
}

.hud-pill span {
  display: flex;

  align-items: center;

  gap: 4px;

  color: var(--muted);
}

.hud-pill strong {
  color: var(--text);

  font-weight: 600;

  font-variant-numeric: tabular-nums;
}

.hud-pill--right {
  justify-content: flex-end;
  text-align: right;
}

/* Death Screen */
.death-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: deathScreenFadeIn 0.5s ease-out;
}

.death-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    135deg,
    rgba(0, 0, 0, 0.95) 0%,
    rgba(20, 0, 0, 0.9) 50%,
    rgba(0, 0, 0, 0.95) 100%
  );
  backdrop-filter: blur(8px);
}

.death-content {
  position: relative;
  background: linear-gradient(
    145deg,
    rgba(15, 15, 20, 0.95) 0%,
    rgba(25, 15, 15, 0.9) 100%
  );
  border: 2px solid rgba(255, 100, 100, 0.3);
  border-radius: 16px;
  padding: 32px;
  max-width: 90vw;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 
    0 20px 60px rgba(0, 0, 0, 0.8),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  animation: deathContentSlideIn 0.6s ease-out 0.2s both;
}

.death-header {
  text-align: center;
  margin-bottom: 32px;
}

.death-title {
  font-size: 3rem;
  font-weight: bold;
  color: #ff6b6b;
  margin: 0 0 8px 0;
  text-shadow: 
    0 0 20px rgba(255, 107, 107, 0.5),
    0 4px 8px rgba(0, 0, 0, 0.8);
  animation: deathTitlePulse 2s ease-in-out infinite;
}

.death-subtitle {
  font-size: 1.2rem;
  color: #ccc;
  font-weight: 300;
}

.death-stats {
  margin-bottom: 32px;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 24px;
  margin-bottom: 32px;
}

.stats-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 24px;
  margin-bottom: 24px;
}

@media (max-width: 768px) {
  .stats-row {
    grid-template-columns: 1fr;
  }
}

.stat-category {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  padding: 20px;
}

.stat-category h3 {
  color: #4a9eff;
  margin: 0 0 16px 0;
  font-size: 1.1rem;
  font-weight: 600;
  border-bottom: 1px solid rgba(74, 158, 255, 0.3);
  padding-bottom: 8px;
}

.stat-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.stat-item:last-child {
  border-bottom: none;
}

.stat-label {
  color: #bbb;
  font-size: 0.95rem;
}

.stat-value {
  color: #fff;
  font-weight: 600;
  font-size: 1rem;
}

.upgrades-section {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 24px;
}

.upgrades-section h3 {
  color: #ffd700;
  margin: 0 0 16px 0;
  font-size: 1.1rem;
  font-weight: 600;
  border-bottom: 1px solid rgba(255, 215, 0, 0.3);
  padding-bottom: 8px;
}

.final-upgrades {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.upgrade-item {
  background: linear-gradient(135deg, #4a9eff, #6bb6ff);
  color: white;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 0.85rem;
  font-weight: 500;
  box-shadow: 0 2px 8px rgba(74, 158, 255, 0.3);
}

.upgrade-item.rare {
  background: linear-gradient(135deg, #9c27b0, #ba68c8);
  box-shadow: 0 2px 8px rgba(156, 39, 176, 0.3);
}

.upgrade-item.epic {
  background: linear-gradient(135deg, #ff9800, #ffb74d);
  box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
}

.upgrade-item.legendary {
  background: linear-gradient(135deg, #f44336, #ef5350);
  box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
}

.no-upgrades {
  color: #888;
  font-style: italic;
  text-align: center;
  padding: 20px;
}

.enemy-stats {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.enemy-type {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.enemy-name {
  color: #ccc;
  font-size: 0.9rem;
}

.enemy-count {
  color: #ff6b6b;
  font-weight: 600;
  font-size: 1rem;
}

.death-actions {
  display: flex;
  gap: 16px;
  justify-content: center;
  flex-wrap: wrap;
}

.death-btn {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 160px;
}

.death-btn-primary {
  background: linear-gradient(135deg, #4a9eff, #6bb6ff);
  color: white;
  box-shadow: 0 4px 16px rgba(74, 158, 255, 0.3);
}

.death-btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(74, 158, 255, 0.4);
}

.death-btn-secondary {
  background: linear-gradient(135deg, #666, #888);
  color: white;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
}

.death-btn-secondary:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
}

@keyframes deathScreenFadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes deathContentSlideIn {
  from {
    opacity: 0;
    transform: translateY(30px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@keyframes deathTitlePulse {
  0%, 100% {
    text-shadow: 
      0 0 20px rgba(255, 107, 107, 0.5),
      0 4px 8px rgba(0, 0, 0, 0.8);
  }
  50% {
    text-shadow: 
      0 0 30px rgba(255, 107, 107, 0.8),
      0 4px 8px rgba(0, 0, 0, 0.8);
  }
}
</file>

<file path="public/streamer.html">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Arena Shooter Streamer</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body class="game">
    <div class="topbar">
      <div class="brand">Arena Shooter</div>
      <div class="middle-controls">
        <span class="badge" id="status" data-state="disconnected"
          >disconnected</span
        >
      </div>
      <div class="right-controls">
        <button id="fullscreen">Fullscreen</button>
        <button id="nerdToggle">Nerd Stats</button>
      </div>
    </div>

    <div class="app">
      <div class="main">
        <div class="stage">
          <div class="hud-layer">
            <div class="hud-stack hud-top-right">
              <div class="hud-pill hud-pill--right">
                <span>Score: <strong id="hudScore">0</strong></span>
                <span>Banked: <strong id="hudBanked">0</strong></span>
              </div>
            </div>
            <div class="hud-stack hud-middle-left">
              <div id="upgradeOverlay" class="hud-panel hidden">
                <div class="hud-panel-title mono">Level Up! Choose an upgrade</div>
                <div class="choices">
                  <button class="choice" data-idx="0"></button>
                  <button class="choice" data-idx="1"></button>
                  <button class="choice" data-idx="2"></button>
                </div>
                <div class="tip mono">Press 1 / 2 / 3</div>
              </div>
              <div id="buffPanel" class="hud-panel hidden">
                <div class="hud-panel-title">Current Upgrades</div>
                <div class="hud-buff-list" id="buffList"></div>
              </div>
            </div>
            <div class="hud-stack hud-top-left">
              <div class="hud-pill">
                <span>Level: <strong id="hudLevel">0</strong></span>
                <span>XP: <strong id="hudXp">0/0</strong></span>
              </div>
            </div>
            <div class="hud-stack hud-bottom-left">
              <div class="health-bar-container">
                <div class="health-icon">❤️</div>
                <div class="health-bar">
                  <div class="health-segments" id="healthSegments"></div>
                  <div class="health-bar-bg"></div>
                </div>
              </div>
              <div class="hud-pill">
                <span>Weapon: <strong id="hudWeapon">--</strong></span>
                <span>Ammo: <strong id="hudAmmo">0</strong></span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <aside class="sidebar">
        <div class="card">
          <div class="card-title">Session</div>
          <div class="row">
            <button id="newRoom">Create Room</button>
            <button id="toggleChat" disabled>Disable Chat</button>
          </div>
          <div class="row">
            <input
              id="roomLink"
              class="mono"
              placeholder="Join link"
              readonly
            />
            <button id="copy" disabled>Copy Link</button>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Weapons</div>
          <div class="row">
            <button class="weapon" id="btnPistol" data-weapon="pistol">
              Pistol (1)
            </button>
            <button class="weapon" id="btnSmg" data-weapon="smg">
              SMG (2)
            </button>
            <button class="weapon" id="btnShotgun" data-weapon="shotgun">
              Shotgun (3)
            </button>
          </div>
          <div class="row">
            <button id="buyShotgun" title="Costs 300 banked" disabled>
              Unlock Shotgun (4) • 300
            </button>
            <button id="buySmg" title="Costs 300 banked" disabled>
              Unlock SMG (5) • 300
            </button>
          </div>
          <div class="tip">
            Right‑click or Q to swing bat. Pistol is free. Unlock SMG/Shotgun
            with banked (300 each). Use 1/2/3 to equip, 5/4 to buy.
          </div>
        </div>

        <div class="card">
          <div class="card-title">Stats</div>
          <div class="row">
            <span class="badge">Score: <span id="score">0</span></span>
            <span class="badge">Banked: <span id="banked">0</span></span>
            <span class="badge">HP: <span id="hp">100</span></span>
            <span class="badge">Weapon: <span id="weapon">pistol</span></span>
            <span class="badge">Ammo: <span id="ammo">0</span></span>
            <span class="badge" id="timer">Time: --</span>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Players</div>
          <div class="pill-list" id="players"></div>
        </div>

        <div class="card">
          <div class="card-title">Chat</div>
          <div id="chatMessages" class="chat-messages"></div>
          <div class="row"><input id="chatInput" placeholder="Chat..." /></div>
        </div>
      </aside>
    </div>
    <div class="hit-flash" id="flash"></div>
    
    <!-- Death Screen -->
    <div id="deathScreen" class="death-screen hidden">
      <div class="death-overlay"></div>
      <div class="death-content">
        <div class="death-header">
          <h1 class="death-title">💀 RAID ENDED 💀</h1>
          <div class="death-subtitle">Mission Statistics</div>
        </div>
        
        <div class="death-stats">
          <!-- First Row: Combat Stats & Enemy Breakdown Side-by-Side -->
          <div class="stats-row">
            <div class="stat-category">
              <h3>🎯 Combat Stats</h3>
              <div class="stat-item">
                <span class="stat-label">Enemies Killed:</span>
                <span class="stat-value" id="deathEnemiesKilled">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Bosses Defeated:</span>
                <span class="stat-value" id="deathBossesKilled">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Bullets Fired:</span>
                <span class="stat-value" id="deathBulletsFired">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Damage Dealt:</span>
                <span class="stat-value" id="deathDamageDealt">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Damage Taken:</span>
                <span class="stat-value" id="deathDamageTaken">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Accuracy:</span>
                <span class="stat-value" id="deathAccuracy">0%</span>
              </div>
            </div>
            
            <div class="stat-category">
              <h3>🧟 Enemy Breakdown</h3>
              <div class="enemy-stats" id="deathEnemyBreakdown">
                <div class="enemy-type">
                  <span class="enemy-name">Basic Zombies:</span>
                  <span class="enemy-count" id="deathBasicZombies">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Runners:</span>
                  <span class="enemy-count" id="deathRunners">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Brutes:</span>
                  <span class="enemy-count" id="deathBrutes">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Spitters:</span>
                  <span class="enemy-count" id="deathSpitters">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Stalkers:</span>
                  <span class="enemy-count" id="deathStalkers">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Bombers:</span>
                  <span class="enemy-count" id="deathBombers">0</span>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Second Row: Progression & Resources Side-by-Side -->
          <div class="stats-row">
            <div class="stat-category">
              <h3>📊 Progression</h3>
              <div class="stat-item">
                <span class="stat-label">Level Reached:</span>
                <span class="stat-value" id="deathLevel">1</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Total XP Gained:</span>
                <span class="stat-value" id="deathTotalXP">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Final Score:</span>
                <span class="stat-value" id="deathFinalScore">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Time Survived:</span>
                <span class="stat-value" id="deathTimeSurvived">0:00</span>
              </div>
            </div>
            
            <div class="stat-category">
              <h3>💰 Resources</h3>
              <div class="stat-item">
                <span class="stat-label">Coins Collected:</span>
                <span class="stat-value" id="deathCoinsCollected">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Pickups Taken:</span>
                <span class="stat-value" id="deathPickupsTaken">0</span>
              </div>
            </div>
          </div>
          
          <!-- Final Upgrades Section (Full Width) -->
          <div class="upgrades-section">
            <h3>⚡ Final Upgrades</h3>
            <div class="final-upgrades" id="deathFinalUpgrades">
              <div class="no-upgrades">No upgrades acquired</div>
            </div>
          </div>
        </div>
        
        <div class="death-actions">
          <button id="restartRaid" class="death-btn death-btn-primary">🔄 Restart Raid</button>
          <button id="exitToMenu" class="death-btn death-btn-secondary">🏠 Exit to Menu</button>
        </div>
      </div>
    </div>

    <script type="module">
      import {
        connect,
        nameStorage,
        minimalCanvas,
        inputController,
        suppressPageHotkeys,
        toast,
        createLatencyMonitor,
      } from "/common.js";

      const urlParams = new URLSearchParams(location.search);
      const presetRoom = urlParams.get('room') || '';
      const create = async () => {
        if (presetRoom) return presetRoom;
        const res = await fetch("/create", { method: "POST" });
        const { roomId } = await res.json();
        return roomId;
      };

      const { c, ctx } = minimalCanvas(1440, 810);
      const stage = document.querySelector(".stage");
      stage.appendChild(c);
      
      // Move HUD layer to be positioned relative to canvas
      const hudLayer = document.querySelector(".hud-layer");
      if (hudLayer) {
        // Position HUD layer to match canvas dimensions and position
        const updateHudPosition = () => {
          const canvasRect = c.getBoundingClientRect();
          const stageRect = stage.getBoundingClientRect();
          
          hudLayer.style.left = (canvasRect.left - stageRect.left) + 'px';
          hudLayer.style.top = (canvasRect.top - stageRect.top) + 'px';
          hudLayer.style.width = canvasRect.width + 'px';
          hudLayer.style.height = canvasRect.height + 'px';
        };
        
        // Update position initially and on resize
        updateHudPosition();
        window.addEventListener('resize', updateHudPosition);
        
        // Handle fullscreen changes for HUD positioning with multiple attempts
        const handleHudFullscreenChange = () => {
          setTimeout(updateHudPosition, 50);
          setTimeout(updateHudPosition, 150);
          setTimeout(updateHudPosition, 300);
          setTimeout(updateHudPosition, 500);
        };
        
        document.addEventListener('fullscreenchange', handleHudFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleHudFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleHudFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleHudFullscreenChange);
        
        // Also update when canvas size changes
        const resizeObserver = new ResizeObserver(updateHudPosition);
        resizeObserver.observe(c);
      }
      suppressPageHotkeys();
      const input = inputController();

      let ws,
        roomId,
        playerId,
        arena = { w: 960, h: 540 };
      let state = { players: [], bullets: [], arena, remainingTime: 0, aiZombies: [] };
      let gameMap = null; // {w,h,size,theme,tiles:Uint8Array, props, lights}
      let lastHp = 100;
      let lastStateTime = performance.now();
      let lastScore = 0;
      const effects = []; // bullet impacts etc {x,y,ttl}
      // Screen shake accumulator (reduced each frame)
      let shake = 0;
      let muzzleFlashes = [];
      let prevShoot = false;
      let lastMuzzleAt = 0;
      let prevBulletPos = new Map();
      // Damage numbers for floating damage display
      let damageNumbers = [];
      // Dash trails: per-player history of recent positions while dashing
      const trails = new Map(); // id -> Array<{x:number,y:number,t:number}>
      const TRAIL_TTL = 260; // ms
      const TRAIL_MAX = 22;
      // Local melee feedback (client-side prediction so streamer sees instantly)
      let localMeleeAt = 0;
      let localMeleeDirX = 1;
      let localMeleeDirY = 0;
      let prevMelee = false;

      const link = document.getElementById("roomLink");
      const status = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const bankedEl = document.getElementById("banked");
      const hpEl = document.getElementById("hp");
      const ammoEl = document.getElementById("ammo");
      const weaponEl = document.getElementById("weapon");
      const playersEl = document.getElementById("players");
      const buyShotgunBtn = document.getElementById("buyShotgun");
      const buySmgBtn = document.getElementById("buySmg");
      const btnPistol = document.getElementById("btnPistol");
      const btnSmg = document.getElementById("btnSmg");
      const btnShotgun = document.getElementById("btnShotgun");
      const flashEl = document.getElementById("flash");
      const newBtn = document.getElementById("newRoom");
      const copyBtn = document.getElementById("copy");
      const timerEl = document.getElementById("timer");
      const chatMessagesEl = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const toggleChatBtn = document.getElementById("toggleChat");
      const nerdToggleBtn = document.getElementById("nerdToggle");
      const buffPanel = document.getElementById("buffPanel");
      const buffListEl = document.getElementById("buffList");
      const hudScoreEl = document.getElementById("hudScore");
      const upgradeQueue = [];
      const hudBankedEl = document.getElementById("hudBanked");
      const hudWeaponEl = document.getElementById("hudWeapon");
      const hudAmmoEl = document.getElementById("hudAmmo");
      const hudHpEl = document.getElementById("hudHp");
      const hudLevelEl = document.getElementById("hudLevel");
      const hudXpEl = document.getElementById("hudXp");
      const healthSegmentsEl = document.getElementById("healthSegments");
      const deathScreenEl = document.getElementById("deathScreen");
      const restartRaidBtn = document.getElementById("restartRaid");
      const exitToMenuBtn = document.getElementById("exitToMenu");
      // Nerd panel overlay element
      const nerdPanel = document.createElement("div");
      nerdPanel.id = "nerdPanel";
      nerdPanel.className = "nerd-panel hidden mono";
      document.body.appendChild(nerdPanel);

      // Upgrade overlay elements
      const overlay = document.getElementById('upgradeOverlay');
      const choiceEls = Array.from(overlay.querySelectorAll('.choice'));
      let currentChoices = [];
      let currentHealthSegments = 0;
      let maxHealthSegments = 10;
      let isPlayerDead = false;
      let gameStartTime = Date.now();
      let lastPlayerPos = { x: 0, y: 0 };

      // Initialize segmented health bar
      function initHealthBar(maxHp) {
        maxHealthSegments = Math.max(5, Math.min(20, Math.ceil(maxHp / 10))); // 5-20 segments
        healthSegmentsEl.innerHTML = '';
        currentHealthSegments = maxHealthSegments;
        
        for (let i = 0; i < maxHealthSegments; i++) {
          const segment = document.createElement('div');
          segment.className = 'health-segment';
          segment.dataset.index = i;
          healthSegmentsEl.appendChild(segment);
        }
      }

      // Update segmented health bar with smooth animations
      function updateHealthBar(currentHp, maxHp) {
        if (!healthSegmentsEl) return;
        
        const healthPercentage = Math.max(0, Math.min(1, currentHp / maxHp));
        const targetSegments = Math.ceil(healthPercentage * maxHealthSegments);
        const segments = healthSegmentsEl.querySelectorAll('.health-segment');
        
        // Determine health state colors
        const lowHealthThreshold = 0.3;
        const criticalHealthThreshold = 0.15;
        
        segments.forEach((segment, index) => {
          const shouldBeActive = index < targetSegments;
          const isCurrentlyActive = !segment.classList.contains('depleting') && 
                                   segment.style.transform !== 'scaleX(0)';
          
          // Remove previous state classes
          segment.classList.remove('depleting', 'filling', 'low-health', 'critical-health');
          
          if (shouldBeActive && !isCurrentlyActive) {
            // Segment should fill
            segment.classList.add('filling');
            segment.style.transform = 'scaleX(1)';
            segment.style.opacity = '1';
          } else if (!shouldBeActive && isCurrentlyActive) {
            // Segment should deplete
            segment.classList.add('depleting');
            setTimeout(() => {
              segment.style.transform = 'scaleX(0)';
              segment.style.opacity = '0';
            }, 50);
          }
          
          // Apply health state colors
          if (shouldBeActive) {
            if (healthPercentage <= criticalHealthThreshold) {
              segment.classList.add('critical-health');
            } else if (healthPercentage <= lowHealthThreshold) {
              segment.classList.add('low-health');
            }
          }
        });
        
        currentHealthSegments = targetSegments;
      }

      // Death screen functions
      function showDeathScreen(playerStats) {
        isPlayerDead = true;
        
        // Calculate time survived
        const timeAlive = Date.now() - gameStartTime;
        const minutes = Math.floor(timeAlive / 60000);
        const seconds = Math.floor((timeAlive % 60000) / 1000);
        
        // Update death screen stats
        document.getElementById('deathEnemiesKilled').textContent = playerStats.raidStats?.enemiesKilled || 0;
        document.getElementById('deathBossesKilled').textContent = playerStats.raidStats?.bossesKilled || 0;
        document.getElementById('deathBulletsFired').textContent = playerStats.raidStats?.bulletsFired || 0;
        
        const accuracy = playerStats.raidStats?.bulletsFired > 0 
          ? Math.round((playerStats.raidStats.bulletsHit / playerStats.raidStats.bulletsFired) * 100)
          : 0;
        document.getElementById('deathAccuracy').textContent = accuracy + '%';
        
        document.getElementById('deathLevel').textContent = playerStats.level || 1;
        document.getElementById('deathTotalXP').textContent = playerStats.raidStats?.totalXPGained || 0;
        document.getElementById('deathFinalScore').textContent = playerStats.score || 0;
        document.getElementById('deathTimeSurvived').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        document.getElementById('deathCoinsCollected').textContent = playerStats.raidStats?.coinsCollected || 0;
        document.getElementById('deathPickupsTaken').textContent = playerStats.raidStats?.pickupsTaken || 0;
        document.getElementById('deathDamageDealt').textContent = playerStats.raidStats?.damageDealt || 0;
        document.getElementById('deathDamageTaken').textContent = playerStats.raidStats?.damageTaken || 0;
        
        // Enemy breakdown
        const breakdown = playerStats.raidStats?.enemyBreakdown || {};
        document.getElementById('deathBasicZombies').textContent = breakdown.basic || 0;
        document.getElementById('deathRunners').textContent = breakdown.runner || 0;
        document.getElementById('deathBrutes').textContent = breakdown.brute || 0;
        document.getElementById('deathSpitters').textContent = breakdown.spitter || 0;
        document.getElementById('deathStalkers').textContent = breakdown.stalker || 0;
        document.getElementById('deathBombers').textContent = breakdown.bomber || 0;
        
        // Bosses defeated
        const bossesDefeated = playerStats.raidStats?.bossesDefeated || [];
        if (bossesDefeated.length > 0) {
          console.log('Bosses defeated:', bossesDefeated.join(', '));
        }
        
        // Final upgrades
        const upgradesEl = document.getElementById('deathFinalUpgrades');
        if (playerStats.mods && playerStats.mods.length > 0) {
          upgradesEl.innerHTML = '';
          playerStats.mods.forEach(mod => {
            const upgradeEl = document.createElement('div');
            upgradeEl.className = 'upgrade-item';
            // Use the mod name if available, otherwise format the ID
            const displayName = mod.name || mod.id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            upgradeEl.textContent = `${displayName} x${mod.stacks}`;
            upgradesEl.appendChild(upgradeEl);
          });
        } else {
          upgradesEl.innerHTML = '<div class="no-upgrades">No upgrades acquired</div>';
        }
        
        // Show the death screen
        deathScreenEl.classList.remove('hidden');
      }

      function hideDeathScreen() {
        deathScreenEl.classList.add('hidden');
        isPlayerDead = false;
      }

      function restartRaid() {
        hideDeathScreen();
        gameStartTime = Date.now();
        // Trigger a new room creation
        if (ws && ws.readyState === 1) {
          leaveRoom(true);
        }
        setTimeout(() => boot(), 100);
      }

      function exitToMenu() {
        hideDeathScreen();
        if (ws && ws.readyState === 1) {
          leaveRoom(true);
        }
      }

      function showNextUpgrade() {
        if (!upgradeQueue.length) {
          currentChoices = [];
          choiceEls.forEach((el) => { el.textContent = ''; el.disabled = true; });
          overlay.classList.add('hidden');
          return;
        }
        currentChoices = upgradeQueue.shift();
        choiceEls.forEach((el, i) => {
          const choice = currentChoices[i];
          if (!choice) { el.textContent = ''; el.disabled = true; return; }
          el.disabled = false;
          el.textContent = `${i + 1}) ${choice.name} - ${choice.desc}`;
        });
        overlay.classList.remove('hidden');
      }

      function queueUpgrade(choices) {
        const normalized = Array.isArray(choices) ? choices.filter(Boolean) : [];
        if (!normalized.length) return;
        upgradeQueue.push(normalized);
        if (overlay.classList.contains('hidden') && currentChoices.length === 0) {
          showNextUpgrade();
        }
      }

      function pickUpgrade(index) {
        const choice = currentChoices[index];
        if (!choice || !ws) return;
        try { ws.send(JSON.stringify({ type: 'choose_upgrade', id: choice.id })); } catch {}
        showNextUpgrade();
      }

      choiceEls.forEach((el, i) => el.addEventListener('click', () => pickUpgrade(i)));
      window.addEventListener('keydown', (e) => {
        if (overlay.classList.contains('hidden')) return;
        if (e.key === '1') pickUpgrade(0);
        if (e.key === '2') pickUpgrade(1);
        if (e.key === '3') pickUpgrade(2);
      });

      function xpThreshold(level) {
        return 3 + Math.floor(level * 1.8);
      }

      function renderBuffs(mods) {
        if (!buffListEl) return;
        buffListEl.innerHTML = "";
        const data = Array.isArray(mods)
          ? mods.slice()
          : Object.entries(mods || {}).map(([id, stacks]) => ({ id, stacks }));
        if (!data.length) {
          if (buffPanel) buffPanel.classList.add('hidden');
          return;
        }
        data.sort((a, b) => (a.name || a.id || '').localeCompare(b.name || b.id || ''));
        if (buffPanel) buffPanel.classList.remove('hidden');
        for (const mod of data) {
          const row = document.createElement('div');
          row.className = 'hud-buff';
          row.dataset.rarity = (mod.rarity || 'common');
          if (mod.desc) row.title = mod.desc;
          const nameEl = document.createElement('span');
          nameEl.className = 'label';
          nameEl.textContent = mod.name || mod.id;
          const stackEl = document.createElement('span');
          stackEl.className = 'stacks';
          stackEl.textContent = `x${mod.stacks ?? 1}`;
          row.append(nameEl, stackEl);
          buffListEl.appendChild(row);
        }
      }
      renderBuffs([]);

      let nerdOn = localStorage.getItem("nerdStats") === "1";
      function setNerd(on) {
        nerdOn = !!on;
        localStorage.setItem("nerdStats", nerdOn ? "1" : "0");
        nerdPanel.classList.toggle("hidden", !nerdOn);
        nerdToggleBtn.classList.toggle("active", nerdOn);
      }
      setNerd(nerdOn);
      nerdToggleBtn.onclick = () => setNerd(!nerdOn);
      copyBtn.disabled = true;
      // Camera: smooth, mouse-biased, no manual control
      let camX = 0,
        camY = 0; // top-left of viewport in world space
      const zoom = 2.4; // hotline-miami style: a bit more zoomed-in
      const mouseBias = 110; // world px to bias toward aim
      const camLerpBase = 0.05; // smoothing factor per frame higher = faster

      let inputIv = null;
      let sendNeutralHandler = null;
      let visHandler = null;

      let pingIv = null;
      let latency = null;
      let stateMsgCount = 0;
      let statesPerSec = 0;
      let lastStateRateAt = performance.now();
      async function boot() {
        if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;
        
        // Reset death screen state
        gameStartTime = Date.now();
        isPlayerDead = false;
        hideDeathScreen();
        
        roomId = await create();
        const url = `${location.origin}/join.html?room=${roomId}`;
        link.value = url;
        copyBtn.disabled = false;
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(url);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        };

        ws = connect(roomId);
        ws.addEventListener("open", () => {
          status.textContent = "connected";
          status.dataset.state = "connected";
          document.body.classList.add("connected");
          const name = nameStorage().get() || "Marine";
          ws.send(
            JSON.stringify({ type: "join_room", role: "streamer", name })
          );
          newBtn.textContent = "End Session";
          toggleChatBtn.disabled = false;
        });
        latency = createLatencyMonitor(ws);
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        pingIv = setInterval(() => {
          try {
            latency.sendPing();
          } catch {}
        }, 1000);

        ws.addEventListener("message", (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === "map") {
            try {
              const m = msg.map;
              const bin = atob(m.tilesBase64);
              const u8 = new Uint8Array(bin.length);
              for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
              gameMap = {
                w: m.w,
                h: m.h,
                size: m.size,
                theme: m.theme,
                tiles: u8,
                props: m.props || [],
                lights: m.lights || [],
              };
            } catch {}
          }
          if (msg.type === "joined") {
            playerId = msg.playerId;
            arena = msg.arena;
          }
          if (msg.type === "state") {
            stateMsgCount++;
            // detect removed bullets for small impact effect
            const curMap = new Map(
              msg.bullets.map((b) => [b.id, { x: b.x, y: b.y }])
            );
            for (const [id, pos] of prevBulletPos) {
              if (!curMap.has(id)) {
                effects.push({ x: pos.x, y: pos.y, ttl: 220 });
                shake += 2;
              }
            }
            prevBulletPos = curMap;

            // Process damage numbers
            if (msg.damageNumbers) {
              // Create a set of existing IDs for faster lookup
              const existingIds = new Set(damageNumbers.map(dn => dn.id));
              
              for (const dn of msg.damageNumbers) {
                // Check if we already have this damage number
                if (!existingIds.has(dn.id)) {
                  // Find the target entity (player or AI zombie) to attach damage number to
                  let targetId = null;
                  let isAI = false;
                  
                  // Check if damage number is near any player
                  for (const player of msg.players) {
                    const dist = Math.hypot(player.x - dn.x, player.y - dn.y);
                    if (dist < 30) { // Within 30 pixels
                      targetId = player.id;
                      break;
                    }
                  }
                  
                  // If not found near players, check AI zombies
                  if (!targetId && msg.aiZombies) {
                    for (const zombie of msg.aiZombies) {
                      const dist = Math.hypot(zombie.x - dn.x, zombie.y - dn.y);
                      if (dist < 30) { // Within 30 pixels
                        targetId = zombie.id;
                        isAI = true;
                        break;
                      }
                    }
                  }
                  
                  damageNumbers.push({
                    id: dn.id,
                    x: dn.x,
                    y: dn.y,
                    damage: dn.damage,
                    isCrit: dn.isCrit,
                    isDot: dn.isDot,
                    timestamp: dn.timestamp,
                    startTime: Date.now(),
                    offsetY: 0,
                    targetId: targetId,
                    isAI: isAI,
                    initialX: dn.x,
                    initialY: dn.y
                  });
                  
                  // Add to existing IDs set to prevent duplicates within this message
                  existingIds.add(dn.id);
                }
              }
            }

            state = msg;
            const me = msg.players.find((p) => p.id === playerId);
            if (me) {
              const hpVal = me.hp ?? 0;
              const maxHp = me.maxHp ?? hpVal;
              const level = me.level ?? 0;
              const xpVal = me.xp ?? 0;
              const xpNeed = me.xpForNext ?? xpThreshold(level);
              scoreEl.textContent = me.score;
              bankedEl.textContent = me.banked ?? 0;
              
              // Check if HP has decreased
              const prevHpText = hpEl.textContent.split('/')[0];
              const prevHp = parseInt(prevHpText) || maxHp;
              const hpDecreased = hpVal < prevHp && prevHp <= maxHp; // Only trigger if HP actually decreased and not just respawned
              
              // Update HP display
              hpEl.innerHTML = `<span id="hp-value">${hpVal}</span>/<span id="hp-max">${maxHp}</span>`;
              
              // Add pulse effect if HP decreased
              if (hpDecreased) {
                const hpValueEl = document.getElementById('hp-value');
                if (hpValueEl) {
                  hpValueEl.classList.add('hp-damage-pulse');
                  setTimeout(() => {
                    if (hpValueEl) hpValueEl.classList.remove('hp-damage-pulse');
                  }, 400);
                }
              }
              const w = me.weapon || "pistol";
              weaponEl.textContent = w;
              let ammo = 0;
              if (w === "pistol") ammo = me.pistolAmmo ?? 0;
              else if (w === "smg") ammo = me.smgAmmo ?? 0;
              else if (w === "shotgun") ammo = me.shotgunAmmo ?? 0;
              else ammo = 0;
              
              // Check if ammo has decreased
              const prevAmmo = parseInt(ammoEl.textContent) || 0;
              const ammoDecreased = ammo < prevAmmo;
              
              ammoEl.textContent = ammo;
              
              // Add pulse class if ammo decreased
              if (ammoDecreased) {
                ammoEl.classList.add('ammo-pulse');
                // Remove the class after animation completes
                setTimeout(() => ammoEl.classList.remove('ammo-pulse'), 300);
              }
              
              if (hudScoreEl) hudScoreEl.textContent = String(me.score ?? 0);
              if (hudBankedEl) hudBankedEl.textContent = String(me.banked ?? 0);
              if (hudWeaponEl) hudWeaponEl.textContent = w;
              
              // Initialize health bar if not done yet
              if (healthSegmentsEl && healthSegmentsEl.children.length === 0) {
                initHealthBar(maxHp);
              }
              
              // Update segmented health bar
              updateHealthBar(hpVal, maxHp);
              
              // Update HUD ammo counter with the same pulse effect
              if (hudAmmoEl) {
                const prevHudAmmo = parseInt(hudAmmoEl.textContent) || 0;
                hudAmmoEl.textContent = String(ammo);
                if (ammo < prevHudAmmo) {
                  hudAmmoEl.classList.add('ammo-pulse');
                  setTimeout(() => hudAmmoEl.classList.remove('ammo-pulse'), 300);
                }
              }
              // Health bar is now handled by updateHealthBar function
              if (hudLevelEl) hudLevelEl.textContent = String(level);
              if (hudXpEl) hudXpEl.textContent = `${xpVal}/${xpNeed}`;
              renderBuffs(me.mods || []);
              // Ownership inference
              const hasSmg = (me.smgAmmo ?? 0) > 0 || w === "smg";
              const hasShotgun = (me.shotgunAmmo ?? 0) > 0 || w === "shotgun";
              // Button states
              if (btnPistol) {
                btnPistol.classList.toggle("equipped", w === "pistol");
                btnPistol.classList.add("owned");
              }
              if (btnSmg) {
                btnSmg.classList.toggle("equipped", w === "smg");
                btnSmg.classList.toggle("owned", hasSmg);
                btnSmg.classList.toggle("locked", !hasSmg);
              }
              if (btnShotgun) {
                btnShotgun.classList.toggle("equipped", w === "shotgun");
                btnShotgun.classList.toggle("owned", hasShotgun);
                btnShotgun.classList.toggle("locked", !hasShotgun);
              }
              if (buyShotgunBtn) {
                const canBuy = (me.banked || 0) >= 300 && !hasShotgun;
                buyShotgunBtn.disabled = !canBuy;
                buyShotgunBtn.textContent = "Unlock Shotgun (4) ??? 300";
                buyShotgunBtn.title = canBuy
                  ? "Press 4 to purchase"
                  : "Need 300 banked or already unlocked";
              }
              if (buySmgBtn) {
                const canBuySmg = (me.banked || 0) >= 300 && !hasSmg;
                buySmgBtn.disabled = !canBuySmg;
                buySmgBtn.textContent = "Unlock SMG (5) ??? 300";
                buySmgBtn.title = canBuySmg
                  ? "Press 5 to purchase"
                  : "Need 300 banked or already unlocked";
              }
            } else {
              renderBuffs([]);
              if (hudScoreEl) hudScoreEl.textContent = '0';
              if (hudBankedEl) hudBankedEl.textContent = '0';
              if (hudWeaponEl) hudWeaponEl.textContent = '--';
              if (hudAmmoEl) hudAmmoEl.textContent = '0';
              // Clear health bar segments
              if (healthSegmentsEl) healthSegmentsEl.innerHTML = '';
              if (hudLevelEl) hudLevelEl.textContent = '0';
              if (hudXpEl) hudXpEl.textContent = '0/0';
            }
            const ping = Math.max(0, Date.now() - (msg.t || Date.now()));
            status.textContent = `connected • ${ping} ms • players: ${msg.players.length}`;
            status.dataset.state = "connected";
            state.remainingTime = msg.remainingTime;
            updateTimer(state.remainingTime);
            updatePlayerList(msg.players);
            // Update chat toggle button label from state
            if (typeof msg.chatEnabled === "boolean") {
              toggleChatBtn.textContent = msg.chatEnabled
                ? "Disable Chat"
                : "Enable Chat";
              // Hide chat card and disable input when chat is disabled
              chatInput.disabled = !msg.chatEnabled;
              chatInput.placeholder = msg.chatEnabled
                ? "Chat..."
                : "Chat disabled by streamer";
              const chatCard = chatMessagesEl.closest(".card");
              if (chatCard)
                chatCard.classList.toggle("hidden", !msg.chatEnabled);
            }
            if (me && (me.hp ?? 0) < lastHp) {
              flash();
            }
            
            // Check for death - only trigger death screen, don't auto-hide on respawn
            if (me && (me.hp ?? 0) <= 0 && !isPlayerDead) {
              console.log('Death detected! HP:', me.hp);
              showDeathScreen(me);
            }
            
            // Check for sudden teleportation (respawn after spike/poison death)
            if (me && lastPlayerPos.x !== 0 && !isPlayerDead) {
              const distMoved = Math.hypot(me.x - lastPlayerPos.x, me.y - lastPlayerPos.y);
              const hpRestored = (me.hp ?? 0) > lastHp + 20; // HP significantly increased
              
              if (distMoved > 500 && hpRestored) {
                console.log('Teleportation + HP restore detected - likely respawn! Distance:', distMoved, 'HP:', lastHp, '->', me.hp);
                showDeathScreen(me);
              }
            }
            
            // Update last position
            if (me) {
              lastPlayerPos = { x: me.x, y: me.y };
            }
            
            lastScore = me ? me.score : lastScore;
            lastHp = me ? me.hp ?? lastHp : lastHp;
            lastStateTime = performance.now();
          }
          if (msg.type === "pong") {
            if (latency) latency.handlePong(Number(msg.timestamp) || 0);
          }
          if (msg.type === "chat") {
            appendChat(msg.from, msg.message);
          }
          if (msg.type === "notice") {
            try {
              toast(msg.message);
            } catch {}
            appendChat("System", msg.message);
            
            // Check for respawn notice (pit death)
            if (msg.message && msg.message.includes("💀 Fell into a pit! Respawning...") && !isPlayerDead) {
              console.log('Pit death detected:', msg.message);
              const me = state.players.find((p) => p.id === playerId);
              if (me) {
                showDeathScreen(me);
              }
            }
          }
          if (msg.type === 'upgrade_offer') {
            queueUpgrade(msg.choices || []);
          }
        });
        inputIv = setInterval(() => {
          if (ws && ws.readyState === 1 && !isPlayerDead) {
            // Convert screen aim to world coordinates via camera + zoom
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: input.up,
                down: input.down,
                left: input.left,
                right: input.right,
                shoot: input.shoot,
                melee: input.melee,
                dash: input.dash,
                aimX: aimWX,
                aimY: aimWY,
              })
            );

            // Spawn a local muzzle flash near the player's muzzle for immediate feedback
            const meNow = state.players.find((p) => p.id === playerId);
            if (meNow) {
              const now = performance.now();
              const wantFlash =
                input.shoot && (!prevShoot || now - lastMuzzleAt > 110);
              if (wantFlash) {
                const dx = aimWX - meNow.x;
                const dy = aimWY - meNow.y;
                const d = Math.hypot(dx, dy) || 1;
                const muzzleOffset = 16; // distance from player center to muzzle
                const fx = meNow.x + (dx / d) * muzzleOffset;
                const fy = meNow.y + (dy / d) * muzzleOffset;
                muzzleFlashes.push({ x: fx, y: fy, ttl: 90 });
                lastMuzzleAt = now;
              }
              prevShoot = input.shoot;
            }
          }
        }, 50);

        // If focus is lost, immediately send a neutral input (interval covers it, but faster feedback helps)
        sendNeutralHandler = () => {
          if (ws && ws.readyState === 1 && !isPlayerDead) {
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: false,
                down: false,
                left: false,
                right: false,
                shoot: false,
                melee: false,
                dash: false,
                aimX: aimWX,
                aimY: aimWY,
              })
            );
          }
        };
        visHandler = () => {
          if (document.hidden) sendNeutralHandler();
        };
        window.addEventListener("blur", sendNeutralHandler);
        document.addEventListener("visibilitychange", visHandler);

        const onClose = () => {
          leaveRoom(false);
        };
        ws.addEventListener("close", onClose, { once: true });
      }

      function leaveRoom(manual = true) {
        if (inputIv) {
          clearInterval(inputIv);
          inputIv = null;
        }
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        if (sendNeutralHandler) {
          window.removeEventListener("blur", sendNeutralHandler);
          sendNeutralHandler = null;
        }
        if (visHandler) {
          document.removeEventListener("visibilitychange", visHandler);
          visHandler = null;
        }
        if (ws) {
          try {
            if (manual && ws.readyState === 1) ws.close(1000, "leave");
          } catch {}
          ws = null;
        }
        status.textContent = "disconnected";
        status.dataset.state = "disconnected";
        document.body.classList.remove("connected");
        newBtn.textContent = "Create Room";
        copyBtn.disabled = true;
        link.value = "";
        toggleChatBtn.disabled = true;
        toggleChatBtn.textContent = "Disable Chat";
        playerId = null;
        prevBulletPos = new Map();
        effects.length = 0;
        muzzleFlashes.length = 0;
        lastScore = 0;
        lastHp = 100;
        state = { players: [], bullets: [], arena };
        updatePlayerList([]);
      }

      // Smoothing map for positions (reduces 20Hz stutter)
      const smooth = new Map(); // id -> {x,y}
      const SMOOTH_TAU = 90; // ms time constant
      function getSmoothedPos(id, tx, ty, dt) {
        let s = smooth.get(id);
        if (!s) {
          s = { x: tx, y: ty };
          smooth.set(id, s);
          return { x: tx, y: ty };
        }
        const alpha = 1 - Math.exp(-dt / Math.max(1, SMOOTH_TAU));
        s.x += (tx - s.x) * alpha;
        s.y += (ty - s.y) * alpha;
        return { x: s.x, y: s.y };
      }

      function draw(dt = 16) {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const rect = c.getBoundingClientRect();
        // Reset and clear in device pixels
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, c.width, c.height);
        // Base transform to CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // Fill background with dungeon-themed dark color in CSS px
        ctx.fillStyle = "#0a0c0f";
        ctx.fillRect(0, 0, rect.width, rect.height);
        // Update camera target (follow player with slight mouse bias)
        const meRawForCam = state.players.find((p) => p.id === playerId);
        const meHud = meRawForCam || null;
        const meCam = meRawForCam
          ? getSmoothedPos(meRawForCam.id, meRawForCam.x, meRawForCam.y, dt)
          : null;
        if (meCam) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          const dx = aimWX - meCam.x,
            dy = aimWY - meCam.y;
          const d = Math.hypot(dx, dy) || 1;
          const offX = (dx / d) * mouseBias,
            offY = (dy / d) * mouseBias;
          const viewW = rect.width / zoom,
            viewH = rect.height / zoom;
          const targetX = Math.min(
            Math.max(0, meCam.x + offX - viewW / 2),
            Math.max(0, arena.w - viewW)
          );
          const targetY = Math.min(
            Math.max(0, meCam.y + offY - viewH / 2),
            Math.max(0, arena.h - viewH)
          );
          const k = Math.min(1, (dt / 16) * camLerpBase);
          camX = camX + (targetX - camX) * k;
          camY = camY + (targetY - camY) * k;
        }
        // Begin world transform
        ctx.save();
        ctx.scale(zoom, zoom);
        // Screen shake
        const sAmt = Math.max(0, shake);
        shake = Math.max(0, shake * 0.9 - 0.2);
        const sdx = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        const sdy = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        ctx.translate(-camX + sdx, -camY + sdy);
        // Tile layer
        if (gameMap)
          drawTiles(camX, camY, rect.width / zoom, rect.height / zoom);
        // Walls/rooms
        if (state.walls) {
          ctx.fillStyle = "#2a2f36";
          for (const w of state.walls) {
            ctx.fillRect(w.x, w.y, w.w, w.h);
          }
        }
        // Extractions removed
        // Pickups
        if (state.pickups) {
          for (const pk of state.pickups) {
            ctx.save();
            ctx.shadowColor = "rgba(255,255,255,.16)";
            ctx.shadowBlur = 8;
            if (pk.type === "health") {
              ctx.strokeStyle = "#66bb6a";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 8, 16, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x + 6, pk.y);
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "speed") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x - 5, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x - 2, pk.y - 2);
              ctx.lineTo(pk.x + 5, pk.y + 8);
              ctx.stroke();
            } else if (pk.type === "ammo") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 7, pk.y - 5, 14, 10);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y + 1);
              ctx.lineTo(pk.x - 4, pk.y - 1);
              ctx.moveTo(pk.x, pk.y + 1);
              ctx.lineTo(pk.x, pk.y - 1);
              ctx.moveTo(pk.x + 4, pk.y + 1);
              ctx.lineTo(pk.x + 4, pk.y - 1);
              ctx.stroke();
            } else if (pk.type === "weapon") {
              ctx.strokeStyle = "#ffa726";
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x - 6, pk.y);
              ctx.stroke();
            } else if (pk.type === "shield") {
              ctx.strokeStyle = "#26c6da";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 9, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "magnet") {
              ctx.strokeStyle = "#ab47bc";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x - 3, pk.y, 6, -Math.PI / 2, Math.PI / 2);
              ctx.arc(pk.x + 3, pk.y, 6, Math.PI / 2, -Math.PI / 2);
              ctx.stroke();
            } else if (pk.type === "freeze") {
              ctx.strokeStyle = "#90caf9";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x, pk.y + 7);
              ctx.moveTo(pk.x - 7, pk.y);
              ctx.lineTo(pk.x + 7, pk.y);
              ctx.moveTo(pk.x - 5, pk.y - 5);
              ctx.lineTo(pk.x + 5, pk.y + 5);
              ctx.moveTo(pk.x - 5, pk.y + 5);
              ctx.lineTo(pk.x + 5, pk.y - 5);
              ctx.stroke();
            } else if (pk.type === "blast") {
              ctx.strokeStyle = "#ff7043";
              ctx.lineWidth = 2;
              for (let i = 0; i < 8; i++) {
                const a = (i * Math.PI) / 4;
                ctx.beginPath();
                ctx.moveTo(pk.x + Math.cos(a) * 3, pk.y + Math.sin(a) * 3);
                ctx.lineTo(pk.x + Math.cos(a) * 10, pk.y + Math.sin(a) * 10);
                ctx.stroke();
              }
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 3, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "treasure") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x, pk.y + 1, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "coin") {
              ctx.strokeStyle = "#ffc107";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 6, 0, Math.PI * 2);
              ctx.stroke();
              ctx.fillStyle = "#ffc107";
              ctx.globalAlpha = 0.3;
              ctx.fill();
            } else if (pk.type === "gem") {
              ctx.strokeStyle = "#e91e63";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x - 5, pk.y - 2);
              ctx.lineTo(pk.x - 3, pk.y + 7);
              ctx.lineTo(pk.x + 3, pk.y + 7);
              ctx.lineTo(pk.x + 5, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "crystal") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#9c27b0";
              ctx.shadowBlur = 6;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x - 4, pk.y - 2);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.lineTo(pk.x + 4, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "orb") {
              ctx.strokeStyle = "#2196f3";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#2196f3";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 7, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x - 2, pk.y - 2, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "relic") {
              ctx.strokeStyle = "#795548";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#795548";
              ctx.shadowBlur = 6;
              ctx.strokeRect(pk.x - 6, pk.y - 8, 12, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y - 4);
              ctx.moveTo(pk.x - 2, pk.y);
              ctx.lineTo(pk.x + 2, pk.y);
              ctx.stroke();
            } else if (pk.type === "artifact") {
              ctx.strokeStyle = "#607d8b";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#607d8b";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y - 2, 6, 0, Math.PI);
              ctx.stroke();
              ctx.strokeRect(pk.x - 4, pk.y - 2, 8, 8);
            } else if (pk.type === "medallion") {
              ctx.strokeStyle = "#ff9800";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#ff9800";
              ctx.shadowBlur = 10;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 8, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.moveTo(pk.x + 4, pk.y - 4);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.stroke();
            } else if (pk.type === "scroll") {
              ctx.strokeStyle = "#8bc34a";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#8bc34a";
              ctx.shadowBlur = 12;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y - 2);
              ctx.lineTo(pk.x + 6, pk.y - 2);
              ctx.moveTo(pk.x - 6, pk.y + 2);
              ctx.lineTo(pk.x + 6, pk.y + 2);
              ctx.stroke();
            } else if (pk.type === "crown") {
              ctx.strokeStyle = "#ffd700";
              ctx.lineWidth = 4;
              ctx.shadowColor = "#ffd700";
              ctx.shadowBlur = 15;
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y + 4);
              ctx.lineTo(pk.x - 4, pk.y - 6);
              ctx.lineTo(pk.x - 2, pk.y + 2);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x + 4, pk.y - 6);
              ctx.lineTo(pk.x + 8, pk.y + 4);
              ctx.lineTo(pk.x - 8, pk.y + 4);
              ctx.stroke();
            }
            // label under pickup
            ctx.font =
              "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.fillStyle = "#cfd8dc";
            ctx.globalAlpha = 0.95;
            const labelMap = {
              health: "HEALTH",
              speed: "SPEED",
              ammo: "AMMO",
              weapon: "WEAPON",
              shield: "SHIELD",
              magnet: "MAGNET",
              freeze: "FREEZE",
              blast: "BLAST",
              treasure: "TREASURE",
              key: "KEY",
              coin: "COIN (10)",
              gem: "GEM (25)",
              crystal: "CRYSTAL (50)",
              orb: "ORB (75)",
              relic: "RELIC (100)",
              artifact: "ARTIFACT (150)",
              medallion: "MEDALLION (250)",
              scroll: "SCROLL (400)",
              crown: "CROWN (1000)",
            };
            const lbl = labelMap[pk.type] || String(pk.type).toUpperCase();
            if (lbl) ctx.fillText(lbl, pk.x, pk.y + 14);
            ctx.restore();
          }
          ctx.lineWidth = 1;
        }
        // Bullets
        ctx.fillStyle = "#ffd54f";
        for (const b of state.bullets) {
          ctx.save();
          ctx.shadowColor = "rgba(255,213,79,.6)";
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        // Spitter globs (enemy projectiles)
        if (state.globs) {
          ctx.fillStyle = "#ce93d8";
          for (const g of state.globs) {
            ctx.save();
            ctx.shadowColor = "rgba(206,147,216,.6)";
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(g.x, g.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }
        // Bullet impact effects
        for (let i = effects.length - 1; i >= 0; i--) {
          const e = effects[i];
          e.ttl -= dt;
          if (e.ttl <= 0) {
            effects.splice(i, 1);
            continue;
          }
          ctx.save();
          ctx.globalAlpha = e.ttl / 220;
          ctx.fillStyle = "#ff6b35";
          ctx.beginPath();
          ctx.arc(e.x, e.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Damage numbers - clean up old ones first
        const now = Date.now();
        
        // Remove damage numbers older than server timestamp or animation time
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
          const dn = damageNumbers[i];
          const age = now - dn.startTime;
          const maxAge = 1500; // 1.5 seconds
          const serverAge = now - dn.timestamp;
          
          // Remove if animation is done OR if server timestamp is too old
          if (age > maxAge || serverAge > 2000) {
            damageNumbers.splice(i, 1);
            continue;
          }
        }
        
        // Render remaining damage numbers
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
          const dn = damageNumbers[i];
          const age = now - dn.startTime;
          const maxAge = 1500; // 1.5 seconds
          
          // Update position to follow target entity
          let renderX = dn.initialX;
          let renderY = dn.initialY;
          
          if (dn.targetId) {
            if (dn.isAI) {
              // Follow AI zombie
              const zombie = state.aiZombies?.find(z => z.id === dn.targetId);
              if (zombie) {
                renderX = zombie.x;
                renderY = zombie.y - 15; // Slightly above the zombie
              }
            } else {
              // Follow player
              const player = state.players.find(p => p.id === dn.targetId);
              if (player) {
                renderX = player.x;
                renderY = player.y - 15; // Slightly above the player
              }
            }
          }
          
          // Animation: float up and fade out
          const progress = age / maxAge;
          const alpha = Math.max(0, 1 - progress * progress); // Quadratic fade
          const offsetY = -progress * 60; // Float up 60 pixels
          
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Different styles for different damage types
          if (dn.isCrit) {
            ctx.font = 'bold 18px monospace';
            ctx.fillStyle = '#ff4444';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeText(dn.damage.toString(), renderX, renderY + offsetY);
            ctx.fillText(dn.damage.toString(), renderX, renderY + offsetY);
          } else if (dn.isDot) {
            ctx.font = '12px monospace';
            ctx.fillStyle = '#88ff44';
            ctx.fillText(dn.damage.toString(), renderX, renderY + offsetY);
          } else {
            ctx.font = '14px monospace';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(dn.damage.toString(), renderX, renderY + offsetY);
          }
          
          ctx.restore();
        }
        // AI Zombies
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            ctx.save();
            
            // Main zombie body
            ctx.fillStyle = "#ef5350";
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Class outline
            if (zombie.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (zombie.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (zombie.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else if (zombie.zClass === "stalker") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
            } else if (zombie.zClass === "bomber") {
              ctx.strokeStyle = "#f44336";
              ctx.lineWidth = 2.5;
            } else {
              ctx.strokeStyle = "#666";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, zombie.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            
            // State indicator
            if (zombie.state === "chasing") {
              ctx.strokeStyle = "#ff5722";
              ctx.lineWidth = 2;
              ctx.globalAlpha = 0.8;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 18, 0, Math.PI * 2);
              ctx.stroke();
            } else if (zombie.state === "attacking") {
              ctx.strokeStyle = "#d32f2f";
              ctx.lineWidth = 3;
              ctx.globalAlpha = 1;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 20, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Detection range indicator (when idle or chasing)
            if (zombie.state !== "attacking") {
              ctx.strokeStyle = "rgba(255, 87, 34, 0.15)";
              ctx.lineWidth = 1;
              ctx.globalAlpha = 0.3;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, zombie.detectionRange, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // HP bar
            const barWidth = 24;
            const barHeight = 4;
            const barX = zombie.x - barWidth / 2;
            const barY = zombie.y - 20;
            const hpRatio = zombie.hp / zombie.maxHp;
            
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = hpRatio > 0.6 ? "#4caf50" : hpRatio > 0.3 ? "#ff9800" : "#f44336";
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
            
            // Name/class label
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.font = "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(`AI ${zombie.zClass}`, zombie.x, zombie.y + 25);
            
            ctx.restore();
          }
        }

        // Bosses
        if (state.bosses) {
          for (const boss of state.bosses) {
            const visual = boss.visual || {};
            ctx.save();
            
            // Boss glow effect
            ctx.shadowColor = visual.glowColor || "#ff0000";
            ctx.shadowBlur = 20;
            
            // Main boss body - larger circle with unique colors
            ctx.fillStyle = visual.color || "#8B0000";
            ctx.strokeStyle = visual.secondaryColor || "#FF4500";
            ctx.lineWidth = 4;
            
            // Phase effect for Shadow Lord
            if (boss.phased) {
              ctx.globalAlpha = 0.3;
              ctx.setLineDash([5, 5]);
            }
            
            ctx.beginPath();
            ctx.arc(boss.pos.x, boss.pos.y, boss.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
            
            // Boss symbol in center
            ctx.fillStyle = "#ffffff";
            ctx.font = "20px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(visual.symbol || "👹", boss.pos.x, boss.pos.y);
            
            // HP bar above boss
            const barWidth = boss.radius * 2.5;
            const barHeight = 6;
            const barX = boss.pos.x - barWidth / 2;
            const barY = boss.pos.y - boss.radius - 15;
            const hpRatio = boss.hp / boss.maxHp;
            
            // HP bar background
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // HP bar fill with color based on health
            ctx.fillStyle = hpRatio > 0.6 ? "#4caf50" : hpRatio > 0.3 ? "#ff9800" : "#f44336";
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
            
            // Enrage effect for Brute King
            if (boss.enraged) {
              ctx.strokeStyle = "#ff4444";
              ctx.lineWidth = 3;
              ctx.globalAlpha = 0.8;
              ctx.beginPath();
              ctx.arc(boss.pos.x, boss.pos.y, boss.radius + 8, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Boss name and type
            ctx.globalAlpha = 1;
            ctx.fillStyle = "#ffffff";
            ctx.font = "14px system-ui";
            ctx.textAlign = "center";
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 2;
            ctx.strokeText(boss.type.toUpperCase(), boss.pos.x, boss.pos.y - boss.radius - 25);
            ctx.fillText(boss.type.toUpperCase(), boss.pos.x, boss.pos.y - boss.radius - 25);
            
            ctx.restore();
          }
        }

        // Boss minions
        if (state.bossMinions) {
          for (const minion of state.bossMinions) {
            ctx.save();
            
            // Minion body - smaller, darker
            ctx.fillStyle = "#4a148c";
            ctx.strokeStyle = "#7b1fa2";
            ctx.lineWidth = 2;
            ctx.shadowColor = "#7b1fa2";
            ctx.shadowBlur = 8;
            
            ctx.beginPath();
            ctx.arc(minion.pos.x, minion.pos.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Minion symbol
            ctx.fillStyle = "#ffffff";
            ctx.font = "12px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("💀", minion.pos.x, minion.pos.y);
            
            ctx.restore();
          }
        }

        // Poison fields
        if (state.poisonFields) {
          for (const field of state.poisonFields) {
            ctx.save();
            
            // Poison field effect - pulsing green circle
            const time = Date.now() / 1000;
            const pulse = 0.7 + 0.3 * Math.sin(time * 3);
            
            ctx.globalAlpha = 0.4 * pulse;
            ctx.fillStyle = "#4caf50";
            ctx.shadowColor = "#4caf50";
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.arc(field.pos.x, field.pos.y, field.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Poison field border
            ctx.globalAlpha = 0.8;
            ctx.strokeStyle = "#8bc34a";
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.restore();
          }
        }

        // Players
        ctx.font =
          "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.textAlign = "center";
        let me = state.players.find((p) => p.id === playerId);
        // Detect local melee edge and record for immediate visuals
        if (me) {
          if (input.melee && !prevMelee) {
            const aimWX_forMelee = camX + input.aimX / zoom;
            const aimWY_forMelee = camY + input.aimY / zoom;
            const dx = aimWX_forMelee - me.x,
              dy = aimWY_forMelee - me.y;
            const d = Math.hypot(dx, dy) || 1;
            localMeleeDirX = dx / d;
            localMeleeDirY = dy / d;
            localMeleeAt = performance.now();
          }
          prevMelee = input.melee;
        }
        // Update and draw dash trails (under players)
        const nowT = performance.now();
        if (state.players) {
          for (const p of state.players) {
            const sp = getSmoothedPos(p.id, p.x, p.y, 0); // position for trail sampling
            let arr = trails.get(p.id) || [];
            // Append when dashing
            if (p.dashing) {
              arr.push({ x: sp.x, y: sp.y, t: nowT });
              if (arr.length > TRAIL_MAX) arr.shift();
            }
            // Prune old
            arr = arr.filter((pt) => nowT - pt.t <= TRAIL_TTL);
            trails.set(p.id, arr);
            // Draw trail
            if (arr.length >= 2) {
              for (let i = 0; i < arr.length; i++) {
                const age = nowT - arr[i].t;
                const a = Math.max(0, 1 - age / TRAIL_TTL);
                const r = 6 + 10 * a;
                ctx.save();
                // teal-ish trail with soft glow
                ctx.globalAlpha = 0.25 + 0.45 * a;
                ctx.fillStyle = "rgba(158,241,209,1)";
                ctx.shadowColor = "rgba(158,241,209,.8)";
                ctx.shadowBlur = 14 * a;
                ctx.beginPath();
                ctx.arc(arr[i].x, arr[i].y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              }
            }
          }
        }

        for (const p of state.players) {
          const sp = getSmoothedPos(p.id, p.x, p.y, dt);
          ctx.save();
          if (p.role === "streamer") {
            ctx.strokeStyle = "#4caf50";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 10, 0, Math.PI * 2);
            ctx.stroke();
            if (p.weaponed) {
              ctx.strokeStyle = "#ffa726";
              ctx.globalAlpha = 0.6;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 14, 0, Math.PI * 2);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }
            ctx.fillStyle = "#4caf50";
            ctx.globalAlpha = 0.95;
            ctx.fillText(p.name, sp.x, sp.y - 16);
          } else {
            ctx.fillStyle = p.alive ? "#ef5350" : "rgba(239,83,80,.25)";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 12, 0, Math.PI * 2);
            ctx.fill();
            // Class outline
            if (p.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (p.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (p.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else if (p.zClass === "stalker") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
            } else if (p.zClass === "bomber") {
              ctx.strokeStyle = "#f44336";
              ctx.lineWidth = 2.5;
            } else {
              ctx.strokeStyle = "#e57373";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, p.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            if (p.boosted) {
              ctx.strokeStyle = "#64b5f6";
              ctx.globalAlpha = 0.7;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 16, 0, Math.PI * 2);
              ctx.stroke();
            }
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.fillText(p.name, sp.x, sp.y - 16);
            // Emote above zombie head for 5s
            if (p.emote && (p.emoteUntil || 0) > Date.now()) {
              ctx.font =
                "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
              ctx.globalAlpha = 1;
              ctx.fillText(p.emote, sp.x, sp.y - 32);
              ctx.font =
                "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            }
          }
          // Bat swing arc visual (short-lived)
          const swingAge = (state.t || Date.now()) - (p.meleeAt || 0);
          if (swingAge >= 0 && swingAge < 220) {
            const alpha = 1 - swingAge / 220;
            const ang = Math.atan2(p.meleeDirY || 0, p.meleeDirX || 1);
            const span = Math.PI / 1.8; // ~100Â°
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              sp.x + Math.cos(ang - span / 2) * r0,
              sp.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              sp.x + Math.cos(ang + span / 2) * r0,
              sp.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
          ctx.restore();
        }

        // Crosshair for local player (world coordinates)
        me = state.players.find((p) => p.id === playerId);
        if (me) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,.5)";
          ctx.beginPath();
          ctx.arc(aimWX, aimWY, 6, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(aimWX - 8, aimWY);
          ctx.lineTo(aimWX + 8, aimWY);
          ctx.moveTo(aimWX, aimWY - 8);
          ctx.lineTo(aimWX, aimWY + 8);
          ctx.stroke();
          ctx.restore();
          // Muzzle flashes rendering
          for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
            const mf = muzzleFlashes[i];
            mf.ttl -= dt;
            if (mf.ttl <= 0) {
              muzzleFlashes.splice(i, 1);
              continue;
            }
            const a = Math.max(0, mf.ttl / 90);
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            ctx.globalAlpha = a;
            const g = ctx.createRadialGradient(mf.x, mf.y, 0, mf.x, mf.y, 18);
            g.addColorStop(0, "rgba(255,220,160,0.9)");
            g.addColorStop(1, "rgba(255,220,160,0)");
            ctx.fillStyle = g;
            ctx.fillRect(mf.x - 20, mf.y - 20, 40, 40);
            ctx.restore();
          }

          // Local predicted bat swing arc so streamer sees swing instantly
          const age = performance.now() - localMeleeAt;
          if (age >= 0 && age < 220) {
            const alpha = 1 - age / 220;
            const ang = Math.atan2(localMeleeDirY, localMeleeDirX);
            const span = Math.PI / 1.8; // ~100Â°
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }

          // Also render server-synced swing for local player (fallback)
          const swingAgeSrv = (state.t || Date.now()) - (me.meleeAt || 0);
          if (swingAgeSrv >= 0 && swingAgeSrv < 220) {
            const alpha = 1 - swingAgeSrv / 220;
            const ang = Math.atan2(me.meleeDirY || 0, me.meleeDirX || 1);
            const span = Math.PI / 1.8;
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
        }

        // End world transform
        // Darkness/lighting overlay in world space
        drawLighting(camX, camY, rect.width / zoom, rect.height / zoom);
        ctx.restore();

        // Dash cooldown indicator (bottom-center) — doubled size
        if (meHud) {
          const readyAt = meHud.dashReadyAt || 0;
          const lastAt = meHud.lastDashAt || 0;
          const nowMs = Date.now();
          const total = Math.max(1, readyAt - lastAt);
          const remain = Math.max(0, readyAt - nowMs);
          const frac = 1 - Math.min(1, remain / total);
          const meterPad = 24; // padding from bottom
          const r2 = 24; // doubled radius
          const cx2 = rect.width / 2;
          const cy2 = rect.height - meterPad - 52; // push up to fit bigger meter
          ctx.save();
          // backdrop behind the meter
          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(18,20,24,.86)";
          ctx.strokeStyle = "rgba(255,255,255,.08)";
          ctx.lineWidth = 2;
          roundRect(ctx, cx2 - 52, cy2 - 52, 104, 110, 28, true, true);
          // background circle
          ctx.beginPath();
          ctx.strokeStyle = "rgba(255,255,255,.18)";
          ctx.lineWidth = 6;
          ctx.arc(cx2, cy2, r2, 0, Math.PI * 2);
          ctx.stroke();
          // progress arc
          ctx.beginPath();
          ctx.strokeStyle = remain <= 0 ? "#2dd4bf" : "#90caf9";
          ctx.lineWidth = 7;
          ctx.arc(
            cx2,
            cy2,
            r2,
            -Math.PI / 2,
            -Math.PI / 2 + Math.PI * 2 * frac
          );
          ctx.stroke();
          // label below meter
          ctx.fillStyle = "#cfd8dc";
          ctx.font =
            "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Dash", cx2, cy2 + 48);
          ctx.restore();
        }

        // Mini-map (bottom-right, circular)
        drawMiniMap();


        // Screen-space border overlay
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#808080";
        ctx.strokeRect(1, 1, rect.width - 2, rect.height - 2);
      }

      // small util for rounded rects on HUD
      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (typeof r === "number") r = { tl: r, tr: r, br: r, bl: r };
        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        ctx.quadraticCurveTo(x, y, x + r.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      function drawMiniMap() {
        const rect = c.getBoundingClientRect();
        const mmSize = 160;
        const pad = 12;
        const cx = rect.width - pad - mmSize / 2;
        const cy = rect.height - pad - mmSize / 2;
        const R = mmSize / 2 - 4;
        const W = (state.arena && state.arena.w) || 960;
        const H = (state.arena && state.arena.h) || 540;
        // Zoom in a bit and center around the local player if available
        const meMM =
          state.players && state.players.find((p) => p.id === playerId);
        const centerX = meMM ? meMM.x : W / 2;
        const centerY = meMM ? meMM.y : H / 2;
        const MM_ZOOM = 1.6; // >1 zooms in
        const scale = (2 * R * MM_ZOOM) / Math.max(W, H);
        // frame
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(18,20,24,.86)";
        ctx.beginPath();
        ctx.arc(cx, cy, mmSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.08)";
        ctx.lineWidth = 2;
        ctx.stroke();
        // clip to circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, Math.PI * 2);
        ctx.clip();
        // walls
        if (state.walls) {
          ctx.strokeStyle = "rgba(255,255,255,.25)";
          ctx.lineWidth = 1;
          for (const w of state.walls) {
            const x = cx + (w.x - centerX) * scale;
            const y = cy + (w.y - centerY) * scale;
            const ww = w.w * scale;
            const hh = w.h * scale;
            ctx.strokeRect(x, y, ww, hh);
          }
        }
        // extractions removed
        // players
        if (state.players) {
          for (const p of state.players) {
            const px = cx + (p.x - centerX) * scale;
            const py = cy + (p.y - centerY) * scale;
            const r = p.role === "streamer" ? 3 : 2;
            ctx.beginPath();
            ctx.fillStyle =
              p.role === "streamer"
                ? "#4caf50"
                : p.alive
                ? "#ef5350"
                : "rgba(239,83,80,.4)";
            ctx.arc(px, py, r, 0, Math.PI * 2);
            ctx.fill();
            if (p.id === playerId) {
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        
        // AI zombies on minimap
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            const px = cx + (zombie.x - centerX) * scale;
            const py = cy + (zombie.y - centerY) * scale;
            ctx.beginPath();
            ctx.fillStyle = zombie.state === "chasing" ? "#ff5722" : zombie.state === "attacking" ? "#d32f2f" : "#ef5350";
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Small state indicator
            if (zombie.state === "chasing" || zombie.state === "attacking") {
              ctx.strokeStyle = zombie.state === "attacking" ? "#d32f2f" : "#ff5722";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        
        // Bosses on minimap
        if (state.bosses) {
          for (const boss of state.bosses) {
            const px = cx + (boss.pos.x - centerX) * scale;
            const py = cy + (boss.pos.y - centerY) * scale;
            const visual = boss.visual || {};
            
            ctx.save();
            
            // Boss icon - larger and more prominent
            ctx.fillStyle = visual.color || "#8B0000";
            ctx.strokeStyle = visual.glowColor || "#ff0000";
            ctx.lineWidth = 2;
            ctx.shadowColor = visual.glowColor || "#ff0000";
            ctx.shadowBlur = 4;
            
            // Pulsing effect for bosses
            const time = Date.now() / 1000;
            const pulse = 0.8 + 0.2 * Math.sin(time * 2);
            const radius = 4 * pulse;
            
            ctx.beginPath();
            ctx.arc(px, py, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Boss symbol on minimap
            ctx.fillStyle = "#ffffff";
            ctx.font = "8px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(visual.minimapIcon || "💀", px, py);
            
            // Enrage indicator
            if (boss.enraged) {
              ctx.strokeStyle = "#ff4444";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(px, py, radius + 2, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            ctx.restore();
          }
        }
        ctx.restore(); // unclip
        ctx.restore();
      }

      function drawTiles(viewX, viewY, viewW, viewH) {
        const m = gameMap;
        if (!m) return;
        const sz = m.size;
        const theme = m.theme || "dungeon";
        const pal =
          theme === "dungeon"
            ? {
                floor: "#0e1115",
                wall: "#2a2f36",
                pit: "#0b0d11",
                water: "#0d1b2a",
                edge: "#9aa4b2",
                propCrate: "#6d4c41",
                propPillar: "#b0bec5",
                propBone: "#8d6e63",
              }
            : theme === "cave"
            ? {
                floor: "#0d1113",
                wall: "#263238",
                pit: "#0a0e10",
                water: "#0b1f2d",
                edge: "#90a4ae",
                propCrate: "#546e7a",
                propPillar: "#90caf9",
                propBone: "#80cbc4",
              }
            : {
                floor: "#111416",
                wall: "#3c4148",
                pit: "#0b0c0d",
                water: "#14212e",
                edge: "#b0bec5",
                propCrate: "#90a4ae",
                propPillar: "#cfd8dc",
                propBone: "#b0bec5",
              };
        const sx = Math.max(0, Math.floor(viewX / sz) - 1),
          sy = Math.max(0, Math.floor(viewY / sz) - 1);
        const ex = Math.min(m.w - 1, Math.ceil((viewX + viewW) / sz) + 1),
          ey = Math.min(m.h - 1, Math.ceil((viewY + viewH) / sz) + 1);
        // Floor
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 0) {
              // floor
              ctx.fillStyle = pal.floor;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Pits/Water
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 2) {
              ctx.fillStyle = pal.pit;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
            if (id === 3) {
              ctx.fillStyle = pal.water;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Walls autotile outline
        const isWall = (ix, iy) =>
          ix >= 0 &&
          iy >= 0 &&
          ix < m.w &&
          iy < m.h &&
          m.tiles[iy * m.w + ix] === 1;
        ctx.fillStyle = pal.wall;
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            if (!isWall(x, y)) continue;
            const px = x * sz,
              py = y * sz;
            ctx.fillRect(px, py, sz, sz);
            ctx.strokeStyle = pal.edge;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.15;
            if (!isWall(x, y - 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px + sz, py);
              ctx.stroke();
            }
            if (!isWall(x + 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px + sz, py);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x, y + 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py + sz);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x - 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px, py + sz);
              ctx.stroke();
            }
            ctx.globalAlpha = 1;
          }
        }
        // Props
        for (const p of m.props || []) {
          const px = p.x * sz,
            py = p.y * sz;
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle =
            p.type === "crate"
              ? pal.propCrate
              : p.type === "pillar"
              ? pal.propPillar
              : pal.propBone;
          ctx.fillRect(px + 4, py + 4, sz - 8, sz - 8);
          ctx.restore();
        }
        // Lights (simple ambient blit)
        for (const l of m.lights || []) {
          const cx = l.x * sz + sz / 2,
            cy = l.y * sz + sz / 2;
          const rr = l.r * sz;
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rr);
          g.addColorStop(0, `rgba(255,255,200,${0.35 * l.a})`);
          g.addColorStop(1, "rgba(255,255,200,0)");
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = g;
          ctx.fillRect(cx - rr, cy - rr, rr * 2, rr * 2);
          ctx.restore();
        }
      }
        ctx.restore();
      
        
        ctx.restore();
      
      function drawLighting(viewX, viewY, viewW, viewH) {
        // Lighting system temporarily disabled to remove dots
        return;
      }

      function updatePlayerList(players) {
        playersEl.innerHTML = players
          .map(
            (p) =>
              `<span class="pill ${p.role}">${
                p.role === "streamer" ? "🟢" : "🧟"
              } ${p.name}${p.role === "streamer" ? " · " + p.score : ""}</span>`
          )
          .join(" ");
      }

      function flash() {
        flashEl.classList.add("show");
        setTimeout(() => flashEl.classList.remove("show"), 150);
      }

      function updateTimer(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = seconds % 60;
        timerEl.textContent = `Time: ${min}:${sec.toString().padStart(2, "0")}`;
      }

      function appendChat(from, message) {
        chatMessagesEl.innerHTML += `<div>${from}: ${message}</div>`;
        while (chatMessagesEl.children.length > 10) {
          chatMessagesEl.removeChild(chatMessagesEl.firstChild);
        }
      }

      function sendChat(msg) {
        if (ws && ws.readyState === 1)
          ws.send(JSON.stringify({ type: "chat", message: msg }));
      }

      // Animation loop for effects and smoother visuals
      let last = performance.now();
      const fpsSamples = [];
      const fpsWindow = 120; // ~2s at 60fps
      let lastNerdUpdate = 0;
      lastHp = 100;
      function loop() {
        const now = performance.now();
        const dt = now - last;
        last = now;
        draw(dt);
        // FPS tracking
        const fps = dt > 0 ? 1000 / dt : 0;
        fpsSamples.push(fps);
        if (fpsSamples.length > fpsWindow) fpsSamples.shift();
        // State messages per second
        if (now - lastStateRateAt >= 1000) {
          statesPerSec = stateMsgCount;
          stateMsgCount = 0;
          lastStateRateAt = now;
        }
        // Update nerd overlay at ~4Hz
        if (nerdOn && now - lastNerdUpdate > 250) {
          const avgFps = fpsSamples.length
            ? fpsSamples.reduce((a, b) => a + b, 0) / fpsSamples.length
            : 0;
          const minFps = fpsSamples.length ? Math.min(...fpsSamples) : 0;
          const maxFps = fpsSamples.length ? Math.max(...fpsSamples) : 0;
          const lat = latency
            ? latency.getLatencyStats()
            : { avg: 0, min: 0, max: 0, jitter: 0 };
          const players = state.players?.length || 0;
          const zombies =
            state.players?.filter((p) => p.role === "zombie").length || 0;
          const bullets = state.bullets?.length || 0;
          const pickups = state.pickups?.length || 0;
          const walls = state.walls?.length || 0;
          const wsBuf = (ws && ws.bufferedAmount) || 0;
          nerdPanel.innerHTML = `
          <div><strong>Nerd Stats</strong></div>
          <div>FPS: ${avgFps.toFixed(1)} (min ${minFps.toFixed(
            0
          )} max ${maxFps.toFixed(0)})</div>
          <div>Latency: ${lat.avg.toFixed(1)} ms (min ${lat.min.toFixed(
            0
          )} max ${lat.max.toFixed(0)}) jitter ${lat.jitter.toFixed(1)} ms</div>
          <div>States/s: ${statesPerSec.toFixed(0)}</div>
          <div>Entities: players ${players} (z ${zombies}) bullets ${bullets} pickups ${pickups} walls ${walls}</div>
          <div>WS buf: ${wsBuf}</div>
        `;
          lastNerdUpdate = now;
        }
        requestAnimationFrame(loop);
      }
      loop();

      // Weapon switching
      function sendSwitchWeapon(w) {
        if (ws && ws.readyState === 1)
          ws.send(JSON.stringify({ type: "switch_weapon", weapon: w }));
      }
      document.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        if (e.key === "1") sendSwitchWeapon("pistol");
        if (e.key === "2") sendSwitchWeapon("smg");
        if (e.key === "3") sendSwitchWeapon("shotgun");
        if (e.key === "4") {
          // Attempt shotgun purchase
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "shotgun" }));
        }
        if (e.key === "5") {
          // Attempt SMG purchase
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "smg" }));
        }
        // Extraction removed; X key unused
      });
      document.querySelectorAll(".weapon").forEach((btn) =>
        btn.addEventListener("click", (e) => {
          const el = e.currentTarget;
          const w = el && el.getAttribute("data-weapon");
          if (!w) return;
          // Guard against selecting locked weapons
          if (el.classList.contains("locked")) {
            try {
              import("/common.js").then(
                (m) => m.toast && m.toast("Locked: unlock with banked first")
              );
            } catch {}
            return;
          }
          sendSwitchWeapon(w);
        })
      );
      if (buyShotgunBtn) {
        buyShotgunBtn.addEventListener("click", () => {
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "shotgun" }));
        });
      }
      if (buySmgBtn) {
        buySmgBtn.addEventListener("click", () => {
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "smg" }));
        });
      }

      // Fullscreen toggle
      document.getElementById("fullscreen").onclick = async () => {
        if (!document.fullscreenElement) {
          await document.documentElement.requestFullscreen().catch(() => {});
        } else {
          await document.exitFullscreen().catch(() => {});
        }
      };

      newBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (ws && ws.readyState === 1) {
          leaveRoom(true);
        } else {
          boot();
        }
      };
      copyBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (!copyBtn.disabled && link.value) {
          navigator.clipboard.writeText(link.value);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        }
      };
      toggleChatBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (!ws || ws.readyState !== 1) return;
        // Flip desired state based on button label
        const enable = toggleChatBtn.textContent.includes("Enable");
        ws.send(JSON.stringify({ type: "toggle_chat", disabled: !enable }));
      };

      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && chatInput.value.trim()) {
          sendChat(chatInput.value.trim());
          chatInput.value = "";
        }
      });

      // Death screen button event listeners
      if (restartRaidBtn) {
        restartRaidBtn.addEventListener("click", restartRaid);
      }
      
      if (exitToMenuBtn) {
        exitToMenuBtn.addEventListener("click", exitToMenu);
      }

    </script>
  </body>
</html>
</file>

<file path="src/room.ts">
export { RoomDO } from './room/index';
export type { Env } from './room/index';
</file>

</files>
