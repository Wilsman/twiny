<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arena Shooter ‚Äî Join as Zombie</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="game">
  <div class="topbar">
    <div class="brand">Arena Shooter</div>
    <div class="middle-controls">
      <span class="badge" id="status" data-state="disconnected">disconnected</span>
    </div>
    <div class="right-controls">
      <button id="fullscreen">Fullscreen</button>
      <button id="nerdToggle">Nerd Stats</button>
    </div>
  </div>

  <div class="app">
    <div class="main">
      <div class="stage"></div>
    </div>
    <aside class="sidebar">
      <div class="card">
        <div class="card-title">Join</div>
        <div class="row">
          <label for="name" class="badge">Name</label>
          <input id="name" />
        </div>
        <div class="row">
          <button id="shuffle">Random</button>
          <button id="join">Join</button>
          <span class="badge" id="timer">Time: --</span>
        </div>
        <div class="tip">WASD to move. You are a slow zombie; touch the streamer to drain their score.</div>
      </div>

      <div class="card">
        <div class="card-title">Emotes</div>
        <div id="emoteBar">
          <button class="emote">üßü</button>
          <button class="emote">üíÄ</button>
          <button class="emote">üî•</button>
          <button class="emote">üòÇ</button>
          <button class="emote">‚ù§Ô∏è</button>
          <button class="emote">üí¢</button>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Players</div>
        <div class="pill-list" id="players"></div>
      </div>

      <div class="card">
        <div class="card-title">Chat</div>
        <div id="chatMessages" class="chat-messages"></div>
        <div class="row"><input id="chatInput" placeholder="Chat..." /></div>
      </div>
    </aside>
  </div>

  <div id="raidEndOverlay" class="raid-end-overlay hidden">
    <div class="raid-end-card">
      <div class="raid-end-title">Streamer Down!</div>
      <p class="raid-end-description" id="raidEndDescription">
        The streamer has been defeated. Waiting for the next raid...
      </p>
      <div class="raid-end-leaderboard" id="raidEndLeaderboardWrapper">
        <div class="raid-end-label">Top zombies this round</div>
        <ol id="raidEndLeaderboard"></ol>
      </div>
      <div class="raid-end-actions">
        <button id="raidEndStay">Stay for restart</button>
        <button id="raidEndLeave" class="raid-end-leave">Return to menu</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { connect, nameStorage, minimalCanvas, suppressPageHotkeys, inputController, createLatencyMonitor } from '/common.js';

    const params = new URLSearchParams(location.search);
    let roomId = params.get('room') || '';

    const { c, ctx } = minimalCanvas(1440, 810);
    suppressPageHotkeys();
    let ws, playerId, arena={w:960,h:540};
    let state = { players:[], bullets:[], arena, remainingTime: 0 };
    let gameMap = null; // {w,h,size,theme,tiles:Uint8Array, props, lights}
    const input = inputController({ mouse:true });
    const effects = []; // transient bullet/impact particles
    // Damage numbers for floating damage display
    let damageNumbers = [];
    let roundActive = false;
    // Smoothing for 20Hz -> 60fps render
    const smooth = new Map(); // id -> {x,y}
    const SMOOTH_TAU = 90; // ms
    function getSmoothedPos(id, tx, ty, dt){
      let s = smooth.get(id);
      if (!s) { s = { x: tx, y: ty }; smooth.set(id, s); return { x: tx, y: ty }; }
      const alpha = 1 - Math.exp(-dt / Math.max(1, SMOOTH_TAU));
      s.x += (tx - s.x) * alpha;
      s.y += (ty - s.y) * alpha;
      return { x: s.x, y: s.y };
    }
    // Dash trails for streamer visibility from zombie clients
    const trails = new Map(); // id -> Array<{x:number,y:number,t:number}>
    const TRAIL_TTL = 260; const TRAIL_MAX = 22;
    let prevBullets = new Map();
    const bulletTrailHistory = new Map();

    const status = document.getElementById('status');
    const playersEl = document.getElementById('players');
    const nameEl = document.getElementById('name');
    const joinBtn = document.getElementById('join');
    // Join URL / code input
    const roomUrlInput = document.createElement('input');
    roomUrlInput.id = 'roomUrl';
    roomUrlInput.className = 'mono';
    roomUrlInput.placeholder = 'Room URL or code';
    // Insert into the Join card under name row
    const joinCard = document.querySelector('.sidebar .card');
    if (joinCard) {
      const row = document.createElement('div'); row.className = 'row'; row.appendChild(roomUrlInput);
      joinCard.insertBefore(row, joinCard.children[2]);
    }
    if (roomId) roomUrlInput.value = `${location.origin}/join.html?room=${roomId}`;
    roomUrlInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') joinBtn.click(); });
    const shuffleBtn = document.getElementById('shuffle');
    const timerEl = document.getElementById('timer');
    const emoteBar = document.getElementById('emoteBar');
    const chatInput = document.getElementById('chatInput');
    const chatMessagesEl = document.getElementById('chatMessages');
    const nerdToggleBtn = document.getElementById('nerdToggle');
    const raidEndOverlay = document.getElementById('raidEndOverlay');
    const raidEndDescription = document.getElementById('raidEndDescription');
    const raidEndLeaderboard = document.getElementById('raidEndLeaderboard');
    const raidEndStayBtn = document.getElementById('raidEndStay');
    const raidEndLeaveBtn = document.getElementById('raidEndLeave');

    const updateBulletTrail = (id, x, y, now) => {
      const existing = bulletTrailHistory.get(id) || [];
      const filtered = existing.filter((pt) => now - pt.t < 280);
      filtered.push({ x, y, t: now });
      if (filtered.length > 8) filtered.shift();
      bulletTrailHistory.set(id, filtered);
      return filtered;
    };

    const seededRand = (seed, step = 0) => {
      const x = Math.sin((seed + 1) * 12.9898 + step * 78.233) * 43758.5453;
      return x - Math.floor(x);
    };

    const resolveBulletWeapon = (bullet, playerLookup) => {
      const hint = bullet?.visual?.weapon;
      if (hint && hint !== 'bat') return hint;
      if (playerLookup?.has?.(bullet.ownerId)) {
        const weapon = playerLookup.get(bullet.ownerId)?.weapon;
        if (weapon && weapon !== 'bat') return weapon;
      } else if (state?.players) {
        const owner = state.players.find((p) => p.id === bullet.ownerId);
        if (owner?.weapon && owner.weapon !== 'bat') return owner.weapon;
      }
      if (hint === 'bat') return 'pistol';
      return hint || 'pistol';
    };

    const spawnBulletImpact = (bullet) => {
      if (!bullet) return;
      const trail = bulletTrailHistory.get(bullet.id);
      let angle = 0;
      if (trail && trail.length >= 2) {
        const last = trail[trail.length - 1];
        const prev = trail[trail.length - 2];
        angle = Math.atan2(last.y - prev.y, last.x - prev.x) || 0;
      }
      bulletTrailHistory.delete(bullet.id);
      const weapon = resolveBulletWeapon(bullet);
      const traits = bullet.visual?.traits ? [...bullet.visual.traits] : [];
      const normalized = weapon === 'bat' ? 'pistol' : weapon;
      const duration = normalized === 'railgun' ? 420 : normalized === 'shotgun' ? 300 : normalized === 'flamethrower' ? 260 : 220;
      const seed = [...(bullet.id || '')].reduce((acc, ch) => acc + ch.charCodeAt(0), 0) || Math.floor(Math.random() * 1000);
      effects.push({
        type: 'impact',
        weapon: normalized,
        traits,
        x: bullet.x,
        y: bullet.y,
        angle,
        ttl: duration,
        duration,
        seed,
      });
    };

    const drawBulletTraits = (ctx, x, y, traits, now) => {
      if (!traits || traits.length === 0) return;
      const traitSet = new Set(traits);
      const pulse = 0.5 + 0.5 * Math.sin(now * 0.01 + x * 0.05 + y * 0.05);
      ctx.save();
      if (traitSet.has('burn')) {
        ctx.globalAlpha = 0.4 + 0.25 * pulse;
        ctx.strokeStyle = 'rgba(255, 138, 101, 0.85)';
        ctx.lineWidth = 1.6;
        ctx.beginPath();
        ctx.arc(x, y, 6.5 + pulse * 2, 0, Math.PI * 2);
        ctx.stroke();
      }
      if (traitSet.has('slow')) {
        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = 'rgba(129, 212, 250, 0.75)';
        ctx.lineWidth = 1.1;
        ctx.beginPath();
        ctx.arc(x, y, 8.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - 5);
        ctx.lineTo(x, y + 5);
        ctx.moveTo(x - 4, y);
        ctx.lineTo(x + 4, y);
        ctx.stroke();
      }
      if (traitSet.has('bleed')) {
        ctx.globalAlpha = 0.65;
        ctx.fillStyle = 'rgba(244, 67, 54, 0.75)';
        ctx.beginPath();
        ctx.moveTo(x, y - 3);
        ctx.quadraticCurveTo(x - 3, y + 2, x, y + 6);
        ctx.quadraticCurveTo(x + 3, y + 2, x, y - 3);
        ctx.fill();
      }
      if (traitSet.has('chain')) {
        ctx.globalAlpha = 0.6;
        ctx.strokeStyle = 'rgba(167, 255, 235, 0.9)';
        ctx.lineWidth = 1;
        const spin = (now * 0.006) % (Math.PI * 2);
        ctx.beginPath();
        ctx.arc(x, y, 9.5, spin, spin + Math.PI / 3);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x, y, 9.5, spin + Math.PI, spin + Math.PI + Math.PI / 3);
        ctx.stroke();
      }
      if (traitSet.has('ricochet')) {
        ctx.globalAlpha = 0.6;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y - 6);
        ctx.lineTo(x + 4, y);
        ctx.lineTo(x, y + 6);
        ctx.lineTo(x - 4, y);
        ctx.closePath();
        ctx.stroke();
      }
      if (traitSet.has('pierce')) {
        ctx.globalAlpha = 0.55;
        ctx.strokeStyle = 'rgba(255, 241, 118, 0.85)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x - 6, y);
        ctx.lineTo(x + 6, y);
        ctx.moveTo(x, y - 6);
        ctx.lineTo(x, y + 6);
        ctx.stroke();
      }
      ctx.restore();
    };

    const drawWeaponBullet = (ctx, bullet, weapon, traits, opts) => {
      const { angle, dist, empowered, now } = opts;
      const x = bullet.x;
      const y = bullet.y;
      switch (weapon) {
        case 'smg': {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle);
          const tailLen = Math.min(34, Math.max(14, dist * 7 + 6));
          const grad = ctx.createLinearGradient(0, 0, -tailLen, 0);
          grad.addColorStop(0, 'rgba(128, 222, 234, 0.95)');
          grad.addColorStop(0.45, 'rgba(3, 169, 244, 0.7)');
          grad.addColorStop(1, 'rgba(3, 169, 244, 0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.moveTo(2.5, -1.8);
          ctx.lineTo(-tailLen, -0.4);
          ctx.lineTo(-tailLen, 0.4);
          ctx.lineTo(2.5, 1.8);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = 'rgba(3, 169, 244, 0.85)';
          ctx.lineWidth = empowered ? 1.6 : 1.2;
          ctx.beginPath();
          ctx.moveTo(2.5, 0);
          ctx.lineTo(-tailLen, 0);
          ctx.stroke();
          ctx.restore();
          break;
        }
        case 'shotgun': {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle);
          const burst = Math.max(9, dist * 4);
          for (let i = 0; i < 3; i++) {
            ctx.strokeStyle = 'rgba(255, 183, 77, 0.85)';
            ctx.lineWidth = 1.4 - i * 0.2;
            ctx.globalAlpha = 0.9 - i * 0.2;
            const offset = (i - 1) * 1.1;
            ctx.beginPath();
            ctx.moveTo(0, offset);
            ctx.lineTo(-burst * (1 - i * 0.25), offset);
            ctx.stroke();
          }
          ctx.globalAlpha = 0.95;
          ctx.shadowColor = 'rgba(255, 171, 64, 0.7)';
          ctx.shadowBlur = empowered ? 26 : 16;
          ctx.fillStyle = 'rgba(255, 138, 101, 0.9)';
          ctx.beginPath();
          ctx.arc(0, 0, empowered ? 4.4 : 3.6, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          break;
        }
        case 'railgun': {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle);
          const tailLen = Math.min(150, Math.max(70, dist * 14 + 40));
          const grad = ctx.createLinearGradient(0, 0, -tailLen, 0);
          grad.addColorStop(0, 'rgba(187, 222, 251, 0.98)');
          grad.addColorStop(0.4, 'rgba(100, 181, 246, 0.7)');
          grad.addColorStop(1, 'rgba(30, 136, 229, 0)');
          ctx.strokeStyle = grad;
          ctx.lineWidth = empowered ? 5 : 4;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-tailLen, 0);
          ctx.stroke();
          ctx.shadowColor = 'rgba(225, 245, 254, 0.9)';
          ctx.shadowBlur = empowered ? 40 : 28;
          ctx.fillStyle = '#bbdefb';
          ctx.globalAlpha = 0.95;
          ctx.beginPath();
          ctx.arc(0, 0, empowered ? 6 : 5.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          break;
        }
        case 'flamethrower': {
          const tailLen = Math.min(32, Math.max(10, dist * 6));
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle);
          const trailGrad = ctx.createLinearGradient(0, 0, -tailLen, 0);
          trailGrad.addColorStop(0, 'rgba(255, 183, 77, 0.8)');
          trailGrad.addColorStop(1, 'rgba(255, 111, 0, 0)');
          ctx.fillStyle = trailGrad;
          ctx.beginPath();
          ctx.moveTo(0, -2.4);
          ctx.lineTo(-tailLen, -0.8);
          ctx.lineTo(-tailLen, 0.8);
          ctx.lineTo(0, 2.4);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
          const pulse = 0.6 + 0.4 * Math.sin(now * 0.03 + x * 0.04 + y * 0.02);
          const radius = 5.2 + pulse * 2.6;
          const glow = ctx.createRadialGradient(x, y, 0, x, y, radius);
          glow.addColorStop(0, 'rgba(255, 249, 196, 0.95)');
          glow.addColorStop(0.4, 'rgba(255, 202, 40, 0.85)');
          glow.addColorStop(1, 'rgba(255, 87, 34, 0)');
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 0.45;
          ctx.fillStyle = 'rgba(255, 183, 77, 0.55)';
          const driftX = Math.cos(now * 0.01 + x * 0.03) * 3.5;
          const driftY = Math.sin(now * 0.013 + y * 0.02) * 3.5;
          ctx.beginPath();
          ctx.arc(x - driftX, y - driftY, radius * 0.6, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          break;
        }
        default: {
          ctx.save();
          ctx.translate(x, y);
          if (dist > 0.2) {
            ctx.rotate(angle);
            const tailLen = Math.min(28, Math.max(10, dist * 6));
            const grad = ctx.createLinearGradient(0, 0, -tailLen, 0);
            grad.addColorStop(0, empowered ? 'rgba(255, 255, 224, 0.95)' : 'rgba(255, 236, 179, 0.95)');
            grad.addColorStop(1, 'rgba(255, 193, 7, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(0, -2.2);
            ctx.lineTo(-tailLen, -0.5);
            ctx.lineTo(-tailLen, 0.5);
            ctx.lineTo(0, 2.2);
            ctx.closePath();
            ctx.fill();
          }
          ctx.globalAlpha = 1;
          ctx.shadowColor = empowered ? 'rgba(255, 255, 224, 0.9)' : 'rgba(255, 214, 123, 0.8)';
          ctx.shadowBlur = empowered ? 24 : 12;
          ctx.fillStyle = empowered ? '#fff8e1' : '#ffe082';
          ctx.beginPath();
          ctx.arc(0, 0, empowered ? 4.6 : 3.4, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          break;
        }
      }
      drawBulletTraits(ctx, x, y, traits, now);
    };

    const renderBullet = (ctx, bullet, now, playerLookup) => {
      const trail = updateBulletTrail(bullet.id, bullet.x, bullet.y, now);
      const len = trail.length;
      const prev = len >= 2 ? trail[len - 2] : null;
      const curr = trail[len - 1];
      const dx = prev ? curr.x - prev.x : 0;
      const dy = prev ? curr.y - prev.y : 0;
      const dist = Math.hypot(dx, dy);
      const angle = prev ? Math.atan2(dy, dx) : 0;
      const weapon = resolveBulletWeapon(bullet, playerLookup);
      const ownerEmpowered = playerLookup?.get?.(bullet.ownerId)?.weaponed;
      const empowered = Boolean(bullet.visual?.empowered || ownerEmpowered);
      drawWeaponBullet(ctx, bullet, weapon, bullet.visual?.traits || [], { angle, dist, empowered, now });
    };

    // Nerd panel overlay element
    const nerdPanel = document.createElement('div');
    nerdPanel.id = 'nerdPanel';
    nerdPanel.className = 'nerd-panel hidden mono';
    document.body.appendChild(nerdPanel);

    let nerdOn = localStorage.getItem('nerdStats') === '1';
    function setNerd(on){
      nerdOn = !!on;
      localStorage.setItem('nerdStats', nerdOn ? '1' : '0');
      nerdPanel.classList.toggle('hidden', !nerdOn);
      nerdToggleBtn.classList.toggle('active', nerdOn);
    }
    setNerd(nerdOn);
    nerdToggleBtn.onclick = () => setNerd(!nerdOn);

    // preload name
    nameEl.value = nameStorage().get() || '';

    function randomName(){
      const pool = ("KibaRogue,WoodsScav,ShorelineRat,FactoryGhost,LabsRunner,InterchangeChad,DormsGoblin,ReserveMole,FleaFlipper,TetrizHoarder,LedXHunter,SlickSeeker,RSASSEnjoyer,M995Enjoyer,GrenadierGoon,SanitarStan,KillaChaser,TagillaTapper,GluharGuy,ShturmanScout,KnightWatcher,RogueRaider,USECFriend,BEARBuddy,JaegerPal,FenceFella,TherapistAlly,RagmanRigger,SkierSlinger,PraporPatron,MechanicMain,PeacekeeperPro,LabsRat,MarkedRoomMole,StashGremlin,MoonshineMax,ScavJunkie,OmComEnjoyer,SJ6Sprinter,AltynAddict,ThermalAndy,GreenBatteryGuy,DormsKeyKing,GPUGoblin,AmmoArbiter,WaffleFilter").split(",");
      return pool[Math.floor(Math.random()*pool.length)];
    }

    document.getElementById('shuffle').onclick = (ev) => { nameEl.value = randomName(); if (ev.currentTarget && ev.currentTarget.blur) ev.currentTarget.blur(); };

    function sendChat(msg) {
      if (ws && ws.readyState===1) ws.send(JSON.stringify({ type:'chat', message: msg }));
    }

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && chatInput.value.trim()) {
        sendChat(chatInput.value.trim());
        chatInput.value = '';
      }
    });

    function appendChat(from, message) {
      chatMessagesEl.innerHTML += `<div>${from}: ${message}</div>`;
      while (chatMessagesEl.children.length > 10) {
        chatMessagesEl.removeChild(chatMessagesEl.firstChild);
      }
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    let sendNeutralHandler = null; let visHandler = null; let inputIv = null;
    let pingIv = null; let latency = null; let stateMsgCount = 0; let statesPerSec = 0; let lastStateRateAt = performance.now();
    function leave(){
      if (ws) { try { if (ws.readyState===1) ws.close(1000,'leave'); } catch{} ws=null; }
      status.textContent = 'disconnected';
      status.dataset.state = 'disconnected';
      document.body.classList.remove('connected');
      joinBtn.textContent = 'Join';
      nameEl.disabled = false; shuffleBtn.disabled = false;
      if (inputIv) { clearInterval(inputIv); inputIv = null; }
      if (pingIv) { clearInterval(pingIv); pingIv = null; }
      if (sendNeutralHandler) { window.removeEventListener('blur', sendNeutralHandler); sendNeutralHandler=null; }
      if (visHandler) { document.removeEventListener('visibilitychange', visHandler); visHandler=null; }
      roundActive = false;
      damageNumbers = [];
      trails.clear();
      prevBullets = new Map();
      bulletTrailHistory.clear();
      effects.length = 0;
      hideRaidEndOverlay();
    }

    const roundEndCauseMessages = {
      zombie_touch: 'The horde swarmed the streamer!',
      ai_zombie_touch: 'An AI zombie landed the final blow.',
      pit: 'The streamer fell into a pit.',
      spikes: 'The streamer was impaled on spikes.',
      poison: 'A poison cloud finished the streamer.',
    };

    function formatRoundEndCause(cause) {
      if (!cause) return 'The streamer has been defeated!';
      return roundEndCauseMessages[cause] || 'The streamer has been defeated!';
    }

    function renderRaidEndLeaderboard(players) {
      if (!raidEndLeaderboard) return;
      raidEndLeaderboard.innerHTML = '';
      const zombies = (players || []).filter(p => p.role === 'zombie');
      if (!zombies.length) {
        const li = document.createElement('li');
        li.className = 'raid-end-empty';
        li.textContent = 'No zombies were in the raid.';
        raidEndLeaderboard.appendChild(li);
        return;
      }
      const sorted = zombies.slice().sort((a, b) => (b.score || 0) - (a.score || 0));
      const top = sorted.slice(0, 5);
      for (const [idx, player] of top.entries()) {
        const li = document.createElement('li');
        const rank = document.createElement('span');
        rank.className = 'raid-end-rank';
        rank.textContent = `#${idx + 1}`;
        const name = document.createElement('span');
        name.className = 'raid-end-name';
        name.textContent = player.name || 'Zombie';
        const score = document.createElement('span');
        score.className = 'raid-end-score';
        score.textContent = (player.score || 0).toLocaleString();
        li.appendChild(rank);
        li.appendChild(name);
        li.appendChild(score);
        raidEndLeaderboard.appendChild(li);
      }
    }

    function showRaidEndOverlay(payload) {
      if (!raidEndOverlay) return;
      if (raidEndDescription) {
        raidEndDescription.textContent = formatRoundEndCause(payload?.cause);
      }
      renderRaidEndLeaderboard(state.players);
      raidEndOverlay.classList.remove('hidden');
    }

    function hideRaidEndOverlay() {
      if (!raidEndOverlay) return;
      raidEndOverlay.classList.add('hidden');
    }

    raidEndStayBtn?.addEventListener('click', () => {
      hideRaidEndOverlay();
    });

    raidEndLeaveBtn?.addEventListener('click', () => {
      hideRaidEndOverlay();
      leave();
      window.location.href = '/index.html';
    });

    function extractRoomId(val){
      const s = String(val||'').trim();
      if (!s) return '';
      try {
        const u = new URL(s);
        const q = u.searchParams.get('room');
        if (q) return q;
      } catch {}
      // fallback: treat as code
      return s;
    }

    joinBtn.onclick = (ev) => {
      if (ws && ws.readyState===1) { leave(); return; }
      const provided = extractRoomId(roomUrlInput.value);
      if (provided) roomId = provided;
      if (!roomId) { alert('Missing room id'); return; }
      const name = (nameEl.value||'').slice(0,20);
      nameStorage().set(name);
      if (ev.currentTarget && ev.currentTarget.blur) ev.currentTarget.blur();
      ws = connect(roomId);
      ws.addEventListener('open', () => {
        status.textContent = 'connected';
        status.dataset.state = 'connected';
        document.body.classList.add('connected');
        roundActive = true;
        ws.send(JSON.stringify({ type:'join_room', role:'zombie', name }));
        joinBtn.textContent = 'Leave';
        nameEl.disabled = true; shuffleBtn.disabled = true;
      });
      latency = createLatencyMonitor(ws);
      if (pingIv) { clearInterval(pingIv); pingIv = null; }
      pingIv = setInterval(() => { try { latency.sendPing(); } catch {} }, 1000);
      ws.addEventListener('message', (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'map') {
          try {
            const m = msg.map; const bin = atob(m.tilesBase64);
            const u8 = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
            gameMap = { w:m.w, h:m.h, size:m.size, theme:m.theme, tiles:u8, props:m.props||[], lights:m.lights||[] };
          } catch {}
        }
        if (msg.type === 'joined') { arena = msg.arena; playerId = msg.playerId; }
        if (msg.type === 'round_end') {
          roundActive = false;
          status.textContent = 'connected ‚Ä¢ raid ended';
          status.dataset.state = 'ended';
          appendChat('System', 'Raid ended');
          showRaidEndOverlay(msg);
        }
        if (msg.type === 'round_restart') {
          roundActive = true;
          status.textContent = 'connected ‚Ä¢ restarting raid';
          status.dataset.state = 'connected';
          damageNumbers = [];
          trails.clear();
          prevBullets = new Map();
          bulletTrailHistory.clear();
          effects.length = 0;
          hideRaidEndOverlay();
        }
        if (msg.type === 'state') {
          stateMsgCount++;
          roundActive = msg.roundActive !== false;
          // impact effects
          const curMap = new Map(msg.bullets.map(b=>[b.id,b]));
          for (const [id, prev] of prevBullets) {
            if (!curMap.has(id)) spawnBulletImpact(prev);
          }
          prevBullets = curMap;

          // Process damage numbers
          if (msg.damageNumbers) {
            for (const dn of msg.damageNumbers) {
              // Check if we already have this damage number
              if (!damageNumbers.some(existing => existing.id === dn.id)) {
                damageNumbers.push({
                  id: dn.id,
                  x: dn.x,
                  y: dn.y,
                  damage: dn.damage,
                  isCrit: dn.isCrit,
                  isDot: dn.isDot,
                  timestamp: dn.timestamp,
                  startTime: Date.now(),
                  offsetY: 0
                });
              }
            }
          }

          state = msg; const ping = Math.max(0, Date.now() - (msg.t||Date.now()));
          if (roundActive) {
            status.textContent = `connected ‚Ä¢ ${ping} ms ‚Ä¢ players: ${msg.players.length}`;
            status.dataset.state = 'connected';
          } else {
            status.textContent = 'connected ‚Ä¢ raid ended';
            status.dataset.state = 'ended';
            renderRaidEndLeaderboard(msg.players);
          }
          state.remainingTime = msg.remainingTime;
          updateTimer(state.remainingTime);
          updatePlayerList(msg.players);
          // Respect chat enabled/disabled from server
          if (typeof msg.chatEnabled === 'boolean') {
            chatInput.disabled = !msg.chatEnabled;
            chatInput.placeholder = msg.chatEnabled ? 'Chat...' : 'Chat disabled by streamer';
            const chatCard = chatMessagesEl.closest('.card');
          if (chatCard) chatCard.classList.toggle('hidden', !msg.chatEnabled);
          }
        }
        if (msg.type === 'pong') {
          if (latency) latency.handlePong(Number(msg.timestamp)||0);
        }
        if (msg.type === 'chat') {
          appendChat(msg.from, msg.message);
        }
        if (msg.type === 'notice') {
          appendChat('System', msg.message);
        }
      });
      // Send continuous movement state for smooth input like streamer
      inputIv = setInterval(() => {
        if (ws && ws.readyState===1 && roundActive) {
          const { up,down,left,right,shoot } = input;
          const aimWX = camX + (input.aimX / zoom);
          const aimWY = camY + (input.aimY / zoom);
          ws.send(JSON.stringify({ type:'input', up, down, left, right, shoot, melee:false, dash:false, aimX:aimWX, aimY:aimWY }));
        }
      }, 50);

      // If the tab loses focus while holding a key, send a neutral input
      sendNeutralHandler = () => { if (ws && ws.readyState===1 && roundActive) ws.send(JSON.stringify({ type:'input', up:false, down:false, left:false, right:false, shoot:false, melee:false, dash:false, aimX:0, aimY:0 })); };
      visHandler = () => { if (document.hidden) sendNeutralHandler(); };
      window.addEventListener('blur', sendNeutralHandler);
      document.addEventListener('visibilitychange', visHandler);

      ws.addEventListener('close', () => { leave(); }, { once: true });
    };

    // Emote palette: send selected emoji to server (zombies only)
    emoteBar.addEventListener('click', (e) => {
      const target = e.target;
      if (!target || !(target instanceof HTMLElement) || !target.classList.contains('emote')) return;
      const symbol = target.textContent || '';
      if (!ws || ws.readyState !== 1) return;
      ws.send(JSON.stringify({ type: 'emote', symbol }));
    });

    // Simple camera for zombies: follow self
    let camX = 0, camY = 0;
    const zoom = 2.4; // match streamer view
    function draw(dt=16){
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
      const rect = c.getBoundingClientRect();
      const frameNow = performance.now();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,c.width,c.height);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      // Fill background with dungeon-themed dark color in CSS px
      ctx.fillStyle = "#0a0c0f";
      ctx.fillRect(0,0,rect.width,rect.height);
      // Update camera target (follow me)
      let meRaw = state.players.find(p=>p.id===playerId);
      if (!meRaw && state.players && state.players.length) {
        meRaw = state.players.find(p=>p.role==='zombie') || state.players[0];
      }
      const meCam = meRaw ? getSmoothedPos(meRaw.id, meRaw.x, meRaw.y, dt) : null;
      if (meCam) {
        const viewW = rect.width / zoom, viewH = rect.height / zoom;
        const targetX = Math.min(Math.max(0, meCam.x - viewW/2), Math.max(0, arena.w - viewW));
        const targetY = Math.min(Math.max(0, meCam.y - viewH/2), Math.max(0, arena.h - viewH));
        const k = Math.min(1, (dt/16) * 0.12);
        camX = camX + (targetX - camX) * k;
        camY = camY + (targetY - camY) * k;
      }

      // World transform
      ctx.save();
      ctx.scale(zoom, zoom);
      ctx.translate(-camX, -camY);
      // Tiles first
      if (gameMap) drawTiles(camX, camY, rect.width/zoom, rect.height/zoom);
      // Walls/rooms
      if (state.walls){
        ctx.fillStyle = '#2a2f36';
        for (const w of state.walls){ ctx.fillRect(w.x,w.y,w.w,w.h); }
      }
      // Extractions removed
      // Pickups
      if (state.pickups){
        for (const pk of state.pickups){
          ctx.save();
          ctx.shadowColor = 'rgba(255,255,255,.18)'; ctx.shadowBlur = 8;
          if (pk.type==='health'){
            ctx.strokeStyle = '#66bb6a'; ctx.lineWidth = 2; ctx.strokeRect(pk.x-8, pk.y-8, 16, 16);
            ctx.beginPath(); ctx.moveTo(pk.x-6, pk.y); ctx.lineTo(pk.x+6, pk.y); ctx.moveTo(pk.x, pk.y-6); ctx.lineTo(pk.x, pk.y+6); ctx.stroke();
          } else if (pk.type==='speed') {
            ctx.strokeStyle = '#64b5f6'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(pk.x-5, pk.y-8); ctx.lineTo(pk.x+2, pk.y-2); ctx.lineTo(pk.x-2, pk.y-2); ctx.lineTo(pk.x+5, pk.y+8); ctx.stroke();
          } else if (pk.type==='ammo') {
            ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2; ctx.strokeRect(pk.x-7, pk.y-5, 14, 10);
            ctx.beginPath(); ctx.moveTo(pk.x-4, pk.y+1); ctx.lineTo(pk.x-4, pk.y-1); ctx.moveTo(pk.x, pk.y+1); ctx.lineTo(pk.x, pk.y-1); ctx.moveTo(pk.x+4, pk.y+1); ctx.lineTo(pk.x+4, pk.y-1); ctx.stroke();
          } else if (pk.type==='weapon') {
            ctx.strokeStyle = '#ffa726'; ctx.beginPath(); ctx.moveTo(pk.x-6,pk.y); ctx.lineTo(pk.x,pk.y-8); ctx.lineTo(pk.x+2,pk.y-2); ctx.lineTo(pk.x+8,pk.y-2); ctx.lineTo(pk.x,pk.y+8); ctx.lineTo(pk.x+2,pk.y+2); ctx.lineTo(pk.x-6,pk.y); ctx.stroke();
          } else if (pk.type==='shield') {
            ctx.strokeStyle = '#26c6da'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(pk.x, pk.y, 9, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(pk.x, pk.y-6); ctx.lineTo(pk.x, pk.y+6); ctx.stroke();
          } else if (pk.type==='magnet') {
            ctx.strokeStyle = '#ab47bc'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pk.x-3, pk.y, 6, -Math.PI/2, Math.PI/2);
            ctx.arc(pk.x+3, pk.y, 6, Math.PI/2, -Math.PI/2);
            ctx.stroke();
          } else if (pk.type==='freeze') {
            ctx.strokeStyle = '#90caf9'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pk.x, pk.y-7); ctx.lineTo(pk.x, pk.y+7);
            ctx.moveTo(pk.x-7, pk.y); ctx.lineTo(pk.x+7, pk.y);
            ctx.moveTo(pk.x-5, pk.y-5); ctx.lineTo(pk.x+5, pk.y+5);
            ctx.moveTo(pk.x-5, pk.y+5); ctx.lineTo(pk.x+5, pk.y-5);
            ctx.stroke();
          } else if (pk.type==='blast') {
            ctx.strokeStyle = '#ff7043'; ctx.lineWidth = 2;
            for (let i=0;i<8;i++){ const a=i*Math.PI/4; ctx.beginPath(); ctx.moveTo(pk.x+Math.cos(a)*3, pk.y+Math.sin(a)*3); ctx.lineTo(pk.x+Math.cos(a)*10, pk.y+Math.sin(a)*10); ctx.stroke(); }
            ctx.beginPath(); ctx.arc(pk.x, pk.y, 3, 0, Math.PI*2); ctx.stroke();
          } else if (pk.type==='treasure') {
            ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2;
            ctx.strokeRect(pk.x-8, pk.y-6, 16, 12);
            ctx.beginPath(); ctx.moveTo(pk.x-8, pk.y-2); ctx.lineTo(pk.x+8, pk.y-2); ctx.stroke();
            ctx.beginPath(); ctx.arc(pk.x, pk.y+1, 2, 0, Math.PI*2); ctx.stroke();
          }
          // label under pickup
          ctx.font = '10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.save(); ctx.globalAlpha = 0.18; ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(pk.x, pk.y, 3, 0, Math.PI*2); ctx.fill(); ctx.restore();
          ctx.fillStyle = '#cfd8dc'; ctx.globalAlpha = 0.95;
          const labelMap = { health:'HEALTH', speed:'SPEED', ammo:'AMMO', weapon:'WEAPON', shield:'SHIELD', magnet:'MAGNET', freeze:'FREEZE', blast:'BLAST', treasure:'TREASURE', key:'KEY' };
          const lbl = labelMap[pk.type] || String(pk.type).toUpperCase();
          if (lbl) ctx.fillText(lbl, pk.x, pk.y + 14);
          ctx.restore();
        }
        ctx.lineWidth = 1;
      }
      // Bullets
      if (state.bullets && state.bullets.length) {
        const playerLookup = new Map(state.players.map(p => [p.id, p]));
        for (const b of state.bullets) {
          renderBullet(ctx, b, frameNow, playerLookup);
        }
      }
      // Spitter globs
      if (state.globs){
        ctx.fillStyle = '#ce93d8';
        for (const g of state.globs){
          ctx.save(); ctx.shadowColor='rgba(206,147,216,.6)'; ctx.shadowBlur=8; ctx.beginPath(); ctx.arc(g.x,g.y,4,0,Math.PI*2); ctx.fill(); ctx.restore();
        }
      }
      // Bullet impact effects
      const effectNow = frameNow;
      for (let i = effects.length - 1; i >= 0; i--) {
        const e = effects[i];
        e.ttl -= dt;
        if (e.ttl <= 0) { effects.splice(i, 1); continue; }
        const total = e.duration || 220;
        const life = Math.max(0, Math.min(1, e.ttl / total));
        const progress = 1 - life;
        ctx.save();
        if (e.type === 'impact') {
          switch (e.weapon) {
            case 'railgun': {
              const angle = e.angle || 0;
              const len = 170 + 120 * progress;
              ctx.globalCompositeOperation = 'lighter';
              ctx.globalAlpha = 0.45 * life + 0.2;
              ctx.strokeStyle = 'rgba(144, 202, 249, 0.95)';
              ctx.lineWidth = 4 + 4 * life;
              ctx.lineCap = 'round';
              ctx.beginPath();
              ctx.moveTo(e.x - Math.cos(angle) * len, e.y - Math.sin(angle) * len);
              ctx.lineTo(e.x + Math.cos(angle) * 18, e.y + Math.sin(angle) * 18);
              ctx.stroke();
              ctx.globalAlpha = 0.25 * life;
              ctx.fillStyle = 'rgba(187, 222, 251, 0.35)';
              ctx.beginPath();
              ctx.arc(e.x, e.y, 18 + 42 * progress, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = 0.5 * life;
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.75)';
              ctx.lineWidth = 1.4;
              ctx.beginPath();
              ctx.arc(e.x, e.y, 26 + 48 * progress, 0, Math.PI * 2);
              ctx.stroke();
              break;
            }
            case 'shotgun': {
              const sparks = 5;
              for (let s = 0; s < sparks; s++) {
                const ang = seededRand(e.seed || 1, s) * Math.PI * 2;
                const length = 12 + seededRand(e.seed || 1, s + 5) * 28;
                ctx.globalAlpha = (0.75 - s * 0.12) * life;
                ctx.strokeStyle = 'rgba(255, 183, 77, 0.9)';
                ctx.lineWidth = 1.3 - s * 0.15;
                ctx.beginPath();
                ctx.moveTo(e.x, e.y);
                ctx.lineTo(
                  e.x + Math.cos(ang) * length * life,
                  e.y + Math.sin(ang) * length * life
                );
                ctx.stroke();
              }
              ctx.globalAlpha = 0.4 * life;
              ctx.fillStyle = 'rgba(255, 138, 101, 0.6)';
              ctx.beginPath();
              ctx.arc(e.x, e.y, 5 + 10 * progress, 0, Math.PI * 2);
              ctx.fill();
              break;
            }
            case 'smg': {
              const angle = e.angle || 0;
              const len = 28 + 36 * progress;
              ctx.globalCompositeOperation = 'lighter';
              ctx.globalAlpha = 0.55 * life;
              ctx.strokeStyle = 'rgba(3, 169, 244, 0.8)';
              ctx.lineWidth = 1.2 + 1.5 * life;
              ctx.beginPath();
              ctx.moveTo(e.x - Math.cos(angle) * len, e.y - Math.sin(angle) * len);
              ctx.lineTo(e.x + Math.cos(angle) * 8, e.y + Math.sin(angle) * 8);
              ctx.stroke();
              ctx.globalAlpha = 0.35 * life;
              ctx.beginPath();
              ctx.moveTo(e.x - Math.cos(angle + Math.PI / 2) * 6, e.y - Math.sin(angle + Math.PI / 2) * 6);
              ctx.lineTo(e.x + Math.cos(angle + Math.PI / 2) * 6, e.y + Math.sin(angle + Math.PI / 2) * 6);
              ctx.stroke();
              break;
            }
            case 'flamethrower': {
              const angle = e.angle || 0;
              const radius = 9 + 18 * progress;
              ctx.globalAlpha = 0.55 * life;
              ctx.fillStyle = 'rgba(255, 138, 101, 0.65)';
              ctx.beginPath();
              ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = 0.4 * life;
              ctx.fillStyle = 'rgba(255, 202, 40, 0.45)';
              ctx.beginPath();
              ctx.arc(
                e.x - Math.cos(angle) * (6 + 14 * progress),
                e.y - Math.sin(angle) * (6 + 14 * progress),
                radius * 0.6,
                0,
                Math.PI * 2
              );
              ctx.fill();
              break;
            }
            default: {
              const radius = 5 + 12 * progress;
              ctx.globalCompositeOperation = 'lighter';
              ctx.globalAlpha = 0.5 * life + 0.2;
              ctx.fillStyle = 'rgba(255, 214, 126, 0.6)';
              ctx.beginPath();
              ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = 0.35 * life;
              ctx.strokeStyle = 'rgba(255, 241, 148, 0.8)';
              ctx.lineWidth = 1.5 + 2.5 * life;
              ctx.beginPath();
              ctx.arc(e.x, e.y, radius + 4, 0, Math.PI * 2);
              ctx.stroke();
              break;
            }
          }
          if (e.traits && e.traits.length) {
            drawBulletTraits(ctx, e.x, e.y, e.traits, effectNow);
          }
        } else {
          ctx.globalAlpha = life;
          ctx.fillStyle = 'rgba(255, 107, 53, 0.7)';
          ctx.beginPath();
          ctx.arc(e.x, e.y, 4 + 10 * progress, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Damage numbers
      const now = Date.now();
      for (let i = damageNumbers.length - 1; i >= 0; i--) {
        const dn = damageNumbers[i];
        const age = now - dn.startTime;
        const maxAge = 1500; // 1.5 seconds
        
        if (age > maxAge) {
          damageNumbers.splice(i, 1);
          continue;
        }
        
        // Animation: float up and fade out
        const progress = age / maxAge;
        const alpha = Math.max(0, 1 - progress * progress); // Quadratic fade
        dn.offsetY = -progress * 60; // Float up 60 pixels
        
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Different styles for different damage types
        if (dn.isCrit) {
          ctx.font = 'bold 18px monospace';
          ctx.fillStyle = '#ff4444';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.strokeText(dn.damage.toString(), dn.x, dn.y + dn.offsetY);
          ctx.fillText(dn.damage.toString(), dn.x, dn.y + dn.offsetY);
        } else if (dn.isDot) {
          ctx.font = '12px monospace';
          ctx.fillStyle = '#88ff44';
          ctx.fillText(dn.damage.toString(), dn.x, dn.y + dn.offsetY);
        } else {
          ctx.font = '14px monospace';
          ctx.fillStyle = '#ffffff';
          ctx.fillText(dn.damage.toString(), dn.x, dn.y + dn.offsetY);
        }
        
        ctx.restore();
      }
      // Players' dash trails under characters
      const nowT = performance.now();
      if (state.players){
        for (const p of state.players){
          const sp = getSmoothedPos(p.id, p.x, p.y, 0);
          let arr = trails.get(p.id) || [];
          if (p.dashing){ arr.push({ x: sp.x, y: sp.y, t: nowT }); if (arr.length > TRAIL_MAX) arr.shift(); }
          arr = arr.filter(pt => nowT - pt.t <= TRAIL_TTL);
          trails.set(p.id, arr);
          if (arr.length >= 2){
            for (let i=0;i<arr.length;i++){
              const age = nowT - arr[i].t;
              const a = Math.max(0, 1 - (age / TRAIL_TTL));
              const r = 6 + 10 * a;
              ctx.save(); ctx.globalAlpha = 0.22 + 0.4*a; ctx.fillStyle='rgba(158,241,209,1)'; ctx.shadowColor='rgba(158,241,209,.7)'; ctx.shadowBlur=12*a; ctx.beginPath(); ctx.arc(arr[i].x,arr[i].y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
            }
          }
        }
      }

      // Players
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'center';
      for (const p of state.players){
        const sp = getSmoothedPos(p.id, p.x, p.y, dt);
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,.6)'; ctx.shadowBlur = 0;
        if (p.role==='streamer'){
          if (p.alive === false) { ctx.restore(); continue; }
          ctx.strokeStyle = '#4caf50';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(sp.x,sp.y,10,0,Math.PI*2); ctx.stroke();
          ctx.fillStyle = '#4caf50'; ctx.globalAlpha = .95; ctx.fillText(p.name, sp.x, sp.y - 16);
        } else {
          ctx.fillStyle = p.alive? '#ef5350' : 'rgba(239,83,80,.25)';
          ctx.beginPath(); ctx.arc(sp.x,sp.y,12,0,Math.PI*2); ctx.fill();
          // Class outline
          if (p.zClass === 'runner') { ctx.strokeStyle = '#64b5f6'; ctx.lineWidth = 1.5; }
          else if (p.zClass === 'brute') { ctx.strokeStyle = '#ffa726'; ctx.lineWidth = 3; }
          else if (p.zClass === 'spitter') { ctx.strokeStyle = '#ba68c8'; ctx.lineWidth = 2; }
          else if (p.zClass === 'stalker') { ctx.strokeStyle = '#9c27b0'; ctx.lineWidth = 2; }
          else if (p.zClass === 'bomber') { ctx.strokeStyle = '#f44336'; ctx.lineWidth = 2.5; }
          else { ctx.strokeStyle = '#e57373'; ctx.lineWidth = 1; }
          ctx.globalAlpha = .9; ctx.beginPath(); ctx.arc(sp.x,sp.y, (p.zClass==='brute')?14:13, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
          if (p.boosted){ ctx.strokeStyle = '#64b5f6'; ctx.globalAlpha=.8; ctx.beginPath(); ctx.arc(sp.x,sp.y,16,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
          ctx.fillStyle = '#e57373'; ctx.globalAlpha = .95; ctx.fillText(p.name, sp.x, sp.y - 16);
          // Emote above zombie head for 5s
          if (p.emote && (p.emoteUntil||0) > Date.now()){
            ctx.font = '18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
            ctx.globalAlpha = 1;
            ctx.fillText(p.emote, sp.x, sp.y - 32);
            ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          }
        }
        // Bat swing arc visual (short-lived)
        const swingAge = (state.t||Date.now()) - (p.meleeAt||0);
        if (swingAge >= 0 && swingAge < 220) {
          const alpha = 1 - (swingAge / 220);
          const ang = Math.atan2(p.meleeDirY||0, p.meleeDirX||1);
          const span = Math.PI / 1.8; // ~100¬∞
          const r0 = 14, r1 = 34;
          ctx.save();
          ctx.globalAlpha = Math.max(0, alpha*0.9);
          ctx.fillStyle = 'rgba(255,213,79,0.35)';
          ctx.beginPath();
          ctx.moveTo(sp.x + Math.cos(ang - span/2)*r0, sp.y + Math.sin(ang - span/2)*r0);
          ctx.arc(sp.x, sp.y, r1, ang - span/2, ang + span/2);
          ctx.lineTo(sp.x + Math.cos(ang + span/2)*r0, sp.y + Math.sin(ang + span/2)*r0);
          ctx.arc(sp.x, sp.y, r0, ang + span/2, ang - span/2, true);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }

      ctx.restore();

      // Crosshair (screen-space, centered at aim cursor)
      {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
        ctx.setTransform(dpr,0,0,dpr,0,0);
        const cx = input.aimX || 0; const cy = input.aimY || 0;
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#cfd8dc';
        // Outer ring
        ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.stroke();
        // Gap cross
        const arm = 14, gap = 6, len = 9;
        // left
        ctx.beginPath(); ctx.moveTo(cx - arm, cy); ctx.lineTo(cx - gap, cy); ctx.stroke();
        // right
        ctx.beginPath(); ctx.moveTo(cx + gap, cy); ctx.lineTo(cx + arm, cy); ctx.stroke();
        // top
        ctx.beginPath(); ctx.moveTo(cx, cy - arm); ctx.lineTo(cx, cy - gap); ctx.stroke();
        // bottom
        ctx.beginPath(); ctx.moveTo(cx, cy + gap); ctx.lineTo(cx, cy + arm); ctx.stroke();
        // Subtle center dot
        ctx.globalAlpha = 0.7; ctx.fillStyle = '#cfd8dc'; ctx.beginPath(); ctx.arc(cx, cy, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // Extractions removed

      // Mini-map (bottom-right)
      drawMiniMap();

      // Screen border on top
      ctx.save(); ctx.lineWidth = 2; ctx.strokeStyle = '#808080'; ctx.strokeRect(1,1,rect.width-2,rect.height-2); ctx.restore();
      // Class legend (bottom-right above minimap)
      drawClassLegend();
    }

    function updatePlayerList(players){
      playersEl.innerHTML = players.map(p=>`<span class="pill ${p.role}">${p.role==='streamer'?'üü¢':'üßü'} ${p.name}${p.role==='streamer'?' ¬∑ '+p.score:''}</span>`).join(' ');
    }

    function updateTimer(seconds) {
      const min = Math.floor(seconds / 60);
      const sec = seconds % 60;
      timerEl.textContent = `Time: ${min}:${sec.toString().padStart(2, '0')}`;
    }

    // Animation loop + nerd stats
    let last = performance.now();
    const fpsSamples = [];
    const fpsWindow = 120; // ~2s at 60fps
    let lastNerdUpdate = 0;
    function loop(){
      const now=performance.now(); const dt=now-last; last=now; draw(dt);
      const fps = dt>0 ? 1000/dt : 0; fpsSamples.push(fps); if (fpsSamples.length>fpsWindow) fpsSamples.shift();
      if (now - lastStateRateAt >= 1000){ statesPerSec = stateMsgCount; stateMsgCount = 0; lastStateRateAt = now; }
      if (nerdOn && now - lastNerdUpdate > 250){
        const avgFps = fpsSamples.length ? (fpsSamples.reduce((a,b)=>a+b,0)/fpsSamples.length) : 0;
        const minFps = fpsSamples.length ? Math.min(...fpsSamples) : 0;
        const maxFps = fpsSamples.length ? Math.max(...fpsSamples) : 0;
        const lat = latency ? latency.getLatencyStats() : { avg:0, min:0, max:0, jitter:0 };
        const players = state.players?.length||0;
        const zombies = state.players?.filter(p=>p.role==='zombie').length||0;
        const bullets = state.bullets?.length||0;
        const pickups = state.pickups?.length||0;
        const walls = state.walls?.length||0;
        const wsBuf = ws && ws.bufferedAmount || 0;
        nerdPanel.innerHTML = `
          <div><strong>Nerd Stats</strong></div>
          <div>FPS: ${avgFps.toFixed(1)} (min ${minFps.toFixed(0)} max ${maxFps.toFixed(0)})</div>
          <div>Latency: ${lat.avg.toFixed(1)} ms (min ${lat.min.toFixed(0)} max ${lat.max.toFixed(0)}) jitter ${lat.jitter.toFixed(1)} ms</div>
          <div>States/s: ${statesPerSec.toFixed(0)}</div>
          <div>Entities: players ${players} (z ${zombies}) bullets ${bullets} pickups ${pickups} walls ${walls}</div>
          <div>WS buf: ${wsBuf}</div>
        `;
        lastNerdUpdate = now;
      }
      requestAnimationFrame(loop);
    }
    loop();

    // Fullscreen
    document.getElementById('fullscreen').onclick = async () => {
      if (!document.fullscreenElement) { await document.documentElement.requestFullscreen().catch(()=>{}); }
      else { await document.exitFullscreen().catch(()=>{}); }
    };

    function drawMiniMap(){
      const rect = c.getBoundingClientRect();
      const mmSize = 160; const pad = 12; const cx = rect.width - pad - mmSize/2; const cy = rect.height - pad - mmSize/2;
      const R = (mmSize/2) - 4;
      const W = (state.arena && state.arena.w) || 960; const H = (state.arena && state.arena.h) || 540;
      // Zoom in and center around local player for context
      const meMM = state.players && state.players.find(p=>p.id===playerId);
      const centerX = meMM ? meMM.x : W/2;
      const centerY = meMM ? meMM.y : H/2;
      const MM_ZOOM = 1.6;
      const scale = (2*R*MM_ZOOM) / Math.max(W, H);
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = 'rgba(18,20,24,.86)';
      ctx.beginPath(); ctx.arc(cx, cy, mmSize/2, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth = 2; ctx.stroke();
      ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.clip();
      if (state.walls) {
        ctx.strokeStyle = 'rgba(255,255,255,.25)'; ctx.lineWidth = 1;
        for (const w of state.walls){
          const x = cx + (w.x - centerX) * scale; const y = cy + (w.y - centerY) * scale;
          const ww = w.w * scale; const hh = w.h * scale;
          ctx.strokeRect(x, y, ww, hh);
        }
      }
      // Extractions removed
      if (state.players){
        for (const p of state.players){
          const px = cx + (p.x - centerX) * scale; const py = cy + (p.y - centerY) * scale;
          const r = p.role==='streamer' ? 3 : 2;
          ctx.beginPath();
          ctx.fillStyle = p.role==='streamer' ? '#4caf50' : (p.alive ? '#ef5350' : 'rgba(239,83,80,.4)');
          ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
          if (p.id === playerId) { ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1; ctx.stroke(); }
        }
      }
      ctx.restore(); ctx.restore();
    }

    function drawTiles(viewX, viewY, viewW, viewH){
      const m = gameMap; if (!m) return; const sz = m.size;
      const theme = m.theme||'dungeon';
      const pal = theme==='dungeon' ? {
        floor:'#0e1115', wall:'#2a2f36', pit:'#0b0d11', water:'#0d1b2a', edge:'#9aa4b2', propCrate:'#6d4c41', propPillar:'#b0bec5', propBone:'#8d6e63'
      } : theme==='cave' ? {
        floor:'#0d1113', wall:'#263238', pit:'#0a0e10', water:'#0b1f2d', edge:'#90a4ae', propCrate:'#546e7a', propPillar:'#90caf9', propBone:'#80cbc4'
      } : {
        floor:'#111416', wall:'#3c4148', pit:'#0b0c0d', water:'#14212e', edge:'#b0bec5', propCrate:'#90a4ae', propPillar:'#cfd8dc', propBone:'#b0bec5'
      };
      const sx = Math.max(0, Math.floor(viewX/sz)-1), sy = Math.max(0, Math.floor(viewY/sz)-1);
      const ex = Math.min(m.w-1, Math.ceil((viewX+viewW)/sz)+1), ey = Math.min(m.h-1, Math.ceil((viewY+viewH)/sz)+1);
      // Floor
      for (let y=sy;y<=ey;y++){
        for (let x=sx;x<=ex;x++){
          const id = m.tiles[y*m.w + x];
          if (id===0){ ctx.fillStyle = pal.floor; ctx.fillRect(x*sz, y*sz, sz, sz); ctx.globalAlpha=.06; ctx.fillStyle='#ffffff'; ctx.fillRect(x*sz+4,y*sz+4,3,3); ctx.globalAlpha=1; }
        }
      }
      // Pits/Water
      for (let y=sy;y<=ey;y++) for (let x=sx;x<=ex;x++){ const id=m.tiles[y*m.w+x]; if (id===2){ ctx.fillStyle='#101318'; ctx.fillRect(x*sz,y*sz,sz,sz);} if (id===3){ ctx.fillStyle='#0d1b2a'; ctx.fillRect(x*sz,y*sz,sz,sz);} }
      // Walls outline
      const isWall=(ix,iy)=> ix>=0&&iy>=0&&ix<m.w&&iy<m.h && m.tiles[iy*m.w+ix]===1;
      ctx.fillStyle = pal.wall;
      for (let y=sy;y<=ey;y++){
        for (let x=sx;x<=ex;x++){
          if (!isWall(x,y)) continue; const px=x*sz, py=y*sz; ctx.fillRect(px,py,sz,sz);
          ctx.strokeStyle=pal.edge; ctx.lineWidth=1; ctx.globalAlpha=.15;
          if (!isWall(x,y-1)){ ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px+sz,py); ctx.stroke(); }
          if (!isWall(x+1,y)){ ctx.beginPath(); ctx.moveTo(px+sz,py); ctx.lineTo(px+sz,py+sz); ctx.stroke(); }
          if (!isWall(x,y+1)){ ctx.beginPath(); ctx.moveTo(px,py+sz); ctx.lineTo(px+sz,py+sz); ctx.stroke(); }
          if (!isWall(x-1,y)){ ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px,py+sz); ctx.stroke(); }
          ctx.globalAlpha=1;
        }
      }
      // Props
      for (const p of (m.props||[])){
        const px=p.x*sz, py=p.y*sz; ctx.save(); ctx.globalAlpha=.9; ctx.fillStyle=p.type==='crate'?pal.propCrate:p.type==='pillar'?pal.propPillar:pal.propBone; ctx.fillRect(px+4,py+4,sz-8,sz-8); ctx.restore();
      }
      // Lights
      for (const l of (m.lights||[])){
        const cx=l.x*sz+sz/2, cy=l.y*sz+sz/2, rr=l.r*sz; const g=ctx.createRadialGradient(cx,cy,2,cx,cy,rr); g.addColorStop(0,`rgba(255,255,200,${0.35*l.a})`); g.addColorStop(1,'rgba(255,255,200,0)'); ctx.save(); ctx.fillStyle=g; ctx.fillRect(cx-rr,cy-rr,rr*2,rr*2); ctx.restore();
      }
    }

    // Simple lighting overlay for zombies ‚Äî lighter than streamer
    function drawLighting(viewX, viewY, viewW, viewH, me){
      ctx.save(); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(viewX,viewY,viewW,viewH); ctx.globalCompositeOperation='destination-out';
      const add=(x,y,r,a=1)=>{ const g=ctx.createRadialGradient(x,y,2,x,y,r); g.addColorStop(0,`rgba(255,255,220,${0.6*a})`); g.addColorStop(1,'rgba(255,255,220,0)'); ctx.fillStyle=g; ctx.fillRect(x-r,y-r,r*2,r*2); };
      if (gameMap){ const sz=gameMap.size; for(const l of (gameMap.lights||[])) add(l.x*sz+sz/2,l.y*sz+sz/2,(l.r||6)*sz,l.a||0.2); }
      if (me) add(me.x, me.y, 110, 1);
      for (const b of (state.bullets||[])) add(b.x,b.y,22,.6);
      ctx.restore();
    }

    function drawClassLegend(){
      const rect = c.getBoundingClientRect();
      const pad = 12;
      const boxW = 160, boxH = 114;
      const x = rect.width - boxW - pad;
      const y = rect.height - 160 - boxH - pad;
      ctx.save();
      ctx.globalAlpha = .95; ctx.fillStyle = 'rgba(18,20,24,.86)'; ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.roundRect ? ctx.roundRect(x,y,boxW,boxH,10) : (ctx.moveTo(x+10,y),ctx.lineTo(x+boxW-10,y),ctx.quadraticCurveTo(x+boxW,y,x+boxW,y+10),ctx.lineTo(x+boxW,y+boxH-10),ctx.quadraticCurveTo(x+boxW,y+boxH,x+boxW-10,y+boxH),ctx.lineTo(x+10,y+boxH),ctx.quadraticCurveTo(x,y+boxH,x,y+boxH-10),ctx.lineTo(x,y+10),ctx.quadraticCurveTo(x,y,x+10,y));
      ctx.fill(); ctx.stroke();
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif'; ctx.fillStyle = '#cfd8dc';
      const rows = [
        { label: 'Runner', color: '#64b5f6', lw: 1.5 },
        { label: 'Brute', color: '#ffa726', lw: 3 },
        { label: 'Spitter', color: '#ba68c8', lw: 2 },
        { label: 'Stalker', color: '#9c27b0', lw: 2 },
        { label: 'Bomber', color: '#f44336', lw: 2.5 },
      ];
      let yy = y + 18;
      for (const r of rows){
        ctx.save(); ctx.strokeStyle = r.color; ctx.lineWidth = r.lw; ctx.beginPath(); ctx.arc(x+14, yy-4, 6, 0, Math.PI*2); ctx.stroke(); ctx.restore();
        ctx.fillText(r.label, x+28, yy-2);
        yy += 22;
      }
      ctx.restore();
    }
  </script>
</body>
</html>
