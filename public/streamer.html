<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Arena Shooter Streamer</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body class="game">
    <div class="topbar">
      <div class="brand">Arena Shooter</div>
      <div class="middle-controls">
        <span class="badge" id="status" data-state="disconnected"
          >disconnected</span
        >
      </div>
      <div class="right-controls">
        <button id="fullscreen">Fullscreen</button>
        <button id="nerdToggle">Nerd Stats</button>
      </div>
    </div>

    <div class="app">
      <div class="main">
        <div class="stage">
          <div class="hud-layer">
            <div class="hud-stack hud-top-right">
              <div id="upgradeOverlay" class="hud-panel hidden">
                <div class="hud-panel-title mono">Level Up! Choose an upgrade</div>
                <div class="choices">
                  <button class="choice" data-idx="0"></button>
                  <button class="choice" data-idx="1"></button>
                  <button class="choice" data-idx="2"></button>
                </div>
                <div class="tip mono">Press 1 / 2 / 3</div>
              </div>
              <div id="buffPanel" class="hud-panel hidden">
                <div class="hud-panel-title">Current Upgrades</div>
                <div class="hud-buff-list" id="buffList"></div>
              </div>
              <div class="hud-pill hud-pill--right">
                <span>Score: <strong id="hudScore">0</strong></span>
                <span>Banked: <strong id="hudBanked">0</strong></span>
              </div>
            </div>
            <div class="hud-stack hud-top-left">
              <div class="hud-pill">
                <span>HP: <strong id="hudHp">0/0</strong></span>
                <span>Level: <strong id="hudLevel">0</strong></span>
                <span>XP: <strong id="hudXp">0/0</strong></span>
              </div>
            </div>
            <div class="hud-stack hud-bottom-left">
              <div class="hud-pill">
                <span>Weapon: <strong id="hudWeapon">--</strong></span>
                <span>Ammo: <strong id="hudAmmo">0</strong></span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <aside class="sidebar">
        <div class="card">
          <div class="card-title">Session</div>
          <div class="row">
            <button id="newRoom">Create Room</button>
            <button id="toggleChat" disabled>Disable Chat</button>
          </div>
          <div class="row">
            <input
              id="roomLink"
              class="mono"
              placeholder="Join link"
              readonly
            />
            <button id="copy" disabled>Copy Link</button>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Weapons</div>
          <div class="row">
            <button class="weapon" id="btnPistol" data-weapon="pistol">
              Pistol (1)
            </button>
            <button class="weapon" id="btnSmg" data-weapon="smg">
              SMG (2)
            </button>
            <button class="weapon" id="btnShotgun" data-weapon="shotgun">
              Shotgun (3)
            </button>
          </div>
          <div class="row">
            <button id="buyShotgun" title="Costs 300 banked" disabled>
              Unlock Shotgun (4) • 300
            </button>
            <button id="buySmg" title="Costs 300 banked" disabled>
              Unlock SMG (5) • 300
            </button>
          </div>
          <div class="tip">
            Right‑click or Q to swing bat. Pistol is free. Unlock SMG/Shotgun
            with banked (300 each). Use 1/2/3 to equip, 5/4 to buy.
          </div>
        </div>

        <div class="card">
          <div class="card-title">Stats</div>
          <div class="row">
            <span class="badge">Score: <span id="score">0</span></span>
            <span class="badge">Banked: <span id="banked">0</span></span>
            <span class="badge">HP: <span id="hp">100</span></span>
            <span class="badge">Weapon: <span id="weapon">pistol</span></span>
            <span class="badge">Ammo: <span id="ammo">0</span></span>
            <span class="badge" id="timer">Time: --</span>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Players</div>
          <div class="pill-list" id="players"></div>
        </div>

        <div class="card">
          <div class="card-title">Chat</div>
          <div id="chatMessages" class="chat-messages"></div>
          <div class="row"><input id="chatInput" placeholder="Chat..." /></div>
        </div>
      </aside>
    </div>
    <div class="hit-flash" id="flash"></div>

    <script type="module">
      import {
        connect,
        nameStorage,
        minimalCanvas,
        inputController,
        suppressPageHotkeys,
        toast,
        createLatencyMonitor,
      } from "/common.js";

      const urlParams = new URLSearchParams(location.search);
      const presetRoom = urlParams.get('room') || '';
      const create = async () => {
        if (presetRoom) return presetRoom;
        const res = await fetch("/create", { method: "POST" });
        const { roomId } = await res.json();
        return roomId;
      };

      const { c, ctx } = minimalCanvas(1440, 810);
      document.querySelector(".stage").appendChild(c);
      suppressPageHotkeys();
      const input = inputController();

      let ws,
        roomId,
        playerId,
        arena = { w: 960, h: 540 };
      let state = { players: [], bullets: [], arena, remainingTime: 0, aiZombies: [] };
      let gameMap = null; // {w,h,size,theme,tiles:Uint8Array, props, lights}
      let lastHp = 100;
      let lastStateTime = performance.now();
      let lastScore = 0;
      const effects = []; // bullet impacts etc {x,y,ttl}
      // Screen shake accumulator (reduced each frame)
      let shake = 0;
      let muzzleFlashes = [];
      let prevShoot = false;
      let lastMuzzleAt = 0;
      let prevBulletPos = new Map();
      // Dash trails: per-player history of recent positions while dashing
      const trails = new Map(); // id -> Array<{x:number,y:number,t:number}>
      const TRAIL_TTL = 260; // ms
      const TRAIL_MAX = 22;
      // Local melee feedback (client-side prediction so streamer sees instantly)
      let localMeleeAt = 0;
      let localMeleeDirX = 1;
      let localMeleeDirY = 0;
      let prevMelee = false;

      const link = document.getElementById("roomLink");
      const status = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const bankedEl = document.getElementById("banked");
      const hpEl = document.getElementById("hp");
      const ammoEl = document.getElementById("ammo");
      const weaponEl = document.getElementById("weapon");
      const playersEl = document.getElementById("players");
      const buyShotgunBtn = document.getElementById("buyShotgun");
      const buySmgBtn = document.getElementById("buySmg");
      const btnPistol = document.getElementById("btnPistol");
      const btnSmg = document.getElementById("btnSmg");
      const btnShotgun = document.getElementById("btnShotgun");
      const flashEl = document.getElementById("flash");
      const newBtn = document.getElementById("newRoom");
      const copyBtn = document.getElementById("copy");
      const timerEl = document.getElementById("timer");
      const chatMessagesEl = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const toggleChatBtn = document.getElementById("toggleChat");
      const nerdToggleBtn = document.getElementById("nerdToggle");
      const buffPanel = document.getElementById("buffPanel");
      const buffListEl = document.getElementById("buffList");
      const hudScoreEl = document.getElementById("hudScore");
      const hudBankedEl = document.getElementById("hudBanked");
      const hudWeaponEl = document.getElementById("hudWeapon");
      const hudAmmoEl = document.getElementById("hudAmmo");
      const hudHpEl = document.getElementById("hudHp");
      const hudLevelEl = document.getElementById("hudLevel");
      const hudXpEl = document.getElementById("hudXp");
      // Nerd panel overlay element
      const nerdPanel = document.createElement("div");
      nerdPanel.id = "nerdPanel";
      nerdPanel.className = "nerd-panel hidden mono";
      document.body.appendChild(nerdPanel);

      // Upgrade overlay elements
      const overlay = document.getElementById('upgradeOverlay');
      const choiceEls = Array.from(overlay.querySelectorAll('.choice'));
      let currentChoices = [];
      function showUpgrades(choices){
        currentChoices = choices || [];
        choiceEls.forEach((el, i) => {
          const c = currentChoices[i];
          if (!c) { el.textContent = ''; el.disabled = true; return; }
          el.disabled = false;
          el.textContent = `${i+1}) ${c.name} - ${c.desc}`;
        });
        overlay.classList.remove('hidden');
      }
      function pickUpgrade(index){
        const c = currentChoices[index];
        if (!c || !ws) return;
        try { ws.send(JSON.stringify({ type:'choose_upgrade', id: c.id })); } catch {}
        overlay.classList.add('hidden');
        currentChoices = [];
      }
      choiceEls.forEach((el,i)=> el.addEventListener('click', ()=> pickUpgrade(i)) );
      window.addEventListener('keydown', (e)=>{
        if (overlay.classList.contains('hidden')) return;
        if (e.key === '1') pickUpgrade(0);
        if (e.key === '2') pickUpgrade(1);
        if (e.key === '3') pickUpgrade(2);
      });

      function xpThreshold(level) {
        return 3 + Math.floor(level * 1.8);
      }

      function renderBuffs(mods) {
        if (!buffListEl) return;
        buffListEl.innerHTML = "";
        const data = Array.isArray(mods)
          ? mods.slice()
          : Object.entries(mods || {}).map(([id, stacks]) => ({ id, stacks }));
        if (!data.length) {
          if (buffPanel) buffPanel.classList.add('hidden');
          return;
        }
        data.sort((a, b) => (a.name || a.id || '').localeCompare(b.name || b.id || ''));
        if (buffPanel) buffPanel.classList.remove('hidden');
        for (const mod of data) {
          const row = document.createElement('div');
          row.className = 'hud-buff';
          row.dataset.rarity = (mod.rarity || 'common');
          if (mod.desc) row.title = mod.desc;
          const nameEl = document.createElement('span');
          nameEl.className = 'label';
          nameEl.textContent = mod.name || mod.id;
          const stackEl = document.createElement('span');
          stackEl.className = 'stacks';
          stackEl.textContent = `x${mod.stacks ?? 1}`;
          row.append(nameEl, stackEl);
          buffListEl.appendChild(row);
        }
      }
      renderBuffs([]);

      let nerdOn = localStorage.getItem("nerdStats") === "1";
      function setNerd(on) {
        nerdOn = !!on;
        localStorage.setItem("nerdStats", nerdOn ? "1" : "0");
        nerdPanel.classList.toggle("hidden", !nerdOn);
        nerdToggleBtn.classList.toggle("active", nerdOn);
      }
      setNerd(nerdOn);
      nerdToggleBtn.onclick = () => setNerd(!nerdOn);
      copyBtn.disabled = true;
      // Camera: smooth, mouse-biased, no manual control
      let camX = 0,
        camY = 0; // top-left of viewport in world space
      const zoom = 2.4; // hotline-miami style: a bit more zoomed-in
      const mouseBias = 110; // world px to bias toward aim
      const camLerpBase = 0.05; // smoothing factor per frame higher = faster

      let inputIv = null;
      let sendNeutralHandler = null;
      let visHandler = null;

      let pingIv = null;
      let latency = null;
      let stateMsgCount = 0;
      let statesPerSec = 0;
      let lastStateRateAt = performance.now();
      async function boot() {
        if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;
        roomId = await create();
        const url = `${location.origin}/join.html?room=${roomId}`;
        link.value = url;
        copyBtn.disabled = false;
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(url);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        };

        ws = connect(roomId);
        ws.addEventListener("open", () => {
          status.textContent = "connected";
          status.dataset.state = "connected";
          document.body.classList.add("connected");
          const name = nameStorage().get() || "Marine";
          ws.send(
            JSON.stringify({ type: "join_room", role: "streamer", name })
          );
          newBtn.textContent = "End Session";
          toggleChatBtn.disabled = false;
        });
        latency = createLatencyMonitor(ws);
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        pingIv = setInterval(() => {
          try {
            latency.sendPing();
          } catch {}
        }, 1000);

        ws.addEventListener("message", (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === "map") {
            try {
              const m = msg.map;
              const bin = atob(m.tilesBase64);
              const u8 = new Uint8Array(bin.length);
              for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
              gameMap = {
                w: m.w,
                h: m.h,
                size: m.size,
                theme: m.theme,
                tiles: u8,
                props: m.props || [],
                lights: m.lights || [],
              };
            } catch {}
          }
          if (msg.type === "joined") {
            playerId = msg.playerId;
            arena = msg.arena;
          }
          if (msg.type === "state") {
            stateMsgCount++;
            // detect removed bullets for small impact effect
            const curMap = new Map(
              msg.bullets.map((b) => [b.id, { x: b.x, y: b.y }])
            );
            for (const [id, pos] of prevBulletPos) {
              if (!curMap.has(id)) {
                effects.push({ x: pos.x, y: pos.y, ttl: 220 });
                shake += 2;
              }
            }
            prevBulletPos = curMap;

            state = msg;
            const me = msg.players.find((p) => p.id === playerId);
            if (me) {
              const hpVal = me.hp ?? 0;
              const maxHp = me.maxHp ?? hpVal;
              const level = me.level ?? 0;
              const xpVal = me.xp ?? 0;
              const xpNeed = me.xpForNext ?? xpThreshold(level);
              scoreEl.textContent = me.score;
              bankedEl.textContent = me.banked ?? 0;
              hpEl.textContent = `${hpVal}/${maxHp}`;
              const w = me.weapon || "pistol";
              weaponEl.textContent = w;
              let ammo = 0;
              if (w === "pistol") ammo = me.pistolAmmo ?? 0;
              else if (w === "smg") ammo = me.smgAmmo ?? 0;
              else if (w === "shotgun") ammo = me.shotgunAmmo ?? 0;
              else ammo = 0;
              ammoEl.textContent = ammo;
              if (hudScoreEl) hudScoreEl.textContent = String(me.score ?? 0);
              if (hudBankedEl) hudBankedEl.textContent = String(me.banked ?? 0);
              if (hudWeaponEl) hudWeaponEl.textContent = w;
              if (hudAmmoEl) hudAmmoEl.textContent = String(ammo);
              if (hudHpEl) hudHpEl.textContent = `${hpVal}/${maxHp}`;
              if (hudLevelEl) hudLevelEl.textContent = String(level);
              if (hudXpEl) hudXpEl.textContent = `${xpVal}/${xpNeed}`;
              renderBuffs(me.mods || []);
              // Ownership inference
              const hasSmg = (me.smgAmmo ?? 0) > 0 || w === "smg";
              const hasShotgun = (me.shotgunAmmo ?? 0) > 0 || w === "shotgun";
              // Button states
              if (btnPistol) {
                btnPistol.classList.toggle("equipped", w === "pistol");
                btnPistol.classList.add("owned");
              }
              if (btnSmg) {
                btnSmg.classList.toggle("equipped", w === "smg");
                btnSmg.classList.toggle("owned", hasSmg);
                btnSmg.classList.toggle("locked", !hasSmg);
              }
              if (btnShotgun) {
                btnShotgun.classList.toggle("equipped", w === "shotgun");
                btnShotgun.classList.toggle("owned", hasShotgun);
                btnShotgun.classList.toggle("locked", !hasShotgun);
              }
              if (buyShotgunBtn) {
                const canBuy = (me.banked || 0) >= 300 && !hasShotgun;
                buyShotgunBtn.disabled = !canBuy;
                buyShotgunBtn.textContent = "Unlock Shotgun (4) ??? 300";
                buyShotgunBtn.title = canBuy
                  ? "Press 4 to purchase"
                  : "Need 300 banked or already unlocked";
              }
              if (buySmgBtn) {
                const canBuySmg = (me.banked || 0) >= 300 && !hasSmg;
                buySmgBtn.disabled = !canBuySmg;
                buySmgBtn.textContent = "Unlock SMG (5) ??? 300";
                buySmgBtn.title = canBuySmg
                  ? "Press 5 to purchase"
                  : "Need 300 banked or already unlocked";
              }
            } else {
              renderBuffs([]);
              if (hudScoreEl) hudScoreEl.textContent = '0';
              if (hudBankedEl) hudBankedEl.textContent = '0';
              if (hudWeaponEl) hudWeaponEl.textContent = '--';
              if (hudAmmoEl) hudAmmoEl.textContent = '0';
              if (hudHpEl) hudHpEl.textContent = '0/0';
              if (hudLevelEl) hudLevelEl.textContent = '0';
              if (hudXpEl) hudXpEl.textContent = '0/0';
            }
            const ping = Math.max(0, Date.now() - (msg.t || Date.now()));
            status.textContent = `connected • ${ping} ms • players: ${msg.players.length}`;
            status.dataset.state = "connected";
            state.remainingTime = msg.remainingTime;
            updateTimer(state.remainingTime);
            updatePlayerList(msg.players);
            // Update chat toggle button label from state
            if (typeof msg.chatEnabled === "boolean") {
              toggleChatBtn.textContent = msg.chatEnabled
                ? "Disable Chat"
                : "Enable Chat";
              // Hide chat card and disable input when chat is disabled
              chatInput.disabled = !msg.chatEnabled;
              chatInput.placeholder = msg.chatEnabled
                ? "Chat..."
                : "Chat disabled by streamer";
              const chatCard = chatMessagesEl.closest(".card");
              if (chatCard)
                chatCard.classList.toggle("hidden", !msg.chatEnabled);
            }
            if (me && (me.hp ?? 0) < lastHp) {
              flash();
            }
            lastScore = me ? me.score : lastScore;
            lastHp = me ? me.hp ?? lastHp : lastHp;
            lastStateTime = performance.now();
          }
          if (msg.type === "pong") {
            if (latency) latency.handlePong(Number(msg.timestamp) || 0);
          }
          if (msg.type === "chat") {
            appendChat(msg.from, msg.message);
          }
          if (msg.type === "notice") {
            try {
              toast(msg.message);
            } catch {}
            appendChat("System", msg.message);
          }
          if (msg.type === 'upgrade_offer') {
            showUpgrades(msg.choices || []);
          }
        });
        inputIv = setInterval(() => {
          if (ws && ws.readyState === 1) {
            // Convert screen aim to world coordinates via camera + zoom
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: input.up,
                down: input.down,
                left: input.left,
                right: input.right,
                shoot: input.shoot,
                melee: input.melee,
                dash: input.dash,
                aimX: aimWX,
                aimY: aimWY,
              })
            );

            // Spawn a local muzzle flash near the player's muzzle for immediate feedback
            const meNow = state.players.find((p) => p.id === playerId);
            if (meNow) {
              const now = performance.now();
              const wantFlash =
                input.shoot && (!prevShoot || now - lastMuzzleAt > 110);
              if (wantFlash) {
                const dx = aimWX - meNow.x;
                const dy = aimWY - meNow.y;
                const d = Math.hypot(dx, dy) || 1;
                const muzzleOffset = 16; // distance from player center to muzzle
                const fx = meNow.x + (dx / d) * muzzleOffset;
                const fy = meNow.y + (dy / d) * muzzleOffset;
                muzzleFlashes.push({ x: fx, y: fy, ttl: 90 });
                lastMuzzleAt = now;
              }
              prevShoot = input.shoot;
            }
          }
        }, 50);

        // If focus is lost, immediately send a neutral input (interval covers it, but faster feedback helps)
        sendNeutralHandler = () => {
          if (ws && ws.readyState === 1) {
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: false,
                down: false,
                left: false,
                right: false,
                shoot: false,
                melee: false,
                dash: false,
                aimX: aimWX,
                aimY: aimWY,
              })
            );
          }
        };
        visHandler = () => {
          if (document.hidden) sendNeutralHandler();
        };
        window.addEventListener("blur", sendNeutralHandler);
        document.addEventListener("visibilitychange", visHandler);

        const onClose = () => {
          leaveRoom(false);
        };
        ws.addEventListener("close", onClose, { once: true });
      }

      function leaveRoom(manual = true) {
        if (inputIv) {
          clearInterval(inputIv);
          inputIv = null;
        }
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        if (sendNeutralHandler) {
          window.removeEventListener("blur", sendNeutralHandler);
          sendNeutralHandler = null;
        }
        if (visHandler) {
          document.removeEventListener("visibilitychange", visHandler);
          visHandler = null;
        }
        if (ws) {
          try {
            if (manual && ws.readyState === 1) ws.close(1000, "leave");
          } catch {}
          ws = null;
        }
        status.textContent = "disconnected";
        status.dataset.state = "disconnected";
        document.body.classList.remove("connected");
        newBtn.textContent = "Create Room";
        copyBtn.disabled = true;
        link.value = "";
        toggleChatBtn.disabled = true;
        toggleChatBtn.textContent = "Disable Chat";
        playerId = null;
        prevBulletPos = new Map();
        effects.length = 0;
        muzzleFlashes.length = 0;
        lastScore = 0;
        lastHp = 100;
        state = { players: [], bullets: [], arena };
        updatePlayerList([]);
      }

      // Smoothing map for positions (reduces 20Hz stutter)
      const smooth = new Map(); // id -> {x,y}
      const SMOOTH_TAU = 90; // ms time constant
      function getSmoothedPos(id, tx, ty, dt) {
        let s = smooth.get(id);
        if (!s) {
          s = { x: tx, y: ty };
          smooth.set(id, s);
          return { x: tx, y: ty };
        }
        const alpha = 1 - Math.exp(-dt / Math.max(1, SMOOTH_TAU));
        s.x += (tx - s.x) * alpha;
        s.y += (ty - s.y) * alpha;
        return { x: s.x, y: s.y };
      }

      function draw(dt = 16) {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const rect = c.getBoundingClientRect();
        // Reset and clear in device pixels
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, c.width, c.height);
        // Base transform to CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // Fill background with dungeon-themed dark color in CSS px
        ctx.fillStyle = "#0a0c0f";
        ctx.fillRect(0, 0, rect.width, rect.height);
        // Update camera target (follow player with slight mouse bias)
        const meRawForCam = state.players.find((p) => p.id === playerId);
        const meHud = meRawForCam || null;
        const meCam = meRawForCam
          ? getSmoothedPos(meRawForCam.id, meRawForCam.x, meRawForCam.y, dt)
          : null;
        if (meCam) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          const dx = aimWX - meCam.x,
            dy = aimWY - meCam.y;
          const d = Math.hypot(dx, dy) || 1;
          const offX = (dx / d) * mouseBias,
            offY = (dy / d) * mouseBias;
          const viewW = rect.width / zoom,
            viewH = rect.height / zoom;
          const targetX = Math.min(
            Math.max(0, meCam.x + offX - viewW / 2),
            Math.max(0, arena.w - viewW)
          );
          const targetY = Math.min(
            Math.max(0, meCam.y + offY - viewH / 2),
            Math.max(0, arena.h - viewH)
          );
          const k = Math.min(1, (dt / 16) * camLerpBase);
          camX = camX + (targetX - camX) * k;
          camY = camY + (targetY - camY) * k;
        }
        // Begin world transform
        ctx.save();
        ctx.scale(zoom, zoom);
        // Screen shake
        const sAmt = Math.max(0, shake);
        shake = Math.max(0, shake * 0.9 - 0.2);
        const sdx = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        const sdy = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        ctx.translate(-camX + sdx, -camY + sdy);
        // Tile layer
        if (gameMap)
          drawTiles(camX, camY, rect.width / zoom, rect.height / zoom);
        // Walls/rooms
        if (state.walls) {
          ctx.fillStyle = "#2a2f36";
          for (const w of state.walls) {
            ctx.fillRect(w.x, w.y, w.w, w.h);
          }
        }
        // Extractions removed
        // Pickups
        if (state.pickups) {
          for (const pk of state.pickups) {
            ctx.save();
            ctx.shadowColor = "rgba(255,255,255,.16)";
            ctx.shadowBlur = 8;
            if (pk.type === "health") {
              ctx.strokeStyle = "#66bb6a";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 8, 16, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x + 6, pk.y);
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "speed") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x - 5, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x - 2, pk.y - 2);
              ctx.lineTo(pk.x + 5, pk.y + 8);
              ctx.stroke();
            } else if (pk.type === "ammo") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 7, pk.y - 5, 14, 10);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y + 1);
              ctx.lineTo(pk.x - 4, pk.y - 1);
              ctx.moveTo(pk.x, pk.y + 1);
              ctx.lineTo(pk.x, pk.y - 1);
              ctx.moveTo(pk.x + 4, pk.y + 1);
              ctx.lineTo(pk.x + 4, pk.y - 1);
              ctx.stroke();
            } else if (pk.type === "weapon") {
              ctx.strokeStyle = "#ffa726";
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x - 6, pk.y);
              ctx.stroke();
            } else if (pk.type === "shield") {
              ctx.strokeStyle = "#26c6da";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 9, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "magnet") {
              ctx.strokeStyle = "#ab47bc";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x - 3, pk.y, 6, -Math.PI / 2, Math.PI / 2);
              ctx.arc(pk.x + 3, pk.y, 6, Math.PI / 2, -Math.PI / 2);
              ctx.stroke();
            } else if (pk.type === "freeze") {
              ctx.strokeStyle = "#90caf9";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x, pk.y + 7);
              ctx.moveTo(pk.x - 7, pk.y);
              ctx.lineTo(pk.x + 7, pk.y);
              ctx.moveTo(pk.x - 5, pk.y - 5);
              ctx.lineTo(pk.x + 5, pk.y + 5);
              ctx.moveTo(pk.x - 5, pk.y + 5);
              ctx.lineTo(pk.x + 5, pk.y - 5);
              ctx.stroke();
            } else if (pk.type === "blast") {
              ctx.strokeStyle = "#ff7043";
              ctx.lineWidth = 2;
              for (let i = 0; i < 8; i++) {
                const a = (i * Math.PI) / 4;
                ctx.beginPath();
                ctx.moveTo(pk.x + Math.cos(a) * 3, pk.y + Math.sin(a) * 3);
                ctx.lineTo(pk.x + Math.cos(a) * 10, pk.y + Math.sin(a) * 10);
                ctx.stroke();
              }
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 3, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "treasure") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x, pk.y + 1, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "coin") {
              ctx.strokeStyle = "#ffc107";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 6, 0, Math.PI * 2);
              ctx.stroke();
              ctx.fillStyle = "#ffc107";
              ctx.globalAlpha = 0.3;
              ctx.fill();
            } else if (pk.type === "gem") {
              ctx.strokeStyle = "#e91e63";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x - 5, pk.y - 2);
              ctx.lineTo(pk.x - 3, pk.y + 7);
              ctx.lineTo(pk.x + 3, pk.y + 7);
              ctx.lineTo(pk.x + 5, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "crystal") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#9c27b0";
              ctx.shadowBlur = 6;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x - 4, pk.y - 2);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.lineTo(pk.x + 4, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "orb") {
              ctx.strokeStyle = "#2196f3";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#2196f3";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 7, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x - 2, pk.y - 2, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "relic") {
              ctx.strokeStyle = "#795548";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#795548";
              ctx.shadowBlur = 6;
              ctx.strokeRect(pk.x - 6, pk.y - 8, 12, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y - 4);
              ctx.moveTo(pk.x - 2, pk.y);
              ctx.lineTo(pk.x + 2, pk.y);
              ctx.stroke();
            } else if (pk.type === "artifact") {
              ctx.strokeStyle = "#607d8b";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#607d8b";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y - 2, 6, 0, Math.PI);
              ctx.stroke();
              ctx.strokeRect(pk.x - 4, pk.y - 2, 8, 8);
            } else if (pk.type === "medallion") {
              ctx.strokeStyle = "#ff9800";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#ff9800";
              ctx.shadowBlur = 10;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 8, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.moveTo(pk.x + 4, pk.y - 4);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.stroke();
            } else if (pk.type === "scroll") {
              ctx.strokeStyle = "#8bc34a";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#8bc34a";
              ctx.shadowBlur = 12;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y - 2);
              ctx.lineTo(pk.x + 6, pk.y - 2);
              ctx.moveTo(pk.x - 6, pk.y + 2);
              ctx.lineTo(pk.x + 6, pk.y + 2);
              ctx.stroke();
            } else if (pk.type === "crown") {
              ctx.strokeStyle = "#ffd700";
              ctx.lineWidth = 4;
              ctx.shadowColor = "#ffd700";
              ctx.shadowBlur = 15;
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y + 4);
              ctx.lineTo(pk.x - 4, pk.y - 6);
              ctx.lineTo(pk.x - 2, pk.y + 2);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x + 4, pk.y - 6);
              ctx.lineTo(pk.x + 8, pk.y + 4);
              ctx.lineTo(pk.x - 8, pk.y + 4);
              ctx.stroke();
            }
            // label under pickup
            ctx.font =
              "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.fillStyle = "#cfd8dc";
            ctx.globalAlpha = 0.95;
            const labelMap = {
              health: "HEALTH",
              speed: "SPEED",
              ammo: "AMMO",
              weapon: "WEAPON",
              shield: "SHIELD",
              magnet: "MAGNET",
              freeze: "FREEZE",
              blast: "BLAST",
              treasure: "TREASURE",
              key: "KEY",
              coin: "COIN (10)",
              gem: "GEM (25)",
              crystal: "CRYSTAL (50)",
              orb: "ORB (75)",
              relic: "RELIC (100)",
              artifact: "ARTIFACT (150)",
              medallion: "MEDALLION (250)",
              scroll: "SCROLL (400)",
              crown: "CROWN (1000)",
            };
            const lbl = labelMap[pk.type] || String(pk.type).toUpperCase();
            if (lbl) ctx.fillText(lbl, pk.x, pk.y + 14);
            ctx.restore();
          }
          ctx.lineWidth = 1;
        }
        // Bullets
        ctx.fillStyle = "#ffd54f";
        for (const b of state.bullets) {
          ctx.save();
          ctx.shadowColor = "rgba(255,213,79,.6)";
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        // Spitter globs (enemy projectiles)
        if (state.globs) {
          ctx.fillStyle = "#ce93d8";
          for (const g of state.globs) {
            ctx.save();
            ctx.shadowColor = "rgba(206,147,216,.6)";
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(g.x, g.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }
        // Bullet impact effects
        for (let i = effects.length - 1; i >= 0; i--) {
          const e = effects[i];
          e.ttl -= dt;
          if (e.ttl <= 0) {
            effects.splice(i, 1);
            continue;
          }
          ctx.save();
          const a = Math.max(0, e.ttl / 220);
          ctx.globalAlpha = a;
          ctx.strokeStyle = "#ffd54f";
          ctx.beginPath();
          ctx.arc(e.x, e.y, (1 - a) * 12 + 2, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        // AI Zombies
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            ctx.save();
            
            // Main zombie body
            ctx.fillStyle = "#ef5350";
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Class outline
            if (zombie.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (zombie.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (zombie.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else {
              ctx.strokeStyle = "#e57373";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, zombie.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            
            // State indicator
            if (zombie.state === "chasing") {
              ctx.strokeStyle = "#ff5722";
              ctx.lineWidth = 2;
              ctx.globalAlpha = 0.8;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 18, 0, Math.PI * 2);
              ctx.stroke();
            } else if (zombie.state === "attacking") {
              ctx.strokeStyle = "#d32f2f";
              ctx.lineWidth = 3;
              ctx.globalAlpha = 1;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 20, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Detection range indicator (when idle or chasing)
            if (zombie.state !== "attacking") {
              ctx.strokeStyle = "rgba(255, 87, 34, 0.15)";
              ctx.lineWidth = 1;
              ctx.globalAlpha = 0.3;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, zombie.detectionRange, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // HP bar
            const barWidth = 24;
            const barHeight = 4;
            const barX = zombie.x - barWidth / 2;
            const barY = zombie.y - 20;
            const hpRatio = zombie.hp / zombie.maxHp;
            
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = hpRatio > 0.6 ? "#4caf50" : hpRatio > 0.3 ? "#ff9800" : "#f44336";
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
            
            // Name/class label
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.font = "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(`AI ${zombie.zClass}`, zombie.x, zombie.y + 25);
            
            ctx.restore();
          }
        }

        // Players
        ctx.font =
          "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.textAlign = "center";
        let me = state.players.find((p) => p.id === playerId);
        // Detect local melee edge and record for immediate visuals
        if (me) {
          if (input.melee && !prevMelee) {
            const aimWX_forMelee = camX + input.aimX / zoom;
            const aimWY_forMelee = camY + input.aimY / zoom;
            const dx = aimWX_forMelee - me.x,
              dy = aimWY_forMelee - me.y;
            const d = Math.hypot(dx, dy) || 1;
            localMeleeDirX = dx / d;
            localMeleeDirY = dy / d;
            localMeleeAt = performance.now();
          }
          prevMelee = input.melee;
        }
        // Update and draw dash trails (under players)
        const nowT = performance.now();
        if (state.players) {
          for (const p of state.players) {
            const sp = getSmoothedPos(p.id, p.x, p.y, 0); // position for trail sampling
            let arr = trails.get(p.id) || [];
            // Append when dashing
            if (p.dashing) {
              arr.push({ x: sp.x, y: sp.y, t: nowT });
              if (arr.length > TRAIL_MAX) arr.shift();
            }
            // Prune old
            arr = arr.filter((pt) => nowT - pt.t <= TRAIL_TTL);
            trails.set(p.id, arr);
            // Draw trail
            if (arr.length >= 2) {
              for (let i = 0; i < arr.length; i++) {
                const age = nowT - arr[i].t;
                const a = Math.max(0, 1 - age / TRAIL_TTL);
                const r = 6 + 10 * a;
                ctx.save();
                // teal-ish trail with soft glow
                ctx.globalAlpha = 0.25 + 0.45 * a;
                ctx.fillStyle = "rgba(158,241,209,1)";
                ctx.shadowColor = "rgba(158,241,209,.8)";
                ctx.shadowBlur = 14 * a;
                ctx.beginPath();
                ctx.arc(arr[i].x, arr[i].y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              }
            }
          }
        }

        for (const p of state.players) {
          const sp = getSmoothedPos(p.id, p.x, p.y, dt);
          ctx.save();
          if (p.role === "streamer") {
            ctx.strokeStyle = "#4caf50";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 10, 0, Math.PI * 2);
            ctx.stroke();
            if (p.weaponed) {
              ctx.strokeStyle = "#ffa726";
              ctx.globalAlpha = 0.6;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 14, 0, Math.PI * 2);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }
            ctx.fillStyle = "#4caf50";
            ctx.globalAlpha = 0.95;
            ctx.fillText(p.name, sp.x, sp.y - 16);
          } else {
            ctx.fillStyle = p.alive ? "#ef5350" : "rgba(239,83,80,.25)";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 12, 0, Math.PI * 2);
            ctx.fill();
            // Class outline
            if (p.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (p.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (p.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else {
              ctx.strokeStyle = "#e57373";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, p.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            if (p.boosted) {
              ctx.strokeStyle = "#64b5f6";
              ctx.globalAlpha = 0.7;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 16, 0, Math.PI * 2);
              ctx.stroke();
            }
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.fillText(p.name, sp.x, sp.y - 16);
            // Emote above zombie head for 5s
            if (p.emote && (p.emoteUntil || 0) > Date.now()) {
              ctx.font =
                "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
              ctx.globalAlpha = 1;
              ctx.fillText(p.emote, sp.x, sp.y - 32);
              ctx.font =
                "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            }
          }
          // Bat swing arc visual (short-lived)
          const swingAge = (state.t || Date.now()) - (p.meleeAt || 0);
          if (swingAge >= 0 && swingAge < 220) {
            const alpha = 1 - swingAge / 220;
            const ang = Math.atan2(p.meleeDirY || 0, p.meleeDirX || 1);
            const span = Math.PI / 1.8; // ~100Â°
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              sp.x + Math.cos(ang - span / 2) * r0,
              sp.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              sp.x + Math.cos(ang + span / 2) * r0,
              sp.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
          ctx.restore();
        }

        // Crosshair for local player (world coordinates)
        me = state.players.find((p) => p.id === playerId);
        if (me) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,.5)";
          ctx.beginPath();
          ctx.arc(aimWX, aimWY, 6, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(aimWX - 8, aimWY);
          ctx.lineTo(aimWX + 8, aimWY);
          ctx.moveTo(aimWX, aimWY - 8);
          ctx.lineTo(aimWX, aimWY + 8);
          ctx.stroke();
          ctx.restore();
          // Muzzle flashes rendering
          for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
            const mf = muzzleFlashes[i];
            mf.ttl -= dt;
            if (mf.ttl <= 0) {
              muzzleFlashes.splice(i, 1);
              continue;
            }
            const a = Math.max(0, mf.ttl / 90);
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            ctx.globalAlpha = a;
            const g = ctx.createRadialGradient(mf.x, mf.y, 0, mf.x, mf.y, 18);
            g.addColorStop(0, "rgba(255,220,160,0.9)");
            g.addColorStop(1, "rgba(255,220,160,0)");
            ctx.fillStyle = g;
            ctx.fillRect(mf.x - 20, mf.y - 20, 40, 40);
            ctx.restore();
          }

          // Local predicted bat swing arc so streamer sees swing instantly
          const age = performance.now() - localMeleeAt;
          if (age >= 0 && age < 220) {
            const alpha = 1 - age / 220;
            const ang = Math.atan2(localMeleeDirY, localMeleeDirX);
            const span = Math.PI / 1.8; // ~100Â°
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }

          // Also render server-synced swing for local player (fallback)
          const swingAgeSrv = (state.t || Date.now()) - (me.meleeAt || 0);
          if (swingAgeSrv >= 0 && swingAgeSrv < 220) {
            const alpha = 1 - swingAgeSrv / 220;
            const ang = Math.atan2(me.meleeDirY || 0, me.meleeDirX || 1);
            const span = Math.PI / 1.8;
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
        }

        // End world transform
        // Darkness/lighting overlay in world space
        drawLighting(camX, camY, rect.width / zoom, rect.height / zoom);
        ctx.restore();

        // Dash cooldown indicator (bottom-center) — doubled size
        if (meHud) {
          const readyAt = meHud.dashReadyAt || 0;
          const lastAt = meHud.lastDashAt || 0;
          const nowMs = Date.now();
          const total = Math.max(1, readyAt - lastAt);
          const remain = Math.max(0, readyAt - nowMs);
          const frac = 1 - Math.min(1, remain / total);
          const meterPad = 24; // padding from bottom
          const r2 = 24; // doubled radius
          const cx2 = rect.width / 2;
          const cy2 = rect.height - meterPad - 52; // push up to fit bigger meter
          ctx.save();
          // backdrop behind the meter
          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(18,20,24,.86)";
          ctx.strokeStyle = "rgba(255,255,255,.08)";
          ctx.lineWidth = 2;
          roundRect(ctx, cx2 - 52, cy2 - 52, 104, 110, 28, true, true);
          // background circle
          ctx.beginPath();
          ctx.strokeStyle = "rgba(255,255,255,.18)";
          ctx.lineWidth = 6;
          ctx.arc(cx2, cy2, r2, 0, Math.PI * 2);
          ctx.stroke();
          // progress arc
          ctx.beginPath();
          ctx.strokeStyle = remain <= 0 ? "#2dd4bf" : "#90caf9";
          ctx.lineWidth = 7;
          ctx.arc(
            cx2,
            cy2,
            r2,
            -Math.PI / 2,
            -Math.PI / 2 + Math.PI * 2 * frac
          );
          ctx.stroke();
          // label below meter
          ctx.fillStyle = "#cfd8dc";
          ctx.font =
            "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Dash", cx2, cy2 + 48);
          ctx.restore();
        }

        // Mini-map (bottom-right, circular)
        drawMiniMap();


        // Screen-space border overlay
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#808080";
        ctx.strokeRect(1, 1, rect.width - 2, rect.height - 2);
      }

      // small util for rounded rects on HUD
      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (typeof r === "number") r = { tl: r, tr: r, br: r, bl: r };
        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        ctx.quadraticCurveTo(x, y, x + r.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      function drawMiniMap() {
        const rect = c.getBoundingClientRect();
        const mmSize = 160;
        const pad = 12;
        const cx = rect.width - pad - mmSize / 2;
        const cy = rect.height - pad - mmSize / 2;
        const R = mmSize / 2 - 4;
        const W = (state.arena && state.arena.w) || 960;
        const H = (state.arena && state.arena.h) || 540;
        // Zoom in a bit and center around the local player if available
        const meMM =
          state.players && state.players.find((p) => p.id === playerId);
        const centerX = meMM ? meMM.x : W / 2;
        const centerY = meMM ? meMM.y : H / 2;
        const MM_ZOOM = 1.6; // >1 zooms in
        const scale = (2 * R * MM_ZOOM) / Math.max(W, H);
        // frame
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(18,20,24,.86)";
        ctx.beginPath();
        ctx.arc(cx, cy, mmSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.08)";
        ctx.lineWidth = 2;
        ctx.stroke();
        // clip to circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, Math.PI * 2);
        ctx.clip();
        // walls
        if (state.walls) {
          ctx.strokeStyle = "rgba(255,255,255,.25)";
          ctx.lineWidth = 1;
          for (const w of state.walls) {
            const x = cx + (w.x - centerX) * scale;
            const y = cy + (w.y - centerY) * scale;
            const ww = w.w * scale;
            const hh = w.h * scale;
            ctx.strokeRect(x, y, ww, hh);
          }
        }
        // extractions removed
        // players
        if (state.players) {
          for (const p of state.players) {
            const px = cx + (p.x - centerX) * scale;
            const py = cy + (p.y - centerY) * scale;
            const r = p.role === "streamer" ? 3 : 2;
            ctx.beginPath();
            ctx.fillStyle =
              p.role === "streamer"
                ? "#4caf50"
                : p.alive
                ? "#ef5350"
                : "rgba(239,83,80,.4)";
            ctx.arc(px, py, r, 0, Math.PI * 2);
            ctx.fill();
            if (p.id === playerId) {
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        
        // AI zombies on minimap
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            const px = cx + (zombie.x - centerX) * scale;
            const py = cy + (zombie.y - centerY) * scale;
            ctx.beginPath();
            ctx.fillStyle = zombie.state === "chasing" ? "#ff5722" : zombie.state === "attacking" ? "#d32f2f" : "#ef5350";
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Small state indicator
            if (zombie.state === "chasing" || zombie.state === "attacking") {
              ctx.strokeStyle = zombie.state === "attacking" ? "#d32f2f" : "#ff5722";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        ctx.restore(); // unclip
        ctx.restore();
      }

      function drawTiles(viewX, viewY, viewW, viewH) {
        const m = gameMap;
        if (!m) return;
        const sz = m.size;
        const theme = m.theme || "dungeon";
        const pal =
          theme === "dungeon"
            ? {
                floor: "#0e1115",
                wall: "#2a2f36",
                pit: "#0b0d11",
                water: "#0d1b2a",
                edge: "#9aa4b2",
                propCrate: "#6d4c41",
                propPillar: "#b0bec5",
                propBone: "#8d6e63",
              }
            : theme === "cave"
            ? {
                floor: "#0d1113",
                wall: "#263238",
                pit: "#0a0e10",
                water: "#0b1f2d",
                edge: "#90a4ae",
                propCrate: "#546e7a",
                propPillar: "#90caf9",
                propBone: "#80cbc4",
              }
            : {
                floor: "#111416",
                wall: "#3c4148",
                pit: "#0b0c0d",
                water: "#14212e",
                edge: "#b0bec5",
                propCrate: "#90a4ae",
                propPillar: "#cfd8dc",
                propBone: "#b0bec5",
              };
        const sx = Math.max(0, Math.floor(viewX / sz) - 1),
          sy = Math.max(0, Math.floor(viewY / sz) - 1);
        const ex = Math.min(m.w - 1, Math.ceil((viewX + viewW) / sz) + 1),
          ey = Math.min(m.h - 1, Math.ceil((viewY + viewH) / sz) + 1);
        // Floor
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 0) {
              // floor
              ctx.fillStyle = pal.floor;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Pits/Water
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 2) {
              ctx.fillStyle = pal.pit;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
            if (id === 3) {
              ctx.fillStyle = pal.water;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Walls autotile outline
        const isWall = (ix, iy) =>
          ix >= 0 &&
          iy >= 0 &&
          ix < m.w &&
          iy < m.h &&
          m.tiles[iy * m.w + ix] === 1;
        ctx.fillStyle = pal.wall;
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            if (!isWall(x, y)) continue;
            const px = x * sz,
              py = y * sz;
            ctx.fillRect(px, py, sz, sz);
            ctx.strokeStyle = pal.edge;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.15;
            if (!isWall(x, y - 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px + sz, py);
              ctx.stroke();
            }
            if (!isWall(x + 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px + sz, py);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x, y + 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py + sz);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x - 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px, py + sz);
              ctx.stroke();
            }
            ctx.globalAlpha = 1;
          }
        }
        // Props
        for (const p of m.props || []) {
          const px = p.x * sz,
            py = p.y * sz;
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle =
            p.type === "crate"
              ? pal.propCrate
              : p.type === "pillar"
              ? pal.propPillar
              : pal.propBone;
          ctx.fillRect(px + 4, py + 4, sz - 8, sz - 8);
          ctx.restore();
        }
        // Lights (simple ambient blit)
        for (const l of m.lights || []) {
          const cx = l.x * sz + sz / 2,
            cy = l.y * sz + sz / 2;
          const rr = l.r * sz;
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rr);
          g.addColorStop(0, `rgba(255,255,200,${0.35 * l.a})`);
          g.addColorStop(1, "rgba(255,255,200,0)");
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = g;
          ctx.fillRect(cx - rr, cy - rr, rr * 2, rr * 2);
          ctx.restore();
        }
      }
        ctx.restore();
      
        
        ctx.restore();
      
      function drawLighting(viewX, viewY, viewW, viewH) {
        // Lighting system temporarily disabled to remove dots
        return;
      }

      function updatePlayerList(players) {
        playersEl.innerHTML = players
          .map(
            (p) =>
              `<span class="pill ${p.role}">${
                p.role === "streamer" ? "🟢" : "🧟"
              } ${p.name}${p.role === "streamer" ? " · " + p.score : ""}</span>`
          )
          .join(" ");
      }

      function flash() {
        flashEl.classList.add("show");
        setTimeout(() => flashEl.classList.remove("show"), 150);
      }

      function updateTimer(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = seconds % 60;
        timerEl.textContent = `Time: ${min}:${sec.toString().padStart(2, "0")}`;
      }

      function appendChat(from, message) {
        chatMessagesEl.innerHTML += `<div>${from}: ${message}</div>`;
        while (chatMessagesEl.children.length > 10) {
          chatMessagesEl.removeChild(chatMessagesEl.firstChild);
        }
      }

      function sendChat(msg) {
        if (ws && ws.readyState === 1)
          ws.send(JSON.stringify({ type: "chat", message: msg }));
      }

      // Animation loop for effects and smoother visuals
      let last = performance.now();
      const fpsSamples = [];
      const fpsWindow = 120; // ~2s at 60fps
      let lastNerdUpdate = 0;
      lastHp = 100;
      function loop() {
        const now = performance.now();
        const dt = now - last;
        last = now;
        draw(dt);
        // FPS tracking
        const fps = dt > 0 ? 1000 / dt : 0;
        fpsSamples.push(fps);
        if (fpsSamples.length > fpsWindow) fpsSamples.shift();
        // State messages per second
        if (now - lastStateRateAt >= 1000) {
          statesPerSec = stateMsgCount;
          stateMsgCount = 0;
          lastStateRateAt = now;
        }
        // Update nerd overlay at ~4Hz
        if (nerdOn && now - lastNerdUpdate > 250) {
          const avgFps = fpsSamples.length
            ? fpsSamples.reduce((a, b) => a + b, 0) / fpsSamples.length
            : 0;
          const minFps = fpsSamples.length ? Math.min(...fpsSamples) : 0;
          const maxFps = fpsSamples.length ? Math.max(...fpsSamples) : 0;
          const lat = latency
            ? latency.getLatencyStats()
            : { avg: 0, min: 0, max: 0, jitter: 0 };
          const players = state.players?.length || 0;
          const zombies =
            state.players?.filter((p) => p.role === "zombie").length || 0;
          const bullets = state.bullets?.length || 0;
          const pickups = state.pickups?.length || 0;
          const walls = state.walls?.length || 0;
          const wsBuf = (ws && ws.bufferedAmount) || 0;
          nerdPanel.innerHTML = `
          <div><strong>Nerd Stats</strong></div>
          <div>FPS: ${avgFps.toFixed(1)} (min ${minFps.toFixed(
            0
          )} max ${maxFps.toFixed(0)})</div>
          <div>Latency: ${lat.avg.toFixed(1)} ms (min ${lat.min.toFixed(
            0
          )} max ${lat.max.toFixed(0)}) jitter ${lat.jitter.toFixed(1)} ms</div>
          <div>States/s: ${statesPerSec.toFixed(0)}</div>
          <div>Entities: players ${players} (z ${zombies}) bullets ${bullets} pickups ${pickups} walls ${walls}</div>
          <div>WS buf: ${wsBuf}</div>
        `;
          lastNerdUpdate = now;
        }
        requestAnimationFrame(loop);
      }
      loop();

      // Weapon switching
      function sendSwitchWeapon(w) {
        if (ws && ws.readyState === 1)
          ws.send(JSON.stringify({ type: "switch_weapon", weapon: w }));
      }
      document.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        if (e.key === "1") sendSwitchWeapon("pistol");
        if (e.key === "2") sendSwitchWeapon("smg");
        if (e.key === "3") sendSwitchWeapon("shotgun");
        if (e.key === "4") {
          // Attempt shotgun purchase
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "shotgun" }));
        }
        if (e.key === "5") {
          // Attempt SMG purchase
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "smg" }));
        }
        // Extraction removed; X key unused
      });
      document.querySelectorAll(".weapon").forEach((btn) =>
        btn.addEventListener("click", (e) => {
          const el = e.currentTarget;
          const w = el && el.getAttribute("data-weapon");
          if (!w) return;
          // Guard against selecting locked weapons
          if (el.classList.contains("locked")) {
            try {
              import("/common.js").then(
                (m) => m.toast && m.toast("Locked: unlock with banked first")
              );
            } catch {}
            return;
          }
          sendSwitchWeapon(w);
        })
      );
      if (buyShotgunBtn) {
        buyShotgunBtn.addEventListener("click", () => {
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "shotgun" }));
        });
      }
      if (buySmgBtn) {
        buySmgBtn.addEventListener("click", () => {
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "smg" }));
        });
      }

      // Fullscreen toggle
      document.getElementById("fullscreen").onclick = async () => {
        if (!document.fullscreenElement) {
          await document.documentElement.requestFullscreen().catch(() => {});
        } else {
          await document.exitFullscreen().catch(() => {});
        }
      };

      newBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (ws && ws.readyState === 1) {
          leaveRoom(true);
        } else {
          boot();
        }
      };
      copyBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (!copyBtn.disabled && link.value) {
          navigator.clipboard.writeText(link.value);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        }
      };
      toggleChatBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (!ws || ws.readyState !== 1) return;
        // Flip desired state based on button label
        const enable = toggleChatBtn.textContent.includes("Enable");
        ws.send(JSON.stringify({ type: "toggle_chat", disabled: !enable }));
      };

      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && chatInput.value.trim()) {
          sendChat(chatInput.value.trim());
          chatInput.value = "";
        }
      });
    </script>
  </body>
</html>


