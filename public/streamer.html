<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Arena Shooter Streamer</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body class="game">
    <div class="topbar">
      <div class="brand">Arena Shooter</div>
      <div class="middle-controls">
        <span class="badge" id="status" data-state="disconnected"
          >disconnected</span
        >
      </div>
      <div class="right-controls">
        <button id="fullscreen">Fullscreen</button>
        <button id="nerdToggle">Nerd Stats</button>
      </div>
    </div>

    <div class="app">
      <div class="main">
        <div class="stage">
          <div class="hud-layer">
            <div class="hud-stack hud-top-right">
              <div class="hud-pill hud-pill--right">
                <span>Score: <strong id="hudScore">0</strong></span>
                <span>Banked: <strong id="hudBanked">0</strong></span>
              </div>
            </div>
            <div class="hud-stack hud-middle-left">
              <div id="upgradeOverlay" class="hud-panel hidden">
                <div class="hud-panel-title mono">Level Up! Choose an upgrade</div>
                <div class="choices">
                  <button class="choice" data-idx="0"></button>
                  <button class="choice" data-idx="1"></button>
                  <button class="choice" data-idx="2"></button>
                </div>
                <div class="tip mono">Press 1 / 2 / 3</div>
              </div>
              <div id="buffPanel" class="hud-panel hidden">
                <div class="hud-panel-title">Current Upgrades</div>
                <div class="hud-buff-list" id="buffList"></div>
              </div>
            </div>
            <div class="hud-stack hud-top-left">
              <div class="hud-pill">
                <span>Level: <strong id="hudLevel">0</strong></span>
                <span>XP: <strong id="hudXp">0/0</strong></span>
              </div>
            </div>
            <div class="hud-stack hud-bottom-left">
              <div class="health-bar-container">
                <div class="health-icon">‚ù§Ô∏è</div>
                <div class="health-bar">
                  <div class="health-segments" id="healthSegments"></div>
                  <div class="health-bar-bg"></div>
                </div>
              </div>
              <div class="hud-pill">
                <span>Weapon: <strong id="hudWeapon">--</strong></span>
                <span>Ammo: <strong id="hudAmmo">0</strong></span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <aside class="sidebar">
        <div class="card">
          <div class="card-title">Session</div>
          <div class="row">
            <button id="newRoom">Create Room</button>
            <button id="toggleChat" disabled>Disable Chat</button>
          </div>
          <div class="row">
            <input
              id="roomLink"
              class="mono"
              placeholder="Join link"
              readonly
            />
            <button id="copy" disabled>Copy Link</button>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Weapons</div>
          <div class="row">
            <button class="weapon" id="btnPistol" data-weapon="pistol">
              Pistol (1)
            </button>
            <button class="weapon" id="btnSmg" data-weapon="smg">
              SMG (2)
            </button>
            <button class="weapon" id="btnShotgun" data-weapon="shotgun">
              Shotgun (3)
            </button>
          </div>
          <div class="row">
            <button id="buyShotgun" title="Costs 300 banked" disabled>
              Unlock Shotgun (4) ‚Ä¢ 300
            </button>
            <button id="buySmg" title="Costs 300 banked" disabled>
              Unlock SMG (5) ‚Ä¢ 300
            </button>
          </div>
          <div class="tip">
            Right‚Äëclick or Q to swing bat. Pistol is free. Unlock SMG/Shotgun
            with banked (300 each). Use 1/2/3 to equip, 5/4 to buy.
          </div>
        </div>

        <div class="card">
          <div class="card-title">Stats</div>
          <div class="row">
            <span class="badge">Score: <span id="score">0</span></span>
            <span class="badge">Banked: <span id="banked">0</span></span>
            <span class="badge">HP: <span id="hp">100</span></span>
            <span class="badge">Weapon: <span id="weapon">pistol</span></span>
            <span class="badge">Ammo: <span id="ammo">0</span></span>
            <span class="badge" id="timer">Time: --</span>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Players</div>
          <div class="pill-list" id="players"></div>
        </div>

        <div class="card">
          <div class="card-title">Chat</div>
          <div id="chatMessages" class="chat-messages"></div>
          <div class="row"><input id="chatInput" placeholder="Chat..." /></div>
        </div>
      </aside>
    </div>
    <div class="hit-flash" id="flash"></div>
    
    <!-- Death Screen -->
    <div id="deathScreen" class="death-screen hidden">
      <div class="death-overlay"></div>
      <div class="death-content">
        <div class="death-header">
          <h1 class="death-title">üíÄ RAID ENDED üíÄ</h1>
          <div class="death-subtitle">Mission Statistics</div>
        </div>
        
        <div class="death-stats">
          <div class="stats-grid">
            <div class="stat-category">
              <h3>üéØ Combat Stats</h3>
              <div class="stat-item">
                <span class="stat-label">Enemies Killed:</span>
                <span class="stat-value" id="deathEnemiesKilled">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Bosses Defeated:</span>
                <span class="stat-value" id="deathBossesKilled">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Bullets Fired:</span>
                <span class="stat-value" id="deathBulletsFired">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Accuracy:</span>
                <span class="stat-value" id="deathAccuracy">0%</span>
              </div>
            </div>
            
            <div class="stat-category">
              <h3>üìä Progression</h3>
              <div class="stat-item">
                <span class="stat-label">Level Reached:</span>
                <span class="stat-value" id="deathLevel">1</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Total XP Gained:</span>
                <span class="stat-value" id="deathTotalXP">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Final Score:</span>
                <span class="stat-value" id="deathFinalScore">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Time Survived:</span>
                <span class="stat-value" id="deathTimeSurvived">0:00</span>
              </div>
            </div>
            
            <div class="stat-category">
              <h3>üí∞ Resources</h3>
              <div class="stat-item">
                <span class="stat-label">Coins Collected:</span>
                <span class="stat-value" id="deathCoinsCollected">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Pickups Taken:</span>
                <span class="stat-value" id="deathPickupsTaken">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Damage Dealt:</span>
                <span class="stat-value" id="deathDamageDealt">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Damage Taken:</span>
                <span class="stat-value" id="deathDamageTaken">0</span>
              </div>
            </div>
          </div>
          
          <div class="upgrades-section">
            <h3>‚ö° Final Upgrades</h3>
            <div class="final-upgrades" id="deathFinalUpgrades">
              <div class="no-upgrades">No upgrades acquired</div>
            </div>
          </div>
          
          <div class="enemy-breakdown">
            <h3>üßü Enemy Breakdown</h3>
            <div class="enemy-stats" id="deathEnemyBreakdown">
              <div class="enemy-type">
                <span class="enemy-name">Basic Zombies:</span>
                <span class="enemy-count" id="deathBasicZombies">0</span>
              </div>
              <div class="enemy-type">
                <span class="enemy-name">Runners:</span>
                <span class="enemy-count" id="deathRunners">0</span>
              </div>
              <div class="enemy-type">
                <span class="enemy-name">Brutes:</span>
                <span class="enemy-count" id="deathBrutes">0</span>
              </div>
              <div class="enemy-type">
                <span class="enemy-name">Spitters:</span>
                <span class="enemy-count" id="deathSpitters">0</span>
              </div>
              <div class="enemy-type">
                <span class="enemy-name">Stalkers:</span>
                <span class="enemy-count" id="deathStalkers">0</span>
              </div>
              <div class="enemy-type">
                <span class="enemy-name">Bombers:</span>
                <span class="enemy-count" id="deathBombers">0</span>
              </div>
            </div>
          </div>
        </div>
        
        <div class="death-actions">
          <button id="restartRaid" class="death-btn death-btn-primary">üîÑ Restart Raid</button>
          <button id="exitToMenu" class="death-btn death-btn-secondary">üè† Exit to Menu</button>
        </div>
      </div>
    </div>

    <script type="module">
      import {
        connect,
        nameStorage,
        minimalCanvas,
        inputController,
        suppressPageHotkeys,
        toast,
        createLatencyMonitor,
      } from "/common.js";

      const urlParams = new URLSearchParams(location.search);
      const presetRoom = urlParams.get('room') || '';
      const create = async () => {
        if (presetRoom) return presetRoom;
        const res = await fetch("/create", { method: "POST" });
        const { roomId } = await res.json();
        return roomId;
      };

      const { c, ctx } = minimalCanvas(1440, 810);
      const stage = document.querySelector(".stage");
      stage.appendChild(c);
      
      // Move HUD layer to be positioned relative to canvas
      const hudLayer = document.querySelector(".hud-layer");
      if (hudLayer) {
        // Position HUD layer to match canvas dimensions and position
        const updateHudPosition = () => {
          const canvasRect = c.getBoundingClientRect();
          const stageRect = stage.getBoundingClientRect();
          
          hudLayer.style.left = (canvasRect.left - stageRect.left) + 'px';
          hudLayer.style.top = (canvasRect.top - stageRect.top) + 'px';
          hudLayer.style.width = canvasRect.width + 'px';
          hudLayer.style.height = canvasRect.height + 'px';
        };
        
        // Update position initially and on resize
        updateHudPosition();
        window.addEventListener('resize', updateHudPosition);
        
        // Handle fullscreen changes for HUD positioning with multiple attempts
        const handleHudFullscreenChange = () => {
          setTimeout(updateHudPosition, 50);
          setTimeout(updateHudPosition, 150);
          setTimeout(updateHudPosition, 300);
          setTimeout(updateHudPosition, 500);
        };
        
        document.addEventListener('fullscreenchange', handleHudFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleHudFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleHudFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleHudFullscreenChange);
        
        // Also update when canvas size changes
        const resizeObserver = new ResizeObserver(updateHudPosition);
        resizeObserver.observe(c);
      }
      suppressPageHotkeys();
      const input = inputController();

      let ws,
        roomId,
        playerId,
        arena = { w: 960, h: 540 };
      let state = { players: [], bullets: [], arena, remainingTime: 0, aiZombies: [] };
      let gameMap = null; // {w,h,size,theme,tiles:Uint8Array, props, lights}
      let lastHp = 100;
      let lastStateTime = performance.now();
      let lastScore = 0;
      const effects = []; // bullet impacts etc {x,y,ttl}
      // Screen shake accumulator (reduced each frame)
      let shake = 0;
      let muzzleFlashes = [];
      let prevShoot = false;
      let lastMuzzleAt = 0;
      let prevBulletPos = new Map();
      // Damage numbers for floating damage display
      let damageNumbers = [];
      // Dash trails: per-player history of recent positions while dashing
      const trails = new Map(); // id -> Array<{x:number,y:number,t:number}>
      const TRAIL_TTL = 260; // ms
      const TRAIL_MAX = 22;
      // Local melee feedback (client-side prediction so streamer sees instantly)
      let localMeleeAt = 0;
      let localMeleeDirX = 1;
      let localMeleeDirY = 0;
      let prevMelee = false;

      const link = document.getElementById("roomLink");
      const status = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const bankedEl = document.getElementById("banked");
      const hpEl = document.getElementById("hp");
      const ammoEl = document.getElementById("ammo");
      const weaponEl = document.getElementById("weapon");
      const playersEl = document.getElementById("players");
      const buyShotgunBtn = document.getElementById("buyShotgun");
      const buySmgBtn = document.getElementById("buySmg");
      const btnPistol = document.getElementById("btnPistol");
      const btnSmg = document.getElementById("btnSmg");
      const btnShotgun = document.getElementById("btnShotgun");
      const flashEl = document.getElementById("flash");
      const newBtn = document.getElementById("newRoom");
      const copyBtn = document.getElementById("copy");
      const timerEl = document.getElementById("timer");
      const chatMessagesEl = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const toggleChatBtn = document.getElementById("toggleChat");
      const nerdToggleBtn = document.getElementById("nerdToggle");
      const buffPanel = document.getElementById("buffPanel");
      const buffListEl = document.getElementById("buffList");
      const hudScoreEl = document.getElementById("hudScore");
      const upgradeQueue = [];
      const hudBankedEl = document.getElementById("hudBanked");
      const hudWeaponEl = document.getElementById("hudWeapon");
      const hudAmmoEl = document.getElementById("hudAmmo");
      const hudHpEl = document.getElementById("hudHp");
      const hudLevelEl = document.getElementById("hudLevel");
      const hudXpEl = document.getElementById("hudXp");
      const healthSegmentsEl = document.getElementById("healthSegments");
      const deathScreenEl = document.getElementById("deathScreen");
      const restartRaidBtn = document.getElementById("restartRaid");
      const exitToMenuBtn = document.getElementById("exitToMenu");
      // Nerd panel overlay element
      const nerdPanel = document.createElement("div");
      nerdPanel.id = "nerdPanel";
      nerdPanel.className = "nerd-panel hidden mono";
      document.body.appendChild(nerdPanel);

      // Upgrade overlay elements
      const overlay = document.getElementById('upgradeOverlay');
      const choiceEls = Array.from(overlay.querySelectorAll('.choice'));
      let currentChoices = [];
      let currentHealthSegments = 0;
      let maxHealthSegments = 10;
      let isPlayerDead = false;
      let gameStartTime = Date.now();
      let lastPlayerPos = { x: 0, y: 0 };

      // Initialize segmented health bar
      function initHealthBar(maxHp) {
        maxHealthSegments = Math.max(5, Math.min(20, Math.ceil(maxHp / 10))); // 5-20 segments
        healthSegmentsEl.innerHTML = '';
        currentHealthSegments = maxHealthSegments;
        
        for (let i = 0; i < maxHealthSegments; i++) {
          const segment = document.createElement('div');
          segment.className = 'health-segment';
          segment.dataset.index = i;
          healthSegmentsEl.appendChild(segment);
        }
      }

      // Update segmented health bar with smooth animations
      function updateHealthBar(currentHp, maxHp) {
        if (!healthSegmentsEl) return;
        
        const healthPercentage = Math.max(0, Math.min(1, currentHp / maxHp));
        const targetSegments = Math.ceil(healthPercentage * maxHealthSegments);
        const segments = healthSegmentsEl.querySelectorAll('.health-segment');
        
        // Determine health state colors
        const lowHealthThreshold = 0.3;
        const criticalHealthThreshold = 0.15;
        
        segments.forEach((segment, index) => {
          const shouldBeActive = index < targetSegments;
          const isCurrentlyActive = !segment.classList.contains('depleting') && 
                                   segment.style.transform !== 'scaleX(0)';
          
          // Remove previous state classes
          segment.classList.remove('depleting', 'filling', 'low-health', 'critical-health');
          
          if (shouldBeActive && !isCurrentlyActive) {
            // Segment should fill
            segment.classList.add('filling');
            segment.style.transform = 'scaleX(1)';
            segment.style.opacity = '1';
          } else if (!shouldBeActive && isCurrentlyActive) {
            // Segment should deplete
            segment.classList.add('depleting');
            setTimeout(() => {
              segment.style.transform = 'scaleX(0)';
              segment.style.opacity = '0';
            }, 50);
          }
          
          // Apply health state colors
          if (shouldBeActive) {
            if (healthPercentage <= criticalHealthThreshold) {
              segment.classList.add('critical-health');
            } else if (healthPercentage <= lowHealthThreshold) {
              segment.classList.add('low-health');
            }
          }
        });
        
        currentHealthSegments = targetSegments;
      }

      // Death screen functions
      function showDeathScreen(playerStats) {
        isPlayerDead = true;
        
        // Calculate time survived
        const timeAlive = Date.now() - gameStartTime;
        const minutes = Math.floor(timeAlive / 60000);
        const seconds = Math.floor((timeAlive % 60000) / 1000);
        
        // Update death screen stats
        document.getElementById('deathEnemiesKilled').textContent = playerStats.raidStats?.enemiesKilled || 0;
        document.getElementById('deathBossesKilled').textContent = playerStats.raidStats?.bossesKilled || 0;
        document.getElementById('deathBulletsFired').textContent = playerStats.raidStats?.bulletsFired || 0;
        
        const accuracy = playerStats.raidStats?.bulletsFired > 0 
          ? Math.round((playerStats.raidStats.bulletsHit / playerStats.raidStats.bulletsFired) * 100)
          : 0;
        document.getElementById('deathAccuracy').textContent = accuracy + '%';
        
        document.getElementById('deathLevel').textContent = playerStats.level || 1;
        document.getElementById('deathTotalXP').textContent = playerStats.raidStats?.totalXPGained || 0;
        document.getElementById('deathFinalScore').textContent = playerStats.score || 0;
        document.getElementById('deathTimeSurvived').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        document.getElementById('deathCoinsCollected').textContent = playerStats.raidStats?.coinsCollected || 0;
        document.getElementById('deathPickupsTaken').textContent = playerStats.raidStats?.pickupsTaken || 0;
        document.getElementById('deathDamageDealt').textContent = playerStats.raidStats?.damageDealt || 0;
        document.getElementById('deathDamageTaken').textContent = playerStats.raidStats?.damageTaken || 0;
        
        // Enemy breakdown
        const breakdown = playerStats.raidStats?.enemyBreakdown || {};
        document.getElementById('deathBasicZombies').textContent = breakdown.basic || 0;
        document.getElementById('deathRunners').textContent = breakdown.runner || 0;
        document.getElementById('deathBrutes').textContent = breakdown.brute || 0;
        document.getElementById('deathSpitters').textContent = breakdown.spitter || 0;
        document.getElementById('deathStalkers').textContent = breakdown.stalker || 0;
        document.getElementById('deathBombers').textContent = breakdown.bomber || 0;
        
        // Bosses defeated
        const bossesDefeated = playerStats.raidStats?.bossesDefeated || [];
        if (bossesDefeated.length > 0) {
          console.log('Bosses defeated:', bossesDefeated.join(', '));
        }
        
        // Final upgrades
        const upgradesEl = document.getElementById('deathFinalUpgrades');
        if (playerStats.mods && playerStats.mods.length > 0) {
          upgradesEl.innerHTML = '';
          playerStats.mods.forEach(mod => {
            const upgradeEl = document.createElement('div');
            upgradeEl.className = 'upgrade-item';
            // Use the mod name if available, otherwise format the ID
            const displayName = mod.name || mod.id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            upgradeEl.textContent = `${displayName} x${mod.stacks}`;
            upgradesEl.appendChild(upgradeEl);
          });
        } else {
          upgradesEl.innerHTML = '<div class="no-upgrades">No upgrades acquired</div>';
        }
        
        // Show the death screen
        deathScreenEl.classList.remove('hidden');
      }

      function hideDeathScreen() {
        deathScreenEl.classList.add('hidden');
        isPlayerDead = false;
      }

      function restartRaid() {
        hideDeathScreen();
        gameStartTime = Date.now();
        // Trigger a new room creation
        if (ws && ws.readyState === 1) {
          leaveRoom(true);
        }
        setTimeout(() => boot(), 100);
      }

      function exitToMenu() {
        hideDeathScreen();
        if (ws && ws.readyState === 1) {
          leaveRoom(true);
        }
      }

      function showNextUpgrade() {
        if (!upgradeQueue.length) {
          currentChoices = [];
          choiceEls.forEach((el) => { el.textContent = ''; el.disabled = true; });
          overlay.classList.add('hidden');
          return;
        }
        currentChoices = upgradeQueue.shift();
        choiceEls.forEach((el, i) => {
          const choice = currentChoices[i];
          if (!choice) { el.textContent = ''; el.disabled = true; return; }
          el.disabled = false;
          el.textContent = `${i + 1}) ${choice.name} - ${choice.desc}`;
        });
        overlay.classList.remove('hidden');
      }

      function queueUpgrade(choices) {
        const normalized = Array.isArray(choices) ? choices.filter(Boolean) : [];
        if (!normalized.length) return;
        upgradeQueue.push(normalized);
        if (overlay.classList.contains('hidden') && currentChoices.length === 0) {
          showNextUpgrade();
        }
      }

      function pickUpgrade(index) {
        const choice = currentChoices[index];
        if (!choice || !ws) return;
        try { ws.send(JSON.stringify({ type: 'choose_upgrade', id: choice.id })); } catch {}
        showNextUpgrade();
      }

      choiceEls.forEach((el, i) => el.addEventListener('click', () => pickUpgrade(i)));
      window.addEventListener('keydown', (e) => {
        if (overlay.classList.contains('hidden')) return;
        if (e.key === '1') pickUpgrade(0);
        if (e.key === '2') pickUpgrade(1);
        if (e.key === '3') pickUpgrade(2);
      });

      function xpThreshold(level) {
        return 3 + Math.floor(level * 1.8);
      }

      function renderBuffs(mods) {
        if (!buffListEl) return;
        buffListEl.innerHTML = "";
        const data = Array.isArray(mods)
          ? mods.slice()
          : Object.entries(mods || {}).map(([id, stacks]) => ({ id, stacks }));
        if (!data.length) {
          if (buffPanel) buffPanel.classList.add('hidden');
          return;
        }
        data.sort((a, b) => (a.name || a.id || '').localeCompare(b.name || b.id || ''));
        if (buffPanel) buffPanel.classList.remove('hidden');
        for (const mod of data) {
          const row = document.createElement('div');
          row.className = 'hud-buff';
          row.dataset.rarity = (mod.rarity || 'common');
          if (mod.desc) row.title = mod.desc;
          const nameEl = document.createElement('span');
          nameEl.className = 'label';
          nameEl.textContent = mod.name || mod.id;
          const stackEl = document.createElement('span');
          stackEl.className = 'stacks';
          stackEl.textContent = `x${mod.stacks ?? 1}`;
          row.append(nameEl, stackEl);
          buffListEl.appendChild(row);
        }
      }
      renderBuffs([]);

      let nerdOn = localStorage.getItem("nerdStats") === "1";
      function setNerd(on) {
        nerdOn = !!on;
        localStorage.setItem("nerdStats", nerdOn ? "1" : "0");
        nerdPanel.classList.toggle("hidden", !nerdOn);
        nerdToggleBtn.classList.toggle("active", nerdOn);
      }
      setNerd(nerdOn);
      nerdToggleBtn.onclick = () => setNerd(!nerdOn);
      copyBtn.disabled = true;
      // Camera: smooth, mouse-biased, no manual control
      let camX = 0,
        camY = 0; // top-left of viewport in world space
      const zoom = 2.4; // hotline-miami style: a bit more zoomed-in
      const mouseBias = 110; // world px to bias toward aim
      const camLerpBase = 0.05; // smoothing factor per frame higher = faster

      let inputIv = null;
      let sendNeutralHandler = null;
      let visHandler = null;

      let pingIv = null;
      let latency = null;
      let stateMsgCount = 0;
      let statesPerSec = 0;
      let lastStateRateAt = performance.now();
      async function boot() {
        if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;
        
        // Reset death screen state
        gameStartTime = Date.now();
        isPlayerDead = false;
        hideDeathScreen();
        
        roomId = await create();
        const url = `${location.origin}/join.html?room=${roomId}`;
        link.value = url;
        copyBtn.disabled = false;
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(url);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        };

        ws = connect(roomId);
        ws.addEventListener("open", () => {
          status.textContent = "connected";
          status.dataset.state = "connected";
          document.body.classList.add("connected");
          const name = nameStorage().get() || "Marine";
          ws.send(
            JSON.stringify({ type: "join_room", role: "streamer", name })
          );
          newBtn.textContent = "End Session";
          toggleChatBtn.disabled = false;
        });
        latency = createLatencyMonitor(ws);
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        pingIv = setInterval(() => {
          try {
            latency.sendPing();
          } catch {}
        }, 1000);

        ws.addEventListener("message", (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === "map") {
            try {
              const m = msg.map;
              const bin = atob(m.tilesBase64);
              const u8 = new Uint8Array(bin.length);
              for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
              gameMap = {
                w: m.w,
                h: m.h,
                size: m.size,
                theme: m.theme,
                tiles: u8,
                props: m.props || [],
                lights: m.lights || [],
              };
            } catch {}
          }
          if (msg.type === "joined") {
            playerId = msg.playerId;
            arena = msg.arena;
          }
          if (msg.type === "state") {
            stateMsgCount++;
            // detect removed bullets for small impact effect
            const curMap = new Map(
              msg.bullets.map((b) => [b.id, { x: b.x, y: b.y }])
            );
            for (const [id, pos] of prevBulletPos) {
              if (!curMap.has(id)) {
                effects.push({ x: pos.x, y: pos.y, ttl: 220 });
                shake += 2;
              }
            }
            prevBulletPos = curMap;

            // Process damage numbers
            if (msg.damageNumbers) {
              // Create a set of existing IDs for faster lookup
              const existingIds = new Set(damageNumbers.map(dn => dn.id));
              
              for (const dn of msg.damageNumbers) {
                // Check if we already have this damage number
                if (!existingIds.has(dn.id)) {
                  // Find the target entity (player or AI zombie) to attach damage number to
                  let targetId = null;
                  let isAI = false;
                  
                  // Check if damage number is near any player
                  for (const player of msg.players) {
                    const dist = Math.hypot(player.x - dn.x, player.y - dn.y);
                    if (dist < 30) { // Within 30 pixels
                      targetId = player.id;
                      break;
                    }
                  }
                  
                  // If not found near players, check AI zombies
                  if (!targetId && msg.aiZombies) {
                    for (const zombie of msg.aiZombies) {
                      const dist = Math.hypot(zombie.x - dn.x, zombie.y - dn.y);
                      if (dist < 30) { // Within 30 pixels
                        targetId = zombie.id;
                        isAI = true;
                        break;
                      }
                    }
                  }
                  
                  damageNumbers.push({
                    id: dn.id,
                    x: dn.x,
                    y: dn.y,
                    damage: dn.damage,
                    isCrit: dn.isCrit,
                    isDot: dn.isDot,
                    timestamp: dn.timestamp,
                    startTime: Date.now(),
                    offsetY: 0,
                    targetId: targetId,
                    isAI: isAI,
                    initialX: dn.x,
                    initialY: dn.y
                  });
                  
                  // Add to existing IDs set to prevent duplicates within this message
                  existingIds.add(dn.id);
                }
              }
            }

            state = msg;
            const me = msg.players.find((p) => p.id === playerId);
            if (me) {
              const hpVal = me.hp ?? 0;
              const maxHp = me.maxHp ?? hpVal;
              const level = me.level ?? 0;
              const xpVal = me.xp ?? 0;
              const xpNeed = me.xpForNext ?? xpThreshold(level);
              scoreEl.textContent = me.score;
              bankedEl.textContent = me.banked ?? 0;
              
              // Check if HP has decreased
              const prevHpText = hpEl.textContent.split('/')[0];
              const prevHp = parseInt(prevHpText) || maxHp;
              const hpDecreased = hpVal < prevHp && prevHp <= maxHp; // Only trigger if HP actually decreased and not just respawned
              
              // Update HP display
              hpEl.innerHTML = `<span id="hp-value">${hpVal}</span>/<span id="hp-max">${maxHp}</span>`;
              
              // Add pulse effect if HP decreased
              if (hpDecreased) {
                const hpValueEl = document.getElementById('hp-value');
                if (hpValueEl) {
                  hpValueEl.classList.add('hp-damage-pulse');
                  setTimeout(() => {
                    if (hpValueEl) hpValueEl.classList.remove('hp-damage-pulse');
                  }, 400);
                }
              }
              const w = me.weapon || "pistol";
              weaponEl.textContent = w;
              let ammo = 0;
              if (w === "pistol") ammo = me.pistolAmmo ?? 0;
              else if (w === "smg") ammo = me.smgAmmo ?? 0;
              else if (w === "shotgun") ammo = me.shotgunAmmo ?? 0;
              else ammo = 0;
              
              // Check if ammo has decreased
              const prevAmmo = parseInt(ammoEl.textContent) || 0;
              const ammoDecreased = ammo < prevAmmo;
              
              ammoEl.textContent = ammo;
              
              // Add pulse class if ammo decreased
              if (ammoDecreased) {
                ammoEl.classList.add('ammo-pulse');
                // Remove the class after animation completes
                setTimeout(() => ammoEl.classList.remove('ammo-pulse'), 300);
              }
              
              if (hudScoreEl) hudScoreEl.textContent = String(me.score ?? 0);
              if (hudBankedEl) hudBankedEl.textContent = String(me.banked ?? 0);
              if (hudWeaponEl) hudWeaponEl.textContent = w;
              
              // Initialize health bar if not done yet
              if (healthSegmentsEl && healthSegmentsEl.children.length === 0) {
                initHealthBar(maxHp);
              }
              
              // Update segmented health bar
              updateHealthBar(hpVal, maxHp);
              
              // Update HUD ammo counter with the same pulse effect
              if (hudAmmoEl) {
                const prevHudAmmo = parseInt(hudAmmoEl.textContent) || 0;
                hudAmmoEl.textContent = String(ammo);
                if (ammo < prevHudAmmo) {
                  hudAmmoEl.classList.add('ammo-pulse');
                  setTimeout(() => hudAmmoEl.classList.remove('ammo-pulse'), 300);
                }
              }
              // Health bar is now handled by updateHealthBar function
              if (hudLevelEl) hudLevelEl.textContent = String(level);
              if (hudXpEl) hudXpEl.textContent = `${xpVal}/${xpNeed}`;
              renderBuffs(me.mods || []);
              // Ownership inference
              const hasSmg = (me.smgAmmo ?? 0) > 0 || w === "smg";
              const hasShotgun = (me.shotgunAmmo ?? 0) > 0 || w === "shotgun";
              // Button states
              if (btnPistol) {
                btnPistol.classList.toggle("equipped", w === "pistol");
                btnPistol.classList.add("owned");
              }
              if (btnSmg) {
                btnSmg.classList.toggle("equipped", w === "smg");
                btnSmg.classList.toggle("owned", hasSmg);
                btnSmg.classList.toggle("locked", !hasSmg);
              }
              if (btnShotgun) {
                btnShotgun.classList.toggle("equipped", w === "shotgun");
                btnShotgun.classList.toggle("owned", hasShotgun);
                btnShotgun.classList.toggle("locked", !hasShotgun);
              }
              if (buyShotgunBtn) {
                const canBuy = (me.banked || 0) >= 300 && !hasShotgun;
                buyShotgunBtn.disabled = !canBuy;
                buyShotgunBtn.textContent = "Unlock Shotgun (4) ??? 300";
                buyShotgunBtn.title = canBuy
                  ? "Press 4 to purchase"
                  : "Need 300 banked or already unlocked";
              }
              if (buySmgBtn) {
                const canBuySmg = (me.banked || 0) >= 300 && !hasSmg;
                buySmgBtn.disabled = !canBuySmg;
                buySmgBtn.textContent = "Unlock SMG (5) ??? 300";
                buySmgBtn.title = canBuySmg
                  ? "Press 5 to purchase"
                  : "Need 300 banked or already unlocked";
              }
            } else {
              renderBuffs([]);
              if (hudScoreEl) hudScoreEl.textContent = '0';
              if (hudBankedEl) hudBankedEl.textContent = '0';
              if (hudWeaponEl) hudWeaponEl.textContent = '--';
              if (hudAmmoEl) hudAmmoEl.textContent = '0';
              // Clear health bar segments
              if (healthSegmentsEl) healthSegmentsEl.innerHTML = '';
              if (hudLevelEl) hudLevelEl.textContent = '0';
              if (hudXpEl) hudXpEl.textContent = '0/0';
            }
            const ping = Math.max(0, Date.now() - (msg.t || Date.now()));
            status.textContent = `connected ‚Ä¢ ${ping} ms ‚Ä¢ players: ${msg.players.length}`;
            status.dataset.state = "connected";
            state.remainingTime = msg.remainingTime;
            updateTimer(state.remainingTime);
            updatePlayerList(msg.players);
            // Update chat toggle button label from state
            if (typeof msg.chatEnabled === "boolean") {
              toggleChatBtn.textContent = msg.chatEnabled
                ? "Disable Chat"
                : "Enable Chat";
              // Hide chat card and disable input when chat is disabled
              chatInput.disabled = !msg.chatEnabled;
              chatInput.placeholder = msg.chatEnabled
                ? "Chat..."
                : "Chat disabled by streamer";
              const chatCard = chatMessagesEl.closest(".card");
              if (chatCard)
                chatCard.classList.toggle("hidden", !msg.chatEnabled);
            }
            if (me && (me.hp ?? 0) < lastHp) {
              flash();
            }
            
            // Check for death - only trigger death screen, don't auto-hide on respawn
            if (me && (me.hp ?? 0) <= 0 && !isPlayerDead) {
              console.log('Death detected! HP:', me.hp);
              showDeathScreen(me);
            }
            
            // Check for sudden teleportation (respawn after spike/poison death)
            if (me && lastPlayerPos.x !== 0 && !isPlayerDead) {
              const distMoved = Math.hypot(me.x - lastPlayerPos.x, me.y - lastPlayerPos.y);
              const hpRestored = (me.hp ?? 0) > lastHp + 20; // HP significantly increased
              
              if (distMoved > 500 && hpRestored) {
                console.log('Teleportation + HP restore detected - likely respawn! Distance:', distMoved, 'HP:', lastHp, '->', me.hp);
                showDeathScreen(me);
              }
            }
            
            // Update last position
            if (me) {
              lastPlayerPos = { x: me.x, y: me.y };
            }
            
            lastScore = me ? me.score : lastScore;
            lastHp = me ? me.hp ?? lastHp : lastHp;
            lastStateTime = performance.now();
          }
          if (msg.type === "pong") {
            if (latency) latency.handlePong(Number(msg.timestamp) || 0);
          }
          if (msg.type === "chat") {
            appendChat(msg.from, msg.message);
          }
          if (msg.type === "notice") {
            try {
              toast(msg.message);
            } catch {}
            appendChat("System", msg.message);
            
            // Check for respawn notice (pit death)
            if (msg.message && msg.message.includes("üíÄ Fell into a pit! Respawning...") && !isPlayerDead) {
              console.log('Pit death detected:', msg.message);
              const me = state.players.find((p) => p.id === playerId);
              if (me) {
                showDeathScreen(me);
              }
            }
          }
          if (msg.type === 'upgrade_offer') {
            queueUpgrade(msg.choices || []);
          }
        });
        inputIv = setInterval(() => {
          if (ws && ws.readyState === 1 && !isPlayerDead) {
            // Convert screen aim to world coordinates via camera + zoom
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: input.up,
                down: input.down,
                left: input.left,
                right: input.right,
                shoot: input.shoot,
                melee: input.melee,
                dash: input.dash,
                aimX: aimWX,
                aimY: aimWY,
              })
            );

            // Spawn a local muzzle flash near the player's muzzle for immediate feedback
            const meNow = state.players.find((p) => p.id === playerId);
            if (meNow) {
              const now = performance.now();
              const wantFlash =
                input.shoot && (!prevShoot || now - lastMuzzleAt > 110);
              if (wantFlash) {
                const dx = aimWX - meNow.x;
                const dy = aimWY - meNow.y;
                const d = Math.hypot(dx, dy) || 1;
                const muzzleOffset = 16; // distance from player center to muzzle
                const fx = meNow.x + (dx / d) * muzzleOffset;
                const fy = meNow.y + (dy / d) * muzzleOffset;
                muzzleFlashes.push({ x: fx, y: fy, ttl: 90 });
                lastMuzzleAt = now;
              }
              prevShoot = input.shoot;
            }
          }
        }, 50);

        // If focus is lost, immediately send a neutral input (interval covers it, but faster feedback helps)
        sendNeutralHandler = () => {
          if (ws && ws.readyState === 1 && !isPlayerDead) {
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: false,
                down: false,
                left: false,
                right: false,
                shoot: false,
                melee: false,
                dash: false,
                aimX: aimWX,
                aimY: aimWY,
              })
            );
          }
        };
        visHandler = () => {
          if (document.hidden) sendNeutralHandler();
        };
        window.addEventListener("blur", sendNeutralHandler);
        document.addEventListener("visibilitychange", visHandler);

        const onClose = () => {
          leaveRoom(false);
        };
        ws.addEventListener("close", onClose, { once: true });
      }

      function leaveRoom(manual = true) {
        if (inputIv) {
          clearInterval(inputIv);
          inputIv = null;
        }
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        if (sendNeutralHandler) {
          window.removeEventListener("blur", sendNeutralHandler);
          sendNeutralHandler = null;
        }
        if (visHandler) {
          document.removeEventListener("visibilitychange", visHandler);
          visHandler = null;
        }
        if (ws) {
          try {
            if (manual && ws.readyState === 1) ws.close(1000, "leave");
          } catch {}
          ws = null;
        }
        status.textContent = "disconnected";
        status.dataset.state = "disconnected";
        document.body.classList.remove("connected");
        newBtn.textContent = "Create Room";
        copyBtn.disabled = true;
        link.value = "";
        toggleChatBtn.disabled = true;
        toggleChatBtn.textContent = "Disable Chat";
        playerId = null;
        prevBulletPos = new Map();
        effects.length = 0;
        muzzleFlashes.length = 0;
        lastScore = 0;
        lastHp = 100;
        state = { players: [], bullets: [], arena };
        updatePlayerList([]);
      }

      // Smoothing map for positions (reduces 20Hz stutter)
      const smooth = new Map(); // id -> {x,y}
      const SMOOTH_TAU = 90; // ms time constant
      function getSmoothedPos(id, tx, ty, dt) {
        let s = smooth.get(id);
        if (!s) {
          s = { x: tx, y: ty };
          smooth.set(id, s);
          return { x: tx, y: ty };
        }
        const alpha = 1 - Math.exp(-dt / Math.max(1, SMOOTH_TAU));
        s.x += (tx - s.x) * alpha;
        s.y += (ty - s.y) * alpha;
        return { x: s.x, y: s.y };
      }

      function draw(dt = 16) {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const rect = c.getBoundingClientRect();
        // Reset and clear in device pixels
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, c.width, c.height);
        // Base transform to CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // Fill background with dungeon-themed dark color in CSS px
        ctx.fillStyle = "#0a0c0f";
        ctx.fillRect(0, 0, rect.width, rect.height);
        // Update camera target (follow player with slight mouse bias)
        const meRawForCam = state.players.find((p) => p.id === playerId);
        const meHud = meRawForCam || null;
        const meCam = meRawForCam
          ? getSmoothedPos(meRawForCam.id, meRawForCam.x, meRawForCam.y, dt)
          : null;
        if (meCam) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          const dx = aimWX - meCam.x,
            dy = aimWY - meCam.y;
          const d = Math.hypot(dx, dy) || 1;
          const offX = (dx / d) * mouseBias,
            offY = (dy / d) * mouseBias;
          const viewW = rect.width / zoom,
            viewH = rect.height / zoom;
          const targetX = Math.min(
            Math.max(0, meCam.x + offX - viewW / 2),
            Math.max(0, arena.w - viewW)
          );
          const targetY = Math.min(
            Math.max(0, meCam.y + offY - viewH / 2),
            Math.max(0, arena.h - viewH)
          );
          const k = Math.min(1, (dt / 16) * camLerpBase);
          camX = camX + (targetX - camX) * k;
          camY = camY + (targetY - camY) * k;
        }
        // Begin world transform
        ctx.save();
        ctx.scale(zoom, zoom);
        // Screen shake
        const sAmt = Math.max(0, shake);
        shake = Math.max(0, shake * 0.9 - 0.2);
        const sdx = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        const sdy = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        ctx.translate(-camX + sdx, -camY + sdy);
        // Tile layer
        if (gameMap)
          drawTiles(camX, camY, rect.width / zoom, rect.height / zoom);
        // Walls/rooms
        if (state.walls) {
          ctx.fillStyle = "#2a2f36";
          for (const w of state.walls) {
            ctx.fillRect(w.x, w.y, w.w, w.h);
          }
        }
        // Extractions removed
        // Pickups
        if (state.pickups) {
          for (const pk of state.pickups) {
            ctx.save();
            ctx.shadowColor = "rgba(255,255,255,.16)";
            ctx.shadowBlur = 8;
            if (pk.type === "health") {
              ctx.strokeStyle = "#66bb6a";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 8, 16, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x + 6, pk.y);
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "speed") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x - 5, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x - 2, pk.y - 2);
              ctx.lineTo(pk.x + 5, pk.y + 8);
              ctx.stroke();
            } else if (pk.type === "ammo") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 7, pk.y - 5, 14, 10);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y + 1);
              ctx.lineTo(pk.x - 4, pk.y - 1);
              ctx.moveTo(pk.x, pk.y + 1);
              ctx.lineTo(pk.x, pk.y - 1);
              ctx.moveTo(pk.x + 4, pk.y + 1);
              ctx.lineTo(pk.x + 4, pk.y - 1);
              ctx.stroke();
            } else if (pk.type === "weapon") {
              ctx.strokeStyle = "#ffa726";
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x - 6, pk.y);
              ctx.stroke();
            } else if (pk.type === "shield") {
              ctx.strokeStyle = "#26c6da";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 9, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "magnet") {
              ctx.strokeStyle = "#ab47bc";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x - 3, pk.y, 6, -Math.PI / 2, Math.PI / 2);
              ctx.arc(pk.x + 3, pk.y, 6, Math.PI / 2, -Math.PI / 2);
              ctx.stroke();
            } else if (pk.type === "freeze") {
              ctx.strokeStyle = "#90caf9";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x, pk.y + 7);
              ctx.moveTo(pk.x - 7, pk.y);
              ctx.lineTo(pk.x + 7, pk.y);
              ctx.moveTo(pk.x - 5, pk.y - 5);
              ctx.lineTo(pk.x + 5, pk.y + 5);
              ctx.moveTo(pk.x - 5, pk.y + 5);
              ctx.lineTo(pk.x + 5, pk.y - 5);
              ctx.stroke();
            } else if (pk.type === "blast") {
              ctx.strokeStyle = "#ff7043";
              ctx.lineWidth = 2;
              for (let i = 0; i < 8; i++) {
                const a = (i * Math.PI) / 4;
                ctx.beginPath();
                ctx.moveTo(pk.x + Math.cos(a) * 3, pk.y + Math.sin(a) * 3);
                ctx.lineTo(pk.x + Math.cos(a) * 10, pk.y + Math.sin(a) * 10);
                ctx.stroke();
              }
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 3, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "treasure") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x, pk.y + 1, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "coin") {
              ctx.strokeStyle = "#ffc107";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 6, 0, Math.PI * 2);
              ctx.stroke();
              ctx.fillStyle = "#ffc107";
              ctx.globalAlpha = 0.3;
              ctx.fill();
            } else if (pk.type === "gem") {
              ctx.strokeStyle = "#e91e63";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x - 5, pk.y - 2);
              ctx.lineTo(pk.x - 3, pk.y + 7);
              ctx.lineTo(pk.x + 3, pk.y + 7);
              ctx.lineTo(pk.x + 5, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "crystal") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#9c27b0";
              ctx.shadowBlur = 6;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x - 4, pk.y - 2);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.lineTo(pk.x + 4, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "orb") {
              ctx.strokeStyle = "#2196f3";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#2196f3";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 7, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x - 2, pk.y - 2, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "relic") {
              ctx.strokeStyle = "#795548";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#795548";
              ctx.shadowBlur = 6;
              ctx.strokeRect(pk.x - 6, pk.y - 8, 12, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y - 4);
              ctx.moveTo(pk.x - 2, pk.y);
              ctx.lineTo(pk.x + 2, pk.y);
              ctx.stroke();
            } else if (pk.type === "artifact") {
              ctx.strokeStyle = "#607d8b";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#607d8b";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y - 2, 6, 0, Math.PI);
              ctx.stroke();
              ctx.strokeRect(pk.x - 4, pk.y - 2, 8, 8);
            } else if (pk.type === "medallion") {
              ctx.strokeStyle = "#ff9800";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#ff9800";
              ctx.shadowBlur = 10;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 8, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.moveTo(pk.x + 4, pk.y - 4);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.stroke();
            } else if (pk.type === "scroll") {
              ctx.strokeStyle = "#8bc34a";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#8bc34a";
              ctx.shadowBlur = 12;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y - 2);
              ctx.lineTo(pk.x + 6, pk.y - 2);
              ctx.moveTo(pk.x - 6, pk.y + 2);
              ctx.lineTo(pk.x + 6, pk.y + 2);
              ctx.stroke();
            } else if (pk.type === "crown") {
              ctx.strokeStyle = "#ffd700";
              ctx.lineWidth = 4;
              ctx.shadowColor = "#ffd700";
              ctx.shadowBlur = 15;
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y + 4);
              ctx.lineTo(pk.x - 4, pk.y - 6);
              ctx.lineTo(pk.x - 2, pk.y + 2);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x + 4, pk.y - 6);
              ctx.lineTo(pk.x + 8, pk.y + 4);
              ctx.lineTo(pk.x - 8, pk.y + 4);
              ctx.stroke();
            }
            // label under pickup
            ctx.font =
              "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.fillStyle = "#cfd8dc";
            ctx.globalAlpha = 0.95;
            const labelMap = {
              health: "HEALTH",
              speed: "SPEED",
              ammo: "AMMO",
              weapon: "WEAPON",
              shield: "SHIELD",
              magnet: "MAGNET",
              freeze: "FREEZE",
              blast: "BLAST",
              treasure: "TREASURE",
              key: "KEY",
              coin: "COIN (10)",
              gem: "GEM (25)",
              crystal: "CRYSTAL (50)",
              orb: "ORB (75)",
              relic: "RELIC (100)",
              artifact: "ARTIFACT (150)",
              medallion: "MEDALLION (250)",
              scroll: "SCROLL (400)",
              crown: "CROWN (1000)",
            };
            const lbl = labelMap[pk.type] || String(pk.type).toUpperCase();
            if (lbl) ctx.fillText(lbl, pk.x, pk.y + 14);
            ctx.restore();
          }
          ctx.lineWidth = 1;
        }
        // Bullets
        ctx.fillStyle = "#ffd54f";
        for (const b of state.bullets) {
          ctx.save();
          ctx.shadowColor = "rgba(255,213,79,.6)";
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        // Spitter globs (enemy projectiles)
        if (state.globs) {
          ctx.fillStyle = "#ce93d8";
          for (const g of state.globs) {
            ctx.save();
            ctx.shadowColor = "rgba(206,147,216,.6)";
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(g.x, g.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }
        // Bullet impact effects
        for (let i = effects.length - 1; i >= 0; i--) {
          const e = effects[i];
          e.ttl -= dt;
          if (e.ttl <= 0) {
            effects.splice(i, 1);
            continue;
          }
          ctx.save();
          ctx.globalAlpha = e.ttl / 220;
          ctx.fillStyle = "#ff6b35";
          ctx.beginPath();
          ctx.arc(e.x, e.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Damage numbers - clean up old ones first
        const now = Date.now();
        
        // Remove damage numbers older than server timestamp or animation time
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
          const dn = damageNumbers[i];
          const age = now - dn.startTime;
          const maxAge = 1500; // 1.5 seconds
          const serverAge = now - dn.timestamp;
          
          // Remove if animation is done OR if server timestamp is too old
          if (age > maxAge || serverAge > 2000) {
            damageNumbers.splice(i, 1);
            continue;
          }
        }
        
        // Render remaining damage numbers
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
          const dn = damageNumbers[i];
          const age = now - dn.startTime;
          const maxAge = 1500; // 1.5 seconds
          
          // Update position to follow target entity
          let renderX = dn.initialX;
          let renderY = dn.initialY;
          
          if (dn.targetId) {
            if (dn.isAI) {
              // Follow AI zombie
              const zombie = state.aiZombies?.find(z => z.id === dn.targetId);
              if (zombie) {
                renderX = zombie.x;
                renderY = zombie.y - 15; // Slightly above the zombie
              }
            } else {
              // Follow player
              const player = state.players.find(p => p.id === dn.targetId);
              if (player) {
                renderX = player.x;
                renderY = player.y - 15; // Slightly above the player
              }
            }
          }
          
          // Animation: float up and fade out
          const progress = age / maxAge;
          const alpha = Math.max(0, 1 - progress * progress); // Quadratic fade
          const offsetY = -progress * 60; // Float up 60 pixels
          
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Different styles for different damage types
          if (dn.isCrit) {
            ctx.font = 'bold 18px monospace';
            ctx.fillStyle = '#ff4444';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeText(dn.damage.toString(), renderX, renderY + offsetY);
            ctx.fillText(dn.damage.toString(), renderX, renderY + offsetY);
          } else if (dn.isDot) {
            ctx.font = '12px monospace';
            ctx.fillStyle = '#88ff44';
            ctx.fillText(dn.damage.toString(), renderX, renderY + offsetY);
          } else {
            ctx.font = '14px monospace';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(dn.damage.toString(), renderX, renderY + offsetY);
          }
          
          ctx.restore();
        }
        // AI Zombies
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            ctx.save();
            
            // Main zombie body
            ctx.fillStyle = "#ef5350";
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Class outline
            if (zombie.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (zombie.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (zombie.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else if (zombie.zClass === "stalker") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
            } else if (zombie.zClass === "bomber") {
              ctx.strokeStyle = "#f44336";
              ctx.lineWidth = 2.5;
            } else {
              ctx.strokeStyle = "#666";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, zombie.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            
            // State indicator
            if (zombie.state === "chasing") {
              ctx.strokeStyle = "#ff5722";
              ctx.lineWidth = 2;
              ctx.globalAlpha = 0.8;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 18, 0, Math.PI * 2);
              ctx.stroke();
            } else if (zombie.state === "attacking") {
              ctx.strokeStyle = "#d32f2f";
              ctx.lineWidth = 3;
              ctx.globalAlpha = 1;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 20, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Detection range indicator (when idle or chasing)
            if (zombie.state !== "attacking") {
              ctx.strokeStyle = "rgba(255, 87, 34, 0.15)";
              ctx.lineWidth = 1;
              ctx.globalAlpha = 0.3;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, zombie.detectionRange, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // HP bar
            const barWidth = 24;
            const barHeight = 4;
            const barX = zombie.x - barWidth / 2;
            const barY = zombie.y - 20;
            const hpRatio = zombie.hp / zombie.maxHp;
            
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = hpRatio > 0.6 ? "#4caf50" : hpRatio > 0.3 ? "#ff9800" : "#f44336";
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
            
            // Name/class label
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.font = "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(`AI ${zombie.zClass}`, zombie.x, zombie.y + 25);
            
            ctx.restore();
          }
        }

        // Bosses
        if (state.bosses) {
          for (const boss of state.bosses) {
            const visual = boss.visual || {};
            ctx.save();
            
            // Boss glow effect
            ctx.shadowColor = visual.glowColor || "#ff0000";
            ctx.shadowBlur = 20;
            
            // Main boss body - larger circle with unique colors
            ctx.fillStyle = visual.color || "#8B0000";
            ctx.strokeStyle = visual.secondaryColor || "#FF4500";
            ctx.lineWidth = 4;
            
            // Phase effect for Shadow Lord
            if (boss.phased) {
              ctx.globalAlpha = 0.3;
              ctx.setLineDash([5, 5]);
            }
            
            ctx.beginPath();
            ctx.arc(boss.pos.x, boss.pos.y, boss.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
            
            // Boss symbol in center
            ctx.fillStyle = "#ffffff";
            ctx.font = "20px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(visual.symbol || "üëπ", boss.pos.x, boss.pos.y);
            
            // HP bar above boss
            const barWidth = boss.radius * 2.5;
            const barHeight = 6;
            const barX = boss.pos.x - barWidth / 2;
            const barY = boss.pos.y - boss.radius - 15;
            const hpRatio = boss.hp / boss.maxHp;
            
            // HP bar background
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // HP bar fill with color based on health
            ctx.fillStyle = hpRatio > 0.6 ? "#4caf50" : hpRatio > 0.3 ? "#ff9800" : "#f44336";
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
            
            // Enrage effect for Brute King
            if (boss.enraged) {
              ctx.strokeStyle = "#ff4444";
              ctx.lineWidth = 3;
              ctx.globalAlpha = 0.8;
              ctx.beginPath();
              ctx.arc(boss.pos.x, boss.pos.y, boss.radius + 8, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Boss name and type
            ctx.globalAlpha = 1;
            ctx.fillStyle = "#ffffff";
            ctx.font = "14px system-ui";
            ctx.textAlign = "center";
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 2;
            ctx.strokeText(boss.type.toUpperCase(), boss.pos.x, boss.pos.y - boss.radius - 25);
            ctx.fillText(boss.type.toUpperCase(), boss.pos.x, boss.pos.y - boss.radius - 25);
            
            ctx.restore();
          }
        }

        // Boss minions
        if (state.bossMinions) {
          for (const minion of state.bossMinions) {
            ctx.save();
            
            // Minion body - smaller, darker
            ctx.fillStyle = "#4a148c";
            ctx.strokeStyle = "#7b1fa2";
            ctx.lineWidth = 2;
            ctx.shadowColor = "#7b1fa2";
            ctx.shadowBlur = 8;
            
            ctx.beginPath();
            ctx.arc(minion.pos.x, minion.pos.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Minion symbol
            ctx.fillStyle = "#ffffff";
            ctx.font = "12px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("üíÄ", minion.pos.x, minion.pos.y);
            
            ctx.restore();
          }
        }

        // Poison fields
        if (state.poisonFields) {
          for (const field of state.poisonFields) {
            ctx.save();
            
            // Poison field effect - pulsing green circle
            const time = Date.now() / 1000;
            const pulse = 0.7 + 0.3 * Math.sin(time * 3);
            
            ctx.globalAlpha = 0.4 * pulse;
            ctx.fillStyle = "#4caf50";
            ctx.shadowColor = "#4caf50";
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.arc(field.pos.x, field.pos.y, field.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Poison field border
            ctx.globalAlpha = 0.8;
            ctx.strokeStyle = "#8bc34a";
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.restore();
          }
        }

        // Players
        ctx.font =
          "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.textAlign = "center";
        let me = state.players.find((p) => p.id === playerId);
        // Detect local melee edge and record for immediate visuals
        if (me) {
          if (input.melee && !prevMelee) {
            const aimWX_forMelee = camX + input.aimX / zoom;
            const aimWY_forMelee = camY + input.aimY / zoom;
            const dx = aimWX_forMelee - me.x,
              dy = aimWY_forMelee - me.y;
            const d = Math.hypot(dx, dy) || 1;
            localMeleeDirX = dx / d;
            localMeleeDirY = dy / d;
            localMeleeAt = performance.now();
          }
          prevMelee = input.melee;
        }
        // Update and draw dash trails (under players)
        const nowT = performance.now();
        if (state.players) {
          for (const p of state.players) {
            const sp = getSmoothedPos(p.id, p.x, p.y, 0); // position for trail sampling
            let arr = trails.get(p.id) || [];
            // Append when dashing
            if (p.dashing) {
              arr.push({ x: sp.x, y: sp.y, t: nowT });
              if (arr.length > TRAIL_MAX) arr.shift();
            }
            // Prune old
            arr = arr.filter((pt) => nowT - pt.t <= TRAIL_TTL);
            trails.set(p.id, arr);
            // Draw trail
            if (arr.length >= 2) {
              for (let i = 0; i < arr.length; i++) {
                const age = nowT - arr[i].t;
                const a = Math.max(0, 1 - age / TRAIL_TTL);
                const r = 6 + 10 * a;
                ctx.save();
                // teal-ish trail with soft glow
                ctx.globalAlpha = 0.25 + 0.45 * a;
                ctx.fillStyle = "rgba(158,241,209,1)";
                ctx.shadowColor = "rgba(158,241,209,.8)";
                ctx.shadowBlur = 14 * a;
                ctx.beginPath();
                ctx.arc(arr[i].x, arr[i].y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              }
            }
          }
        }

        for (const p of state.players) {
          const sp = getSmoothedPos(p.id, p.x, p.y, dt);
          ctx.save();
          if (p.role === "streamer") {
            ctx.strokeStyle = "#4caf50";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 10, 0, Math.PI * 2);
            ctx.stroke();
            if (p.weaponed) {
              ctx.strokeStyle = "#ffa726";
              ctx.globalAlpha = 0.6;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 14, 0, Math.PI * 2);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }
            ctx.fillStyle = "#4caf50";
            ctx.globalAlpha = 0.95;
            ctx.fillText(p.name, sp.x, sp.y - 16);
          } else {
            ctx.fillStyle = p.alive ? "#ef5350" : "rgba(239,83,80,.25)";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 12, 0, Math.PI * 2);
            ctx.fill();
            // Class outline
            if (p.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (p.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (p.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else if (p.zClass === "stalker") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
            } else if (p.zClass === "bomber") {
              ctx.strokeStyle = "#f44336";
              ctx.lineWidth = 2.5;
            } else {
              ctx.strokeStyle = "#e57373";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, p.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            if (p.boosted) {
              ctx.strokeStyle = "#64b5f6";
              ctx.globalAlpha = 0.7;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 16, 0, Math.PI * 2);
              ctx.stroke();
            }
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.fillText(p.name, sp.x, sp.y - 16);
            // Emote above zombie head for 5s
            if (p.emote && (p.emoteUntil || 0) > Date.now()) {
              ctx.font =
                "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
              ctx.globalAlpha = 1;
              ctx.fillText(p.emote, sp.x, sp.y - 32);
              ctx.font =
                "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            }
          }
          // Bat swing arc visual (short-lived)
          const swingAge = (state.t || Date.now()) - (p.meleeAt || 0);
          if (swingAge >= 0 && swingAge < 220) {
            const alpha = 1 - swingAge / 220;
            const ang = Math.atan2(p.meleeDirY || 0, p.meleeDirX || 1);
            const span = Math.PI / 1.8; // ~100√Ç¬∞
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              sp.x + Math.cos(ang - span / 2) * r0,
              sp.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              sp.x + Math.cos(ang + span / 2) * r0,
              sp.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
          ctx.restore();
        }

        // Crosshair for local player (world coordinates)
        me = state.players.find((p) => p.id === playerId);
        if (me) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,.5)";
          ctx.beginPath();
          ctx.arc(aimWX, aimWY, 6, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(aimWX - 8, aimWY);
          ctx.lineTo(aimWX + 8, aimWY);
          ctx.moveTo(aimWX, aimWY - 8);
          ctx.lineTo(aimWX, aimWY + 8);
          ctx.stroke();
          ctx.restore();
          // Muzzle flashes rendering
          for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
            const mf = muzzleFlashes[i];
            mf.ttl -= dt;
            if (mf.ttl <= 0) {
              muzzleFlashes.splice(i, 1);
              continue;
            }
            const a = Math.max(0, mf.ttl / 90);
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            ctx.globalAlpha = a;
            const g = ctx.createRadialGradient(mf.x, mf.y, 0, mf.x, mf.y, 18);
            g.addColorStop(0, "rgba(255,220,160,0.9)");
            g.addColorStop(1, "rgba(255,220,160,0)");
            ctx.fillStyle = g;
            ctx.fillRect(mf.x - 20, mf.y - 20, 40, 40);
            ctx.restore();
          }

          // Local predicted bat swing arc so streamer sees swing instantly
          const age = performance.now() - localMeleeAt;
          if (age >= 0 && age < 220) {
            const alpha = 1 - age / 220;
            const ang = Math.atan2(localMeleeDirY, localMeleeDirX);
            const span = Math.PI / 1.8; // ~100√Ç¬∞
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }

          // Also render server-synced swing for local player (fallback)
          const swingAgeSrv = (state.t || Date.now()) - (me.meleeAt || 0);
          if (swingAgeSrv >= 0 && swingAgeSrv < 220) {
            const alpha = 1 - swingAgeSrv / 220;
            const ang = Math.atan2(me.meleeDirY || 0, me.meleeDirX || 1);
            const span = Math.PI / 1.8;
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
        }

        // End world transform
        // Darkness/lighting overlay in world space
        drawLighting(camX, camY, rect.width / zoom, rect.height / zoom);
        ctx.restore();

        // Dash cooldown indicator (bottom-center) ‚Äî doubled size
        if (meHud) {
          const readyAt = meHud.dashReadyAt || 0;
          const lastAt = meHud.lastDashAt || 0;
          const nowMs = Date.now();
          const total = Math.max(1, readyAt - lastAt);
          const remain = Math.max(0, readyAt - nowMs);
          const frac = 1 - Math.min(1, remain / total);
          const meterPad = 24; // padding from bottom
          const r2 = 24; // doubled radius
          const cx2 = rect.width / 2;
          const cy2 = rect.height - meterPad - 52; // push up to fit bigger meter
          ctx.save();
          // backdrop behind the meter
          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(18,20,24,.86)";
          ctx.strokeStyle = "rgba(255,255,255,.08)";
          ctx.lineWidth = 2;
          roundRect(ctx, cx2 - 52, cy2 - 52, 104, 110, 28, true, true);
          // background circle
          ctx.beginPath();
          ctx.strokeStyle = "rgba(255,255,255,.18)";
          ctx.lineWidth = 6;
          ctx.arc(cx2, cy2, r2, 0, Math.PI * 2);
          ctx.stroke();
          // progress arc
          ctx.beginPath();
          ctx.strokeStyle = remain <= 0 ? "#2dd4bf" : "#90caf9";
          ctx.lineWidth = 7;
          ctx.arc(
            cx2,
            cy2,
            r2,
            -Math.PI / 2,
            -Math.PI / 2 + Math.PI * 2 * frac
          );
          ctx.stroke();
          // label below meter
          ctx.fillStyle = "#cfd8dc";
          ctx.font =
            "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Dash", cx2, cy2 + 48);
          ctx.restore();
        }

        // Mini-map (bottom-right, circular)
        drawMiniMap();


        // Screen-space border overlay
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#808080";
        ctx.strokeRect(1, 1, rect.width - 2, rect.height - 2);
      }

      // small util for rounded rects on HUD
      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (typeof r === "number") r = { tl: r, tr: r, br: r, bl: r };
        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        ctx.quadraticCurveTo(x, y, x + r.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      function drawMiniMap() {
        const rect = c.getBoundingClientRect();
        const mmSize = 160;
        const pad = 12;
        const cx = rect.width - pad - mmSize / 2;
        const cy = rect.height - pad - mmSize / 2;
        const R = mmSize / 2 - 4;
        const W = (state.arena && state.arena.w) || 960;
        const H = (state.arena && state.arena.h) || 540;
        // Zoom in a bit and center around the local player if available
        const meMM =
          state.players && state.players.find((p) => p.id === playerId);
        const centerX = meMM ? meMM.x : W / 2;
        const centerY = meMM ? meMM.y : H / 2;
        const MM_ZOOM = 1.6; // >1 zooms in
        const scale = (2 * R * MM_ZOOM) / Math.max(W, H);
        // frame
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(18,20,24,.86)";
        ctx.beginPath();
        ctx.arc(cx, cy, mmSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.08)";
        ctx.lineWidth = 2;
        ctx.stroke();
        // clip to circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, Math.PI * 2);
        ctx.clip();
        // walls
        if (state.walls) {
          ctx.strokeStyle = "rgba(255,255,255,.25)";
          ctx.lineWidth = 1;
          for (const w of state.walls) {
            const x = cx + (w.x - centerX) * scale;
            const y = cy + (w.y - centerY) * scale;
            const ww = w.w * scale;
            const hh = w.h * scale;
            ctx.strokeRect(x, y, ww, hh);
          }
        }
        // extractions removed
        // players
        if (state.players) {
          for (const p of state.players) {
            const px = cx + (p.x - centerX) * scale;
            const py = cy + (p.y - centerY) * scale;
            const r = p.role === "streamer" ? 3 : 2;
            ctx.beginPath();
            ctx.fillStyle =
              p.role === "streamer"
                ? "#4caf50"
                : p.alive
                ? "#ef5350"
                : "rgba(239,83,80,.4)";
            ctx.arc(px, py, r, 0, Math.PI * 2);
            ctx.fill();
            if (p.id === playerId) {
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        
        // AI zombies on minimap
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            const px = cx + (zombie.x - centerX) * scale;
            const py = cy + (zombie.y - centerY) * scale;
            ctx.beginPath();
            ctx.fillStyle = zombie.state === "chasing" ? "#ff5722" : zombie.state === "attacking" ? "#d32f2f" : "#ef5350";
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Small state indicator
            if (zombie.state === "chasing" || zombie.state === "attacking") {
              ctx.strokeStyle = zombie.state === "attacking" ? "#d32f2f" : "#ff5722";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        
        // Bosses on minimap
        if (state.bosses) {
          for (const boss of state.bosses) {
            const px = cx + (boss.pos.x - centerX) * scale;
            const py = cy + (boss.pos.y - centerY) * scale;
            const visual = boss.visual || {};
            
            ctx.save();
            
            // Boss icon - larger and more prominent
            ctx.fillStyle = visual.color || "#8B0000";
            ctx.strokeStyle = visual.glowColor || "#ff0000";
            ctx.lineWidth = 2;
            ctx.shadowColor = visual.glowColor || "#ff0000";
            ctx.shadowBlur = 4;
            
            // Pulsing effect for bosses
            const time = Date.now() / 1000;
            const pulse = 0.8 + 0.2 * Math.sin(time * 2);
            const radius = 4 * pulse;
            
            ctx.beginPath();
            ctx.arc(px, py, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Boss symbol on minimap
            ctx.fillStyle = "#ffffff";
            ctx.font = "8px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(visual.minimapIcon || "üíÄ", px, py);
            
            // Enrage indicator
            if (boss.enraged) {
              ctx.strokeStyle = "#ff4444";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(px, py, radius + 2, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            ctx.restore();
          }
        }
        ctx.restore(); // unclip
        ctx.restore();
      }

      function drawTiles(viewX, viewY, viewW, viewH) {
        const m = gameMap;
        if (!m) return;
        const sz = m.size;
        const theme = m.theme || "dungeon";
        const pal =
          theme === "dungeon"
            ? {
                floor: "#0e1115",
                wall: "#2a2f36",
                pit: "#0b0d11",
                water: "#0d1b2a",
                edge: "#9aa4b2",
                propCrate: "#6d4c41",
                propPillar: "#b0bec5",
                propBone: "#8d6e63",
              }
            : theme === "cave"
            ? {
                floor: "#0d1113",
                wall: "#263238",
                pit: "#0a0e10",
                water: "#0b1f2d",
                edge: "#90a4ae",
                propCrate: "#546e7a",
                propPillar: "#90caf9",
                propBone: "#80cbc4",
              }
            : {
                floor: "#111416",
                wall: "#3c4148",
                pit: "#0b0c0d",
                water: "#14212e",
                edge: "#b0bec5",
                propCrate: "#90a4ae",
                propPillar: "#cfd8dc",
                propBone: "#b0bec5",
              };
        const sx = Math.max(0, Math.floor(viewX / sz) - 1),
          sy = Math.max(0, Math.floor(viewY / sz) - 1);
        const ex = Math.min(m.w - 1, Math.ceil((viewX + viewW) / sz) + 1),
          ey = Math.min(m.h - 1, Math.ceil((viewY + viewH) / sz) + 1);
        // Floor
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 0) {
              // floor
              ctx.fillStyle = pal.floor;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Pits/Water
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 2) {
              ctx.fillStyle = pal.pit;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
            if (id === 3) {
              ctx.fillStyle = pal.water;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Walls autotile outline
        const isWall = (ix, iy) =>
          ix >= 0 &&
          iy >= 0 &&
          ix < m.w &&
          iy < m.h &&
          m.tiles[iy * m.w + ix] === 1;
        ctx.fillStyle = pal.wall;
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            if (!isWall(x, y)) continue;
            const px = x * sz,
              py = y * sz;
            ctx.fillRect(px, py, sz, sz);
            ctx.strokeStyle = pal.edge;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.15;
            if (!isWall(x, y - 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px + sz, py);
              ctx.stroke();
            }
            if (!isWall(x + 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px + sz, py);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x, y + 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py + sz);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x - 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px, py + sz);
              ctx.stroke();
            }
            ctx.globalAlpha = 1;
          }
        }
        // Props
        for (const p of m.props || []) {
          const px = p.x * sz,
            py = p.y * sz;
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle =
            p.type === "crate"
              ? pal.propCrate
              : p.type === "pillar"
              ? pal.propPillar
              : pal.propBone;
          ctx.fillRect(px + 4, py + 4, sz - 8, sz - 8);
          ctx.restore();
        }
        // Lights (simple ambient blit)
        for (const l of m.lights || []) {
          const cx = l.x * sz + sz / 2,
            cy = l.y * sz + sz / 2;
          const rr = l.r * sz;
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rr);
          g.addColorStop(0, `rgba(255,255,200,${0.35 * l.a})`);
          g.addColorStop(1, "rgba(255,255,200,0)");
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = g;
          ctx.fillRect(cx - rr, cy - rr, rr * 2, rr * 2);
          ctx.restore();
        }
      }
        ctx.restore();
      
        
        ctx.restore();
      
      function drawLighting(viewX, viewY, viewW, viewH) {
        // Lighting system temporarily disabled to remove dots
        return;
      }

      function updatePlayerList(players) {
        playersEl.innerHTML = players
          .map(
            (p) =>
              `<span class="pill ${p.role}">${
                p.role === "streamer" ? "üü¢" : "üßü"
              } ${p.name}${p.role === "streamer" ? " ¬∑ " + p.score : ""}</span>`
          )
          .join(" ");
      }

      function flash() {
        flashEl.classList.add("show");
        setTimeout(() => flashEl.classList.remove("show"), 150);
      }

      function updateTimer(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = seconds % 60;
        timerEl.textContent = `Time: ${min}:${sec.toString().padStart(2, "0")}`;
      }

      function appendChat(from, message) {
        chatMessagesEl.innerHTML += `<div>${from}: ${message}</div>`;
        while (chatMessagesEl.children.length > 10) {
          chatMessagesEl.removeChild(chatMessagesEl.firstChild);
        }
      }

      function sendChat(msg) {
        if (ws && ws.readyState === 1)
          ws.send(JSON.stringify({ type: "chat", message: msg }));
      }

      // Animation loop for effects and smoother visuals
      let last = performance.now();
      const fpsSamples = [];
      const fpsWindow = 120; // ~2s at 60fps
      let lastNerdUpdate = 0;
      lastHp = 100;
      function loop() {
        const now = performance.now();
        const dt = now - last;
        last = now;
        draw(dt);
        // FPS tracking
        const fps = dt > 0 ? 1000 / dt : 0;
        fpsSamples.push(fps);
        if (fpsSamples.length > fpsWindow) fpsSamples.shift();
        // State messages per second
        if (now - lastStateRateAt >= 1000) {
          statesPerSec = stateMsgCount;
          stateMsgCount = 0;
          lastStateRateAt = now;
        }
        // Update nerd overlay at ~4Hz
        if (nerdOn && now - lastNerdUpdate > 250) {
          const avgFps = fpsSamples.length
            ? fpsSamples.reduce((a, b) => a + b, 0) / fpsSamples.length
            : 0;
          const minFps = fpsSamples.length ? Math.min(...fpsSamples) : 0;
          const maxFps = fpsSamples.length ? Math.max(...fpsSamples) : 0;
          const lat = latency
            ? latency.getLatencyStats()
            : { avg: 0, min: 0, max: 0, jitter: 0 };
          const players = state.players?.length || 0;
          const zombies =
            state.players?.filter((p) => p.role === "zombie").length || 0;
          const bullets = state.bullets?.length || 0;
          const pickups = state.pickups?.length || 0;
          const walls = state.walls?.length || 0;
          const wsBuf = (ws && ws.bufferedAmount) || 0;
          nerdPanel.innerHTML = `
          <div><strong>Nerd Stats</strong></div>
          <div>FPS: ${avgFps.toFixed(1)} (min ${minFps.toFixed(
            0
          )} max ${maxFps.toFixed(0)})</div>
          <div>Latency: ${lat.avg.toFixed(1)} ms (min ${lat.min.toFixed(
            0
          )} max ${lat.max.toFixed(0)}) jitter ${lat.jitter.toFixed(1)} ms</div>
          <div>States/s: ${statesPerSec.toFixed(0)}</div>
          <div>Entities: players ${players} (z ${zombies}) bullets ${bullets} pickups ${pickups} walls ${walls}</div>
          <div>WS buf: ${wsBuf}</div>
        `;
          lastNerdUpdate = now;
        }
        requestAnimationFrame(loop);
      }
      loop();

      // Weapon switching
      function sendSwitchWeapon(w) {
        if (ws && ws.readyState === 1)
          ws.send(JSON.stringify({ type: "switch_weapon", weapon: w }));
      }
      document.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        if (e.key === "1") sendSwitchWeapon("pistol");
        if (e.key === "2") sendSwitchWeapon("smg");
        if (e.key === "3") sendSwitchWeapon("shotgun");
        if (e.key === "4") {
          // Attempt shotgun purchase
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "shotgun" }));
        }
        if (e.key === "5") {
          // Attempt SMG purchase
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "smg" }));
        }
        // Extraction removed; X key unused
      });
      document.querySelectorAll(".weapon").forEach((btn) =>
        btn.addEventListener("click", (e) => {
          const el = e.currentTarget;
          const w = el && el.getAttribute("data-weapon");
          if (!w) return;
          // Guard against selecting locked weapons
          if (el.classList.contains("locked")) {
            try {
              import("/common.js").then(
                (m) => m.toast && m.toast("Locked: unlock with banked first")
              );
            } catch {}
            return;
          }
          sendSwitchWeapon(w);
        })
      );
      if (buyShotgunBtn) {
        buyShotgunBtn.addEventListener("click", () => {
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "shotgun" }));
        });
      }
      if (buySmgBtn) {
        buySmgBtn.addEventListener("click", () => {
          if (ws && ws.readyState === 1)
            ws.send(JSON.stringify({ type: "buy", item: "smg" }));
        });
      }

      // Fullscreen toggle
      document.getElementById("fullscreen").onclick = async () => {
        if (!document.fullscreenElement) {
          await document.documentElement.requestFullscreen().catch(() => {});
        } else {
          await document.exitFullscreen().catch(() => {});
        }
      };

      newBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (ws && ws.readyState === 1) {
          leaveRoom(true);
        } else {
          boot();
        }
      };
      copyBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (!copyBtn.disabled && link.value) {
          navigator.clipboard.writeText(link.value);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        }
      };
      toggleChatBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (!ws || ws.readyState !== 1) return;
        // Flip desired state based on button label
        const enable = toggleChatBtn.textContent.includes("Enable");
        ws.send(JSON.stringify({ type: "toggle_chat", disabled: !enable }));
      };

      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && chatInput.value.trim()) {
          sendChat(chatInput.value.trim());
          chatInput.value = "";
        }
      });

      // Death screen button event listeners
      if (restartRaidBtn) {
        restartRaidBtn.addEventListener("click", restartRaid);
      }
      
      if (exitToMenuBtn) {
        exitToMenuBtn.addEventListener("click", exitToMenu);
      }

    </script>
  </body>
</html>
