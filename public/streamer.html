<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arena Shooter √¢‚Ç¨‚Äù Streamer</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="game">
  <div class="topbar">
    <div class="brand">Arena Shooter</div>
    <div class="middle-controls">
      <span class="badge" id="status" data-state="disconnected">disconnected</span>
    </div>
    <div class="right-controls">
      <button id="fullscreen">Fullscreen</button>
      <button id="nerdToggle">Nerd Stats</button>
    </div>
  </div>

  <div class="app">
    <div class="main">
      <div class="stage"></div>
    </div>
    <aside class="sidebar">
      <div class="card">
        <div class="card-title">Session</div>
        <div class="row">
          <button id="newRoom">Create Room</button>
          <button id="toggleChat" disabled>Disable Chat</button>
        </div>
        <div class="row">
          <input id="roomLink" class="mono" placeholder="Join link" readonly />
          <button id="copy" disabled>Copy Link</button>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Weapons</div>
        <div class="row">
          <button class="weapon" data-weapon="pistol">Pistol (1)</button>
          <button class="weapon" data-weapon="smg">SMG (2)</button>
          <button class="weapon" data-weapon="shotgun">Shotgun (3)</button>
        </div>
        <div class="tip">Right-click or Q to swing bat.</div>
      </div>

      <div class="card">
        <div class="card-title">Stats</div>
        <div class="row">
          <span class="badge">Score: <span id="score">0</span></span>
          <span class="badge">Banked: <span id="banked">0</span></span>
          <span class="badge">HP: <span id="hp">100</span></span>
          <span class="badge">Weapon: <span id="weapon">pistol</span></span>
          <span class="badge">Ammo: <span id="ammo">0</span></span>
          <span class="badge" id="timer">Time: --</span>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Players</div>
        <div class="pill-list" id="players"></div>
      </div>

      <div class="card">
        <div class="card-title">Chat</div>
        <div id="chatMessages" class="chat-messages"></div>
        <div class="row"><input id="chatInput" placeholder="Chat..." /></div>
      </div>
    </aside>
  </div>
  <div class="hit-flash" id="flash"></div>

  <script type="module">
    import { connect, nameStorage, minimalCanvas, inputController, suppressPageHotkeys, toast, createLatencyMonitor } from '/common.js';

    const create = async () => {
      const res = await fetch('/create', { method:'POST' });
      const { roomId } = await res.json();
      return roomId;
    };

    const { c, ctx } = minimalCanvas(1440, 810);
    document.querySelector('.stage').appendChild(c);
    suppressPageHotkeys();
    const input = inputController();

    let ws, roomId, playerId, arena={w:960,h:540};
    let state = { players:[], bullets:[], arena, remainingTime: 0 };
    let lastHp = 100;
    let lastStateTime = performance.now();
    let lastScore = 0;
    const effects = []; // bullet impacts etc {x,y,ttl}
    let prevBulletPos = new Map();
    // Dash trails: per-player history of recent positions while dashing
    const trails = new Map(); // id -> Array<{x:number,y:number,t:number}>
    const TRAIL_TTL = 260; // ms
    const TRAIL_MAX = 22;
    // Local melee feedback (client-side prediction so streamer sees instantly)
    let localMeleeAt = 0; let localMeleeDirX = 1; let localMeleeDirY = 0; let prevMelee = false;

    const link = document.getElementById('roomLink');
    const status = document.getElementById('status');
    const scoreEl = document.getElementById('score');
    const bankedEl = document.getElementById('banked');
    const hpEl = document.getElementById('hp');
    const ammoEl = document.getElementById('ammo');
    const weaponEl = document.getElementById('weapon');
    const playersEl = document.getElementById('players');
    const flashEl = document.getElementById('flash');
    const newBtn = document.getElementById('newRoom');
    const copyBtn = document.getElementById('copy');
    const timerEl = document.getElementById('timer');
    const chatMessagesEl = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const toggleChatBtn = document.getElementById('toggleChat');
    const nerdToggleBtn = document.getElementById('nerdToggle');
    // Nerd panel overlay element
    const nerdPanel = document.createElement('div');
    nerdPanel.id = 'nerdPanel';
    nerdPanel.className = 'nerd-panel hidden mono';
    document.body.appendChild(nerdPanel);

    let nerdOn = localStorage.getItem('nerdStats') === '1';
    function setNerd(on){
      nerdOn = !!on;
      localStorage.setItem('nerdStats', nerdOn ? '1' : '0');
      nerdPanel.classList.toggle('hidden', !nerdOn);
      nerdToggleBtn.classList.toggle('active', nerdOn);
    }
    setNerd(nerdOn);
    nerdToggleBtn.onclick = () => setNerd(!nerdOn);
    copyBtn.disabled = true;
    // Camera: smooth, mouse-biased, no manual control
    let camX = 0, camY = 0; // top-left of viewport in world space
    const zoom = 2.4; // hotline-miami style: a bit more zoomed-in
    const mouseBias = 110; // world px to bias toward aim  
    const camLerpBase = 0.05; // smoothing factor per frame higher = faster

    let inputIv = null;
    let sendNeutralHandler = null;
    let visHandler = null;

    let pingIv = null; let latency = null; let stateMsgCount = 0; let statesPerSec = 0; let lastStateRateAt = performance.now();
    async function boot() {
      if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;
      roomId = await create();
      const url = `${location.origin}/join.html?room=${roomId}`;
      link.value = url;
      copyBtn.disabled = false;
      copyBtn.onclick = () => { navigator.clipboard.writeText(url); toast('Join link copied'); copyBtn.textContent = 'Copied!'; setTimeout(()=>copyBtn.textContent='Copy Link',800); };

      ws = connect(roomId);
      ws.addEventListener('open', () => {
        status.textContent = 'connected';
        status.dataset.state = 'connected';
        document.body.classList.add('connected');
        const name = nameStorage().get() || 'Marine';
        ws.send(JSON.stringify({ type:'join_room', role:'streamer', name }));
        newBtn.textContent = 'End Session';
        toggleChatBtn.disabled = false;
      });
      latency = createLatencyMonitor(ws);
      if (pingIv) { clearInterval(pingIv); pingIv = null; }
      pingIv = setInterval(() => { try { latency.sendPing(); } catch {} }, 1000);

      ws.addEventListener('message', (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'joined') { playerId = msg.playerId; arena = msg.arena; }
        if (msg.type === 'state') {
          stateMsgCount++;
          // detect removed bullets for small impact effect
          const curMap = new Map(msg.bullets.map(b=>[b.id,{x:b.x,y:b.y}]));
          for (const [id,pos] of prevBulletPos){
            if (!curMap.has(id)) effects.push({x:pos.x,y:pos.y,ttl:220});
          }
          prevBulletPos = curMap;

          state = msg;
          const me = msg.players.find(p=>p.id===playerId);
          if (me) {
            scoreEl.textContent = me.score;
            bankedEl.textContent = me.banked ?? 0;
            hpEl.textContent = (me.hp ?? 0);
            const w = me.weapon || 'pistol';
            weaponEl.textContent = w;
            let ammo = 0;
            if (w==='pistol') ammo = me.pistolAmmo ?? 0;
            else if (w==='smg') ammo = me.smgAmmo ?? 0;
            else if (w==='shotgun') ammo = me.shotgunAmmo ?? 0;
            else ammo = 0;
            ammoEl.textContent = ammo;
          }
          const ping = Math.max(0, Date.now() - (msg.t||Date.now()));
          status.textContent = `connected ‚Ä¢ ${ping} ms ‚Ä¢ players: ${msg.players.length}`;
          status.dataset.state = 'connected';
          state.remainingTime = msg.remainingTime;
          updateTimer(state.remainingTime);
          updatePlayerList(msg.players);
          // Update chat toggle button label from state
          if (typeof msg.chatEnabled === 'boolean') {
            toggleChatBtn.textContent = msg.chatEnabled ? 'Disable Chat' : 'Enable Chat';
            // Hide chat card and disable input when chat is disabled
            chatInput.disabled = !msg.chatEnabled;
            chatInput.placeholder = msg.chatEnabled ? 'Chat...' : 'Chat disabled by streamer';
            const chatCard = chatMessagesEl.closest('.card');
            if (chatCard) chatCard.classList.toggle('hidden', !msg.chatEnabled);
          }
          if (me && (me.hp ?? 0) < lastHp){ flash(); }
          lastScore = me?me.score:lastScore;
          lastHp = me?(me.hp ?? lastHp):lastHp;
          lastStateTime = performance.now();
        }
        if (msg.type === 'pong') {
          if (latency) latency.handlePong(Number(msg.timestamp)||0);
        }
        if (msg.type === 'chat') {
          appendChat(msg.from, msg.message);
        }
        if (msg.type === 'notice') {
          try { toast(msg.message); } catch {}
          appendChat('System', msg.message);
        }
      });
      inputIv = setInterval(() => {
        if (ws && ws.readyState===1) {
          // Convert screen aim to world coordinates via camera + zoom
          const aimWX = camX + (input.aimX / zoom);
          const aimWY = camY + (input.aimY / zoom);
          ws.send(JSON.stringify({ type:'input', up:input.up, down:input.down, left:input.left, right:input.right, shoot:input.shoot, melee:input.melee, dash:input.dash, aimX:aimWX, aimY:aimWY }));
        }
      }, 50);

      // If focus is lost, immediately send a neutral input (interval covers it, but faster feedback helps)
      sendNeutralHandler = () => {
        if (ws && ws.readyState===1) {
          const aimWX = camX + (input.aimX / zoom);
          const aimWY = camY + (input.aimY / zoom);
          ws.send(JSON.stringify({ type:'input', up:false, down:false, left:false, right:false, shoot:false, melee:false, dash:false, aimX:aimWX, aimY:aimWY }));
        }
      };
      visHandler = () => { if (document.hidden) sendNeutralHandler(); };
      window.addEventListener('blur', sendNeutralHandler);
      document.addEventListener('visibilitychange', visHandler);

      const onClose = () => { leaveRoom(false); };
      ws.addEventListener('close', onClose, { once: true });
    }

    function leaveRoom(manual=true){
      if (inputIv) { clearInterval(inputIv); inputIv = null; }
      if (pingIv) { clearInterval(pingIv); pingIv = null; }
      if (sendNeutralHandler) { window.removeEventListener('blur', sendNeutralHandler); sendNeutralHandler = null; }
      if (visHandler) { document.removeEventListener('visibilitychange', visHandler); visHandler = null; }
      if (ws) { try { if (manual && ws.readyState===1) ws.close(1000,'leave'); } catch {} ws = null; }
      status.textContent = 'disconnected';
      status.dataset.state = 'disconnected';
      document.body.classList.remove('connected');
      newBtn.textContent = 'Create Room';
      copyBtn.disabled = true; link.value = '';
      toggleChatBtn.disabled = true; toggleChatBtn.textContent = 'Disable Chat';
      playerId = null; prevBulletPos = new Map(); effects.length = 0; lastScore = 0; lastHp = 100;
      state = { players:[], bullets:[], arena };
      updatePlayerList([]);
    }

    // Smoothing map for positions (reduces 20Hz stutter)
    const smooth = new Map(); // id -> {x,y}
    const SMOOTH_TAU = 90; // ms time constant
    function getSmoothedPos(id, tx, ty, dt){
      let s = smooth.get(id);
      if (!s) { s = { x: tx, y: ty }; smooth.set(id, s); return { x: tx, y: ty }; }
      const alpha = 1 - Math.exp(-dt / Math.max(1, SMOOTH_TAU));
      s.x += (tx - s.x) * alpha;
      s.y += (ty - s.y) * alpha;
      return { x: s.x, y: s.y };
    }

    function draw(dt=16){
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
      const rect = c.getBoundingClientRect();
      // Reset and clear in device pixels
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0, c.width, c.height);
      // Base transform to CSS pixels
      ctx.setTransform(dpr,0,0,dpr,0,0);
      // Fill background with solid dark color in CSS px
      ctx.fillStyle = '#000000';
      ctx.fillRect(0,0, rect.width, rect.height);
      // Update camera target (follow player with slight mouse bias)
      const meRawForCam = state.players.find(p=>p.id===playerId);
      const meCam = meRawForCam ? getSmoothedPos(meRawForCam.id, meRawForCam.x, meRawForCam.y, dt) : null;
      if (meCam) {
        const aimWX = camX + (input.aimX / zoom);
        const aimWY = camY + (input.aimY / zoom);
        const dx = aimWX - meCam.x, dy = aimWY - meCam.y; const d = Math.hypot(dx,dy) || 1;
        const offX = (dx/d) * mouseBias, offY = (dy/d) * mouseBias;
        const viewW = rect.width / zoom, viewH = rect.height / zoom;
        const targetX = Math.min(Math.max(0, (meCam.x + offX) - viewW/2), Math.max(0, arena.w - viewW));
        const targetY = Math.min(Math.max(0, (meCam.y + offY) - viewH/2), Math.max(0, arena.h - viewH));
        const k = Math.min(1, (dt/16) * camLerpBase);
        camX = camX + (targetX - camX) * k;
        camY = camY + (targetY - camY) * k;
      }
      // Begin world transform
      ctx.save();
      ctx.scale(zoom, zoom);
      ctx.translate(-camX, -camY);
      // Walls/rooms
      if (state.walls){
        ctx.fillStyle = '#FFFFFF';
        for (const w of state.walls){ ctx.fillRect(w.x, w.y, w.w, w.h); }
      }
      // Extractions
      if (state.extractions) {
        for (const ex of state.extractions) {
          const nowMs = performance.now();
          const active = (ex.activeUntil||0) > Date.now();
          const pulse = active ? (0.6 + 0.4 * Math.abs(Math.sin(nowMs / 350))) : 0.25;
          const timeLeft = active ? Math.max(0, Math.ceil(((ex.activeUntil||0) - Date.now()) / 1000)) : 0;
          ctx.save();
          ctx.lineWidth = active ? 3 : 2;
          ctx.globalAlpha = pulse;
          ctx.strokeStyle = '#81c784';
          ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.r, 0, Math.PI*2); ctx.stroke();
          // subtle outer pulse ring when active
          if (active) {
            ctx.globalAlpha = Math.max(0, pulse * 0.35);
            ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.r + 6, 0, Math.PI*2); ctx.stroke();
          }
          // label and timer
          ctx.globalAlpha = active ? 0.95 : 0.35;
          ctx.fillStyle = '#c8e6c9';
          ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.textAlign = 'center';
          const label = active ? `EXTRACT ${timeLeft}s` : 'EXTRACT';
          ctx.fillText(label, ex.x, ex.y - ex.r - 6);
          ctx.restore();
        }
      }
      // Pickups
      if (state.pickups){
        for (const pk of state.pickups){
          ctx.save();
          ctx.shadowColor = 'rgba(255,255,255,.16)'; ctx.shadowBlur = 8;
          if (pk.type==='health'){
            ctx.strokeStyle = '#66bb6a'; ctx.lineWidth = 2; ctx.strokeRect(pk.x-8, pk.y-8, 16, 16);
            ctx.beginPath(); ctx.moveTo(pk.x-6, pk.y); ctx.lineTo(pk.x+6, pk.y); ctx.moveTo(pk.x, pk.y-6); ctx.lineTo(pk.x, pk.y+6); ctx.stroke();
          } else if (pk.type==='speed') {
            ctx.strokeStyle = '#64b5f6'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(pk.x-5, pk.y-8); ctx.lineTo(pk.x+2, pk.y-2); ctx.lineTo(pk.x-2, pk.y-2); ctx.lineTo(pk.x+5, pk.y+8); ctx.stroke();
          } else if (pk.type==='ammo') {
            ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2; ctx.strokeRect(pk.x-7, pk.y-5, 14, 10);
            ctx.beginPath(); ctx.moveTo(pk.x-4, pk.y+1); ctx.lineTo(pk.x-4, pk.y-1); ctx.moveTo(pk.x, pk.y+1); ctx.lineTo(pk.x, pk.y-1); ctx.moveTo(pk.x+4, pk.y+1); ctx.lineTo(pk.x+4, pk.y-1); ctx.stroke();
          } else if (pk.type==='weapon') {
            ctx.strokeStyle = '#ffa726'; ctx.beginPath(); ctx.moveTo(pk.x-6,pk.y); ctx.lineTo(pk.x,pk.y-8); ctx.lineTo(pk.x+2,pk.y-2); ctx.lineTo(pk.x+8,pk.y-2); ctx.lineTo(pk.x,pk.y+8); ctx.lineTo(pk.x+2,pk.y+2); ctx.lineTo(pk.x-6,pk.y); ctx.stroke();
          }
          
          else if (pk.type==='shield') {
            ctx.strokeStyle = '#26c6da'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(pk.x, pk.y, 9, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(pk.x, pk.y-6); ctx.lineTo(pk.x, pk.y+6); ctx.stroke();
          } else if (pk.type==='magnet') {
            ctx.strokeStyle = '#ab47bc'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pk.x-3, pk.y, 6, -Math.PI/2, Math.PI/2);
            ctx.arc(pk.x+3, pk.y, 6, Math.PI/2, -Math.PI/2);
            ctx.stroke();
          } else if (pk.type==='freeze') {
            ctx.strokeStyle = '#90caf9'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pk.x, pk.y-7); ctx.lineTo(pk.x, pk.y+7);
            ctx.moveTo(pk.x-7, pk.y); ctx.lineTo(pk.x+7, pk.y);
            ctx.moveTo(pk.x-5, pk.y-5); ctx.lineTo(pk.x+5, pk.y+5);
            ctx.moveTo(pk.x-5, pk.y+5); ctx.lineTo(pk.x+5, pk.y-5);
            ctx.stroke();
          } else if (pk.type==='blast') {
            ctx.strokeStyle = '#ff7043'; ctx.lineWidth = 2;
            for (let i=0;i<8;i++){ const a=i*Math.PI/4; ctx.beginPath(); ctx.moveTo(pk.x+Math.cos(a)*3, pk.y+Math.sin(a)*3); ctx.lineTo(pk.x+Math.cos(a)*10, pk.y+Math.sin(a)*10); ctx.stroke(); }
            ctx.beginPath(); ctx.arc(pk.x, pk.y, 3, 0, Math.PI*2); ctx.stroke();
          } else if (pk.type==='treasure') {
            ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2;
            ctx.strokeRect(pk.x-8, pk.y-6, 16, 12);
            ctx.beginPath(); ctx.moveTo(pk.x-8, pk.y-2); ctx.lineTo(pk.x+8, pk.y-2); ctx.stroke();
            ctx.beginPath(); ctx.arc(pk.x, pk.y+1, 2, 0, Math.PI*2); ctx.stroke();
          }
                    // label under pickup
          ctx.font = '10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.save(); ctx.globalAlpha = 0.18; ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(pk.x, pk.y, 3, 0, Math.PI*2); ctx.fill(); ctx.restore();
          ctx.fillStyle = '#cfd8dc'; ctx.globalAlpha = 0.95;
          const labelMap = { health:'HEALTH', speed:'SPEED', ammo:'AMMO', weapon:'WEAPON', shield:'SHIELD', magnet:'MAGNET', freeze:'FREEZE', blast:'BLAST', treasure:'TREASURE' };
          const lbl = labelMap[pk.type] || String(pk.type).toUpperCase();
          if (lbl) ctx.fillText(lbl, pk.x, pk.y + 14);
          ctx.restore();
        }
        ctx.lineWidth = 1;
      }
      // Bullets
      ctx.fillStyle = '#ffd54f';
      for (const b of state.bullets){
        ctx.save();
        ctx.shadowColor = 'rgba(255,213,79,.6)';
        ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
      // Bullet impact effects
      for (let i=effects.length-1;i>=0;i--){ 
        const e=effects[i]; 
        e.ttl-=dt; 
        if (e.ttl<=0){ 
          effects.splice(i,1); 
          continue; 
        }
        ctx.save(); 
        const a=Math.max(0, e.ttl/220); 
        ctx.globalAlpha = a; 
        ctx.strokeStyle = '#ffd54f'; 
        ctx.beginPath(); 
        ctx.arc(e.x,e.y,(1-a)*12+2,0,Math.PI*2); 
        ctx.stroke(); 
        ctx.restore(); 
      }
      // Players
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'center';
      let me = state.players.find(p=>p.id===playerId);
      // Detect local melee edge and record for immediate visuals
      if (me) {
        if (input.melee && !prevMelee) {
          const aimWX_forMelee = camX + (input.aimX / zoom);
          const aimWY_forMelee = camY + (input.aimY / zoom);
          const dx = aimWX_forMelee - me.x, dy = aimWY_forMelee - me.y; const d = Math.hypot(dx,dy)||1;
          localMeleeDirX = dx/d; localMeleeDirY = dy/d; localMeleeAt = performance.now();
        }
        prevMelee = input.melee;
      }
      // Update and draw dash trails (under players)
      const nowT = performance.now();
      if (state.players){
        for (const p of state.players){
          const sp = getSmoothedPos(p.id, p.x, p.y, 0); // position for trail sampling
          let arr = trails.get(p.id) || [];
          // Append when dashing
          if (p.dashing) {
            arr.push({ x: sp.x, y: sp.y, t: nowT });
            if (arr.length > TRAIL_MAX) arr.shift();
          }
          // Prune old
          arr = arr.filter(pt => nowT - pt.t <= TRAIL_TTL);
          trails.set(p.id, arr);
          // Draw trail
          if (arr.length >= 2) {
            for (let i = 0; i < arr.length; i++){
              const age = nowT - arr[i].t;
              const a = Math.max(0, 1 - (age / TRAIL_TTL));
              const r = 6 + 10 * a;
              ctx.save();
              // teal-ish trail with soft glow
              ctx.globalAlpha = 0.25 + 0.45 * a;
              ctx.fillStyle = 'rgba(158,241,209,1)';
              ctx.shadowColor = 'rgba(158,241,209,.8)';
              ctx.shadowBlur = 14 * a;
              ctx.beginPath(); ctx.arc(arr[i].x, arr[i].y, r, 0, Math.PI*2); ctx.fill();
              ctx.restore();
            }
          }
        }
      }

      for (const p of state.players){
        const sp = getSmoothedPos(p.id, p.x, p.y, dt);
        ctx.save();
        if (p.role==='streamer'){
          ctx.strokeStyle = '#4caf50';
          ctx.beginPath(); ctx.arc(sp.x,sp.y,10,0,Math.PI*2); ctx.stroke();
          if (p.weaponed){ ctx.strokeStyle='#ffa726'; ctx.globalAlpha=.6; ctx.beginPath(); ctx.arc(sp.x,sp.y,14,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
          ctx.fillStyle = '#4caf50'; ctx.globalAlpha = .95; ctx.fillText(p.name, sp.x, sp.y - 16);
        } else {
          ctx.fillStyle = p.alive? '#ef5350' : 'rgba(239,83,80,.25)';
          ctx.beginPath(); ctx.arc(sp.x,sp.y,12,0,Math.PI*2); ctx.fill();
          if (p.boosted){ ctx.strokeStyle = '#64b5f6'; ctx.globalAlpha=.7; ctx.beginPath(); ctx.arc(sp.x,sp.y,16,0,Math.PI*2); ctx.stroke(); }
          ctx.globalAlpha = .95; ctx.fillStyle = '#e57373'; ctx.fillText(p.name, sp.x, sp.y - 16);
          // Emote above zombie head for 5s
          if (p.emote && (p.emoteUntil||0) > Date.now()){
            ctx.font = '18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
            ctx.globalAlpha = 1;
            ctx.fillText(p.emote, sp.x, sp.y - 32);
            ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          }
        }
        // Bat swing arc visual (short-lived)
        const swingAge = (state.t||Date.now()) - (p.meleeAt||0);
        if (swingAge >= 0 && swingAge < 220) {
          const alpha = 1 - (swingAge / 220);
          const ang = Math.atan2(p.meleeDirY||0, p.meleeDirX||1);
          const span = Math.PI / 1.8; // ~100√Ç¬∞
          const r0 = 14, r1 = 34;
          ctx.save();
          ctx.globalAlpha = Math.max(0, alpha*0.9);
          ctx.fillStyle = 'rgba(255,213,79,0.35)';
          ctx.beginPath();
          ctx.moveTo(sp.x + Math.cos(ang - span/2)*r0, sp.y + Math.sin(ang - span/2)*r0);
          ctx.arc(sp.x, sp.y, r1, ang - span/2, ang + span/2);
          ctx.lineTo(sp.x + Math.cos(ang + span/2)*r0, sp.y + Math.sin(ang + span/2)*r0);
          ctx.arc(sp.x, sp.y, r0, ang + span/2, ang - span/2, true);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }

      // Crosshair for local player (world coordinates)
      me = state.players.find(p=>p.id===playerId);
      if (me){
        const aimWX = camX + (input.aimX / zoom);
        const aimWY = camY + (input.aimY / zoom);
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,.5)';
        ctx.beginPath(); ctx.arc(aimWX, aimWY, 6, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(aimWX-8,aimWY); ctx.lineTo(aimWX+8,aimWY); ctx.moveTo(aimWX,aimWY-8); ctx.lineTo(aimWX,aimWY+8); ctx.stroke();
        ctx.restore();

        // Local predicted bat swing arc so streamer sees swing instantly
        const age = performance.now() - localMeleeAt;
        if (age >= 0 && age < 220) {
          const alpha = 1 - (age / 220);
          const ang = Math.atan2(localMeleeDirY, localMeleeDirX);
          const span = Math.PI / 1.8; // ~100√Ç¬∞
          const r0 = 14, r1 = 34;
          ctx.save();
          ctx.globalAlpha = Math.max(0, alpha*0.9);
          ctx.fillStyle = 'rgba(255,213,79,0.35)';
          ctx.beginPath();
          ctx.moveTo(me.x + Math.cos(ang - span/2)*r0, me.y + Math.sin(ang - span/2)*r0);
          ctx.arc(me.x, me.y, r1, ang - span/2, ang + span/2);
          ctx.lineTo(me.x + Math.cos(ang + span/2)*r0, me.y + Math.sin(ang + span/2)*r0);
          ctx.arc(me.x, me.y, r0, ang + span/2, ang - span/2, true);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }

        // Also render server-synced swing for local player (fallback)
        const swingAgeSrv = (state.t||Date.now()) - (me.meleeAt||0);
        if (swingAgeSrv >= 0 && swingAgeSrv < 220) {
          const alpha = 1 - (swingAgeSrv / 220);
          const ang = Math.atan2(me.meleeDirY||0, me.meleeDirX||1);
          const span = Math.PI / 1.8; const r0 = 14, r1 = 34;
          ctx.save();
          ctx.globalAlpha = Math.max(0, alpha*0.9);
          ctx.fillStyle = 'rgba(255,213,79,0.35)';
          ctx.beginPath();
          ctx.moveTo(me.x + Math.cos(ang - span/2)*r0, me.y + Math.sin(ang - span/2)*r0);
          ctx.arc(me.x, me.y, r1, ang - span/2, ang + span/2);
          ctx.lineTo(me.x + Math.cos(ang + span/2)*r0, me.y + Math.sin(ang + span/2)*r0);
          ctx.arc(me.x, me.y, r0, ang + span/2, ang - span/2, true);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }

      // End world transform
      ctx.restore();

      // In-game HUD (top-right): Extract time, Score, Ammo
      const meHud = state.players.find(p=>p.id===playerId);
      const activeEx = (state.extractions||[]).find(ex => (ex.activeUntil||0) > Date.now());
      const extractLeft = activeEx ? Math.max(0, Math.ceil(((activeEx.activeUntil||0) - Date.now())/1000)) : 0;
      const weapon = meHud && (meHud.weapon||'pistol') || 'pistol';
      let ammo = 0; if (meHud){ if (weapon==='pistol') ammo=meHud.pistolAmmo||0; else if (weapon==='smg') ammo=meHud.smgAmmo||0; else if (weapon==='shotgun') ammo=meHud.shotgunAmmo||0; }
      const hudLines = [
        `Extract: ${activeEx?extractLeft+'s':'‚Äî'}`,
        `Score: ${meHud?meHud.score:0}  Banked: ${meHud?meHud.banked:0}`,
      ];
      const pad = 8; const lineH = 16; const boxW = 220; const boxH = pad*2 + hudLines.length*lineH;
      const x0 = rect.width - boxW - 12; const y0 = 12;
      ctx.save();
      ctx.globalAlpha = .95; ctx.fillStyle = 'rgba(18,20,24,.86)'; ctx.strokeStyle = 'rgba(255,255,255,.08)';
      ctx.lineWidth = 1.5; roundRect(ctx, x0, y0, boxW, boxH, 10, true, true);
      ctx.fillStyle = '#cfd8dc'; ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      for (let i=0;i<hudLines.length;i++){ ctx.fillText(hudLines[i], x0+10, y0+pad + (i+1)*lineH - 4); }
      ctx.restore();

      // Dash cooldown indicator (bottom-center) ‚Äî doubled size
      if (meHud) {
        const readyAt = meHud.dashReadyAt || 0;
        const lastAt = meHud.lastDashAt || 0;
        const nowMs = Date.now();
        const total = Math.max(1, readyAt - lastAt);
        const remain = Math.max(0, readyAt - nowMs);
        const frac = 1 - Math.min(1, remain / total);
        const meterPad = 24; // padding from bottom
        const r2 = 24; // doubled radius
        const cx2 = rect.width / 2;
        const cy2 = rect.height - meterPad - 52; // push up to fit bigger meter
        ctx.save();
        // backdrop behind the meter
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = 'rgba(18,20,24,.86)'; ctx.strokeStyle = 'rgba(255,255,255,.08)';
        ctx.lineWidth = 2; roundRect(ctx, cx2-52, cy2-52, 104, 110, 28, true, true);
        // background circle
        ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,.18)'; ctx.lineWidth = 6; ctx.arc(cx2, cy2, r2, 0, Math.PI*2); ctx.stroke();
        // progress arc
        ctx.beginPath(); ctx.strokeStyle = (remain<=0) ? '#2dd4bf' : '#90caf9'; ctx.lineWidth = 7; ctx.arc(cx2, cy2, r2, -Math.PI/2, -Math.PI/2 + Math.PI*2*frac); ctx.stroke();
        // label below meter
        ctx.fillStyle = '#cfd8dc'; ctx.font = '18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center'; ctx.fillText('Dash', cx2, cy2 + 48);
        ctx.restore();
      }

      // Weapon/Ammo (bottom-left) ‚Äî doubled size
      if (meHud) {
        const padBL = 12;
        const boxW2 = 340, boxH2 = 80;
        const xBL = padBL, yBL = rect.height - boxH2 - padBL;
        ctx.save();
        ctx.globalAlpha = .95; ctx.fillStyle = 'rgba(18,20,24,.86)'; ctx.strokeStyle = 'rgba(255,255,255,.08)';
        ctx.lineWidth = 2; roundRect(ctx, xBL, yBL, boxW2, boxH2, 24, true, true);
        ctx.fillStyle = '#cfd8dc'; ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.fillText(`Weapon: ${weapon}`, xBL + 20, yBL + 32);
        ctx.fillText(`Ammo: ${ammo}`, xBL + 20, yBL + 64);
        ctx.restore();
      }

      // Mini-map (bottom-right, circular)
      drawMiniMap();

      // Screen-space border overlay
      ctx.globalAlpha = 1; ctx.lineWidth = 2; ctx.strokeStyle = '#808080'; ctx.strokeRect(1,1,rect.width-2,rect.height-2);
    }

    // small util for rounded rects on HUD
    function roundRect(ctx,x,y,w,h,r,fill,stroke){
      if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
      ctx.beginPath();
      ctx.moveTo(x+r.tl, y);
      ctx.lineTo(x+w-r.tr, y);
      ctx.quadraticCurveTo(x+w, y, x+w, y+r.tr);
      ctx.lineTo(x+w, y+h-r.br);
      ctx.quadraticCurveTo(x+w, y+h, x+w-r.br, y+h);
      ctx.lineTo(x+r.bl, y+h);
      ctx.quadraticCurveTo(x, y+h, x, y+h-r.bl);
      ctx.lineTo(x, y+r.tl);
      ctx.quadraticCurveTo(x, y, x+r.tl, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function drawMiniMap(){
      const rect = c.getBoundingClientRect();
      const mmSize = 160; const pad = 12; const cx = rect.width - pad - mmSize/2; const cy = rect.height - pad - mmSize/2;
      const R = (mmSize/2) - 4;
      const W = (state.arena && state.arena.w) || 960; const H = (state.arena && state.arena.h) || 540;
      const scale = (2*R) / Math.max(W, H);
      // frame
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = 'rgba(18,20,24,.86)';
      ctx.beginPath(); ctx.arc(cx, cy, mmSize/2, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth = 2; ctx.stroke();
      // clip to circle
      ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.clip();
      // walls
      if (state.walls) {
        ctx.strokeStyle = 'rgba(255,255,255,.25)'; ctx.lineWidth = 1;
        for (const w of state.walls){
          const x = cx + (w.x - W/2) * scale; const y = cy + (w.y - H/2) * scale;
          const ww = w.w * scale; const hh = w.h * scale;
          ctx.strokeRect(x, y, ww, hh);
        }
      }
      // extractions
      if (state.extractions){
        for (const ex of state.extractions){
          const active = (ex.activeUntil||0) > Date.now();
          ctx.beginPath(); ctx.strokeStyle = active ? '#81c784' : 'rgba(129,199,132,.4)'; ctx.lineWidth = active ? 2 : 1;
          ctx.arc(cx + (ex.x - W/2)*scale, cy + (ex.y - H/2)*scale, Math.max(1, ex.r*scale), 0, Math.PI*2);
          ctx.stroke();
        }
      }
      // players
      if (state.players){
        for (const p of state.players){
          const px = cx + (p.x - W/2) * scale; const py = cy + (p.y - H/2) * scale;
          const r = p.role==='streamer' ? 3 : 2;
          ctx.beginPath();
          ctx.fillStyle = p.role==='streamer' ? '#4caf50' : (p.alive ? '#ef5350' : 'rgba(239,83,80,.4)');
          ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
          if (p.id === playerId) { ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1; ctx.stroke(); }
        }
      }
      ctx.restore(); // unclip
      ctx.restore();
    }

    function updatePlayerList(players){
      playersEl.innerHTML = players.map(p=>`<span class="pill ${p.role}">${p.role==='streamer'?'üü¢':'üßü'} ${p.name}${p.role==='streamer'?' ¬∑ '+p.score:''}</span>`).join(' ');
    }

    function flash(){
      flashEl.classList.add('show');
      setTimeout(()=>flashEl.classList.remove('show'),150);
    }

    function updateTimer(seconds) {
      const min = Math.floor(seconds / 60);
      const sec = seconds % 60;
      timerEl.textContent = `Time: ${min}:${sec.toString().padStart(2, '0')}`;
    }

    function appendChat(from, message) {
      chatMessagesEl.innerHTML += `<div>${from}: ${message}</div>`;
      while (chatMessagesEl.children.length > 10) {
        chatMessagesEl.removeChild(chatMessagesEl.firstChild);
      }
    }

    function sendChat(msg) {
      if (ws && ws.readyState===1) ws.send(JSON.stringify({ type:'chat', message: msg }));
    }

    // Animation loop for effects and smoother visuals
    let last = performance.now();
    const fpsSamples = [];
    const fpsWindow = 120; // ~2s at 60fps
    let lastNerdUpdate = 0;
    lastHp = 100;
    function loop(){
      const now = performance.now();
      const dt = now - last;
      last = now;
      draw(dt);
      // FPS tracking
      const fps = dt>0 ? 1000/dt : 0;
      fpsSamples.push(fps);
      if (fpsSamples.length > fpsWindow) fpsSamples.shift();
      // State messages per second
      if (now - lastStateRateAt >= 1000){ statesPerSec = stateMsgCount; stateMsgCount = 0; lastStateRateAt = now; }
      // Update nerd overlay at ~4Hz
      if (nerdOn && now - lastNerdUpdate > 250){
        const avgFps = fpsSamples.length ? (fpsSamples.reduce((a,b)=>a+b,0)/fpsSamples.length) : 0;
        const minFps = fpsSamples.length ? Math.min(...fpsSamples) : 0;
        const maxFps = fpsSamples.length ? Math.max(...fpsSamples) : 0;
        const lat = latency ? latency.getLatencyStats() : { avg:0, min:0, max:0, jitter:0 };
        const players = state.players?.length||0;
        const zombies = state.players?.filter(p=>p.role==='zombie').length||0;
        const bullets = state.bullets?.length||0;
        const pickups = state.pickups?.length||0;
        const walls = state.walls?.length||0;
        const wsBuf = ws && ws.bufferedAmount || 0;
        nerdPanel.innerHTML = `
          <div><strong>Nerd Stats</strong></div>
          <div>FPS: ${avgFps.toFixed(1)} (min ${minFps.toFixed(0)} max ${maxFps.toFixed(0)})</div>
          <div>Latency: ${lat.avg.toFixed(1)} ms (min ${lat.min.toFixed(0)} max ${lat.max.toFixed(0)}) jitter ${lat.jitter.toFixed(1)} ms</div>
          <div>States/s: ${statesPerSec.toFixed(0)}</div>
          <div>Entities: players ${players} (z ${zombies}) bullets ${bullets} pickups ${pickups} walls ${walls}</div>
          <div>WS buf: ${wsBuf}</div>
        `;
        lastNerdUpdate = now;
      }
      requestAnimationFrame(loop);
    }
    loop();

    // Weapon switching
    function sendSwitchWeapon(w) {
      if (ws && ws.readyState===1) ws.send(JSON.stringify({ type:'switch_weapon', weapon: w }));
    }
    document.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.key==='1') sendSwitchWeapon('pistol');
      if (e.key==='2') sendSwitchWeapon('smg');
      if (e.key==='3') sendSwitchWeapon('shotgun');
      // Optional: mid-round extract attempt on X
      if (e.key==='x' || e.key==='X') {
        // Only send if inside an active extraction ring
        try {
          const me = state.players.find(p=>p.id===playerId);
          if (!me || !state.extractions) return;
          const active = state.extractions.find(ex => (ex.activeUntil||0) > Date.now());
          if (!active) return;
          const d = Math.hypot(me.x - active.x, me.y - active.y);
          if (d <= active.r && ws && ws.readyState===1) {
            ws.send(JSON.stringify({ type:'attempt_extract' }));
          }
        } catch {}
      }
    });
    document.querySelectorAll('.weapon').forEach(btn => btn.addEventListener('click', (e) => {
      const w = e.currentTarget && e.currentTarget.getAttribute('data-weapon');
      if (w) sendSwitchWeapon(w);
    }));

    // Fullscreen toggle
    document.getElementById('fullscreen').onclick = async () => {
      if (!document.fullscreenElement) { await document.documentElement.requestFullscreen().catch(()=>{}); }
      else { await document.exitFullscreen().catch(()=>{}); }
    };

    newBtn.onclick = (ev) => { if (ev && ev.currentTarget && ev.currentTarget.blur) ev.currentTarget.blur(); if (ws && ws.readyState===1) { leaveRoom(true); } else { boot(); } };
    copyBtn.onclick = (ev) => { if (ev && ev.currentTarget && ev.currentTarget.blur) ev.currentTarget.blur(); if (!copyBtn.disabled && link.value) { navigator.clipboard.writeText(link.value); toast('Join link copied'); copyBtn.textContent = 'Copied!'; setTimeout(()=>copyBtn.textContent='Copy Link',800); } };
    toggleChatBtn.onclick = (ev) => {
      if (ev && ev.currentTarget && ev.currentTarget.blur) ev.currentTarget.blur();
      if (!ws || ws.readyState !== 1) return;
      // Flip desired state based on button label
      const enable = toggleChatBtn.textContent.includes('Enable');
      ws.send(JSON.stringify({ type:'toggle_chat', disabled: !enable }));
    };

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && chatInput.value.trim()) {
        sendChat(chatInput.value.trim());
        chatInput.value = '';
      }
    });
  </script>
</body>
</html>
