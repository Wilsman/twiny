<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Arena Shooter Streamer</title>
    <link rel="stylesheet" href="/styles.css" />
    <link rel="stylesheet" href="/sprites/weapons.css" />
    <style>
      /* Testing Mode Upgrade Panel */
      .upgrade-test-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px;
        margin: 4px 0;
        background: var(--panel-2);
        border: 1px solid var(--border);
        border-radius: 6px;
        font-size: 12px;
      }
      .upgrade-test-item.common { border-left: 3px solid #9e9e9e; }
      .upgrade-test-item.uncommon { border-left: 3px solid #4caf50; }
      .upgrade-test-item.rare { border-left: 3px solid #2196f3; }
      .upgrade-test-item.epic { border-left: 3px solid #9c27b0; }
      .upgrade-test-item.legendary { border-left: 3px solid #ff9800; }
      
      .upgrade-test-info {
        flex: 1;
        min-width: 0;
      }
      .upgrade-test-name {
        font-weight: 600;
        color: var(--text);
        margin-bottom: 2px;
      }
      .upgrade-test-desc {
        color: var(--muted);
        font-size: 11px;
        line-height: 1.3;
      }
      .upgrade-test-controls {
        display: flex;
        align-items: center;
        gap: 4px;
        margin-left: 8px;
      }
      .upgrade-test-count {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 11px;
        min-width: 20px;
        text-align: center;
        color: var(--text);
      }
      .upgrade-test-btn {
        width: 24px;
        height: 24px;
        border: 1px solid var(--border);
        background: var(--panel);
        color: var(--text);
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
      }
      .upgrade-test-btn:hover {
        background: var(--panel-2);
        border-color: var(--teal);
      }
      .upgrade-test-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body class="game">
    <div class="topbar">
      <div class="brand">Arena Shooter</div>
      <div class="middle-controls">
        <span class="badge" id="status" data-state="disconnected"
          >disconnected</span
        >
      </div>
      <div class="right-controls">
        <div class="audio-controls">
          <button id="musicMute" type="button">Mute</button>
          <input id="musicVolume" class="audio-slider" type="range" min="0" max="100" value="1" />
          <span id="musicVolumeValue" class="audio-value">1%</span>
        </div>
        <button id="fullscreen">Fullscreen</button>
        <button id="nerdToggle">Nerd Stats</button>
      </div>
    </div>

    <div class="app">
      <div class="main">
        <div class="stage">
          <div class="hud-layer">
            <div class="hud-stack hud-top-right">
              <div class="hud-pill hud-pill--right">
                <span>Score: <strong id="hudScore">0</strong></span>
                <span>Banked: <strong id="hudBanked">0</strong></span>
              </div>
            </div>
            <div class="hud-stack hud-middle-left">
              <div id="buffPanel" class="hud-panel hidden">
                <div class="hud-panel-title">Current Upgrades</div>
                <div class="hud-buff-list" id="buffList"></div>
              </div>
            </div>
            <div class="hud-stack hud-top-left">
              <div class="hud-pill">
                <span>Level: <strong id="hudLevel">0</strong></span>
                <span>XP: <strong id="hudXp">0/0</strong></span>
              </div>
            </div>
            <div class="hud-stack hud-bottom-left">
              <div class="health-bar-container">
                <div class="health-icon">‚ù§Ô∏è</div>
                <div class="health-bar">
                  <div class="health-segments" id="healthSegments"></div>
                  <div class="health-bar-bg"></div>
                </div>
              </div>
              <div class="hud-pill">
                <span>Weapon: <span class="weapon-sprite hud-weapon-icon" id="hudWeaponIcon"></span><strong id="hudWeapon">--</strong></span>
                <span>Ammo: <strong id="hudAmmo">0</strong></span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <aside class="sidebar">
        <div class="card">
          <div class="card-title">Session</div>
          <div class="row">
            <button id="newRoom">Create Room</button>
            <button id="testingMode" title="Enable testing mode with spawn overlaps">Testing Mode</button>
          </div>
          <div class="row">
            <input
              id="roomLink"
              class="mono"
              placeholder="Join link"
              readonly
            />
            <button id="copy" disabled>Copy Link</button>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Weapons</div>
          <div class="tip">
            Weapon drops glow bright gold in the arena. Stand on one and press F
            to swap your current gun. Bosses always drop something new and
            treasure chests have a chance to do the same. The bat is always
            there if you run dry.
          </div>
        </div>

        <div class="card">
          <div class="card-title">Stats</div>
          <div class="row">
            <span class="badge">Score: <span id="score">0</span></span>
            <span class="badge">Banked: <span id="banked">0</span></span>
            <span class="badge">HP: <span id="hp">100</span></span>
            <span class="badge">Weapon: <span id="weapon">pistol</span></span>
            <span class="badge">Ammo: <span id="ammo">0</span></span>
            <span class="badge" id="timer">Time: --</span>
          </div>
        </div>

        <div class="card">
          <div class="card-title">Players</div>
          <div class="pill-list" id="players"></div>
        </div>

        <!-- Testing Mode Upgrade Panel -->
        <div class="card" id="upgradeTestPanel" style="display: none;">
          <div class="card-title">üß™ Testing Upgrades</div>
          <div class="upgrade-test-controls">
            <div class="upgrade-search">
              <input type="text" id="upgradeSearch" placeholder="Search upgrades..." class="mono" style="width: 100%; margin-bottom: 8px;">
            </div>
            <div class="upgrade-list" id="upgradeTestList" style="max-height: 400px; overflow-y: auto;">
              <!-- Upgrades will be populated here -->
            </div>
          </div>
        </div>

      </aside>
    </div>
    <div class="hit-flash" id="flash"></div>
    <div class="swap-prompt" id="swapPrompt"></div>
    
    <!-- Upgrade overlay - centered on game area -->
    <div id="upgradeOverlay" class="upgrade-overlay hidden">
      <div class="upgrade-panel">
        <div class="upgrade-title mono">Level Up! Choose an upgrade</div>
        <div class="choices">
          <button class="choice" data-idx="0"></button>
          <button class="choice" data-idx="1"></button>
          <button class="choice" data-idx="2"></button>
        </div>
        <div class="tip mono">Press 1 / 2 / 3</div>
      </div>
    </div>
    
    <div class="countdown-overlay hidden" id="countdownOverlay">
      <div class="countdown-text" id="countdownText"></div>
    </div>
    
    <!-- Death Screen -->
    <div id="deathScreen" class="death-screen hidden">
      <div class="death-overlay"></div>
      <div class="death-content">
        <div class="death-header">
          <h1 class="death-title">üíÄ RAID ENDED üíÄ</h1>
          <div class="death-subtitle">Mission Statistics</div>
        </div>
        
        <div class="death-stats">
          <!-- First Row: Combat Stats & Enemy Breakdown Side-by-Side -->
          <div class="stats-row">
            <div class="stat-category">
              <h3>üéØ Combat Stats</h3>
              <div class="stat-item">
                <span class="stat-label">Enemies Killed:</span>
                <span class="stat-value" id="deathEnemiesKilled">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Bosses Defeated:</span>
                <span class="stat-value" id="deathBossesKilled">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Bullets Fired:</span>
                <span class="stat-value" id="deathBulletsFired">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Damage Dealt:</span>
                <span class="stat-value" id="deathDamageDealt">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Damage Taken:</span>
                <span class="stat-value" id="deathDamageTaken">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Accuracy:</span>
                <span class="stat-value" id="deathAccuracy">0%</span>
              </div>
            </div>
            
            <div class="stat-category">
              <h3>üßü Enemy Breakdown</h3>
              <div class="enemy-stats" id="deathEnemyBreakdown">
                <div class="enemy-type">
                  <span class="enemy-name">Basic Zombies:</span>
                  <span class="enemy-count" id="deathBasicZombies">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Runners:</span>
                  <span class="enemy-count" id="deathRunners">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Brutes:</span>
                  <span class="enemy-count" id="deathBrutes">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Spitters:</span>
                  <span class="enemy-count" id="deathSpitters">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Stalkers:</span>
                  <span class="enemy-count" id="deathStalkers">0</span>
                </div>
                <div class="enemy-type">
                  <span class="enemy-name">Bombers:</span>
                  <span class="enemy-count" id="deathBombers">0</span>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Second Row: Progression & Resources Side-by-Side -->
          <div class="stats-row">
            <div class="stat-category">
              <h3>üìä Progression</h3>
              <div class="stat-item">
                <span class="stat-label">Level Reached:</span>
                <span class="stat-value" id="deathLevel">1</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Total XP Gained:</span>
                <span class="stat-value" id="deathTotalXP">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Final Score:</span>
                <span class="stat-value" id="deathFinalScore">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Time Survived:</span>
                <span class="stat-value" id="deathTimeSurvived">0:00</span>
              </div>
            </div>
            
            <div class="stat-category">
              <h3>üí∞ Resources</h3>
              <div class="stat-item">
                <span class="stat-label">Coins Collected:</span>
                <span class="stat-value" id="deathCoinsCollected">0</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Pickups Taken:</span>
                <span class="stat-value" id="deathPickupsTaken">0</span>
              </div>
            </div>
          </div>
          
          <!-- Final Upgrades Section (Full Width) -->
          <div class="upgrades-section">
            <h3>‚ö° Final Upgrades</h3>
            <div class="final-upgrades" id="deathFinalUpgrades">
              <div class="no-upgrades">No upgrades acquired</div>
            </div>
          </div>
        </div>
        
        <div class="death-actions">
          <button id="restartRaid" class="death-btn death-btn-primary">üîÑ Restart Raid</button>
          <button id="exitToMenu" class="death-btn death-btn-secondary">üè† Exit to Menu</button>
        </div>
      </div>
    </div>

    <script type="module">
      import {
        connect,
        nameStorage,
        minimalCanvas,
        inputController,
        suppressPageHotkeys,
        toast,
        createLatencyMonitor,
        initUpgradeTesting,
      } from "/common.js";

      const urlParams = new URLSearchParams(location.search);
      const presetRoom = urlParams.get('room') || '';
      const create = async () => {
        if (presetRoom) return presetRoom;
        const res = await fetch("/create", { method: "POST" });
        const { roomId } = await res.json();
        return roomId;
      };

      const { c, ctx } = minimalCanvas(1440, 810);
      const stage = document.querySelector(".stage");
      stage.appendChild(c);
      
      // Move HUD layer to be positioned relative to canvas
      const hudLayer = document.querySelector(".hud-layer");
      if (hudLayer) {
        // Position HUD layer to match canvas dimensions and position
        const updateHudPosition = () => {
          const canvasRect = c.getBoundingClientRect();
          const stageRect = stage.getBoundingClientRect();
          
          hudLayer.style.left = (canvasRect.left - stageRect.left) + 'px';
          hudLayer.style.top = (canvasRect.top - stageRect.top) + 'px';
          hudLayer.style.width = canvasRect.width + 'px';
          hudLayer.style.height = canvasRect.height + 'px';
        };
        
        // Update position initially and on resize
        updateHudPosition();
        window.addEventListener('resize', updateHudPosition);
        
        // Handle fullscreen changes for HUD positioning with multiple attempts
        const handleHudFullscreenChange = () => {
          setTimeout(updateHudPosition, 50);
          setTimeout(updateHudPosition, 150);
          setTimeout(updateHudPosition, 300);
          setTimeout(updateHudPosition, 500);
        };
        
        document.addEventListener('fullscreenchange', handleHudFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleHudFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleHudFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleHudFullscreenChange);
        
        // Auto-start the game if we have a room ID in the URL
        document.addEventListener('DOMContentLoaded', () => {
          if (presetRoom) {
            boot();
          }
        });
        
        // Also update when canvas size changes
        const resizeObserver = new ResizeObserver(updateHudPosition);
        resizeObserver.observe(c);
      }
      suppressPageHotkeys();
      const input = inputController();

      let ws,
        roomId,
        playerId,
        arena = { w: 960, h: 540 };
      let state = { players: [], bullets: [], arena, remainingTime: 0, aiZombies: [] };
      let gameMap = null; // {w,h,size,theme,tiles:Uint8Array, props, lights}
      let lastHp = 100;
      let lastStateTime = performance.now();
      let lastScore = 0;
      const effects = []; // transient particles & bullet impacts
      // Screen shake accumulator (reduced each frame)
      let shake = 0;
      let muzzleFlashes = [];
      let prevShoot = false;
      let lastMuzzleAt = 0;
      let prevBullets = new Map();
      const bulletTrailHistory = new Map(); // bullet id -> [{x,y,t}]
      // Damage numbers for floating damage display
      let damageNumbers = [];
      // Dash trails: per-player history of recent positions while dashing
      const trails = new Map(); // id -> Array<{x:number,y:number,t:number}>
      const TRAIL_TTL = 260; // ms
      const TRAIL_MAX = 22;
      // Local melee feedback (client-side prediction so streamer sees instantly)
      let localMeleeAt = 0;
      let localMeleeDirX = 1;
      let localMeleeDirY = 0;
      let prevMelee = false;
      let swapPromptState = null;

      // Initialize upgrade testing
      let upgradeTestingAPI = null;

      // Function to update testing mode
      function updateTestingMode(gameMode) {
        console.log('updateTestingMode called with:', gameMode);
        console.log('upgradeTestingAPI exists:', !!upgradeTestingAPI);
        
        if (!upgradeTestingAPI) {
          console.log('Initializing upgrade testing API...');
          upgradeTestingAPI = initUpgradeTesting(ws, { gameMode });
          console.log('Upgrade testing API initialized:', !!upgradeTestingAPI);
        }
        if (upgradeTestingAPI) {
          console.log('Calling updateVisibility...');
          upgradeTestingAPI.updateVisibility();
        } else {
          console.warn('Failed to initialize upgrade testing API');
        }
      }

      // Call this when you detect testing mode
      // You can add this in the WebSocket message handler where game state is received

      const updateBulletTrail = (id, x, y, now) => {
        const existing = bulletTrailHistory.get(id) || [];
        const filtered = existing.filter((pt) => now - pt.t < 280);
        filtered.push({ x, y, t: now });
        if (filtered.length > 8) filtered.shift();
        bulletTrailHistory.set(id, filtered);
        return filtered;
      };

      const seededRand = (seed, step = 0) => {
        const x = Math.sin((seed + 1) * 12.9898 + step * 78.233) * 43758.5453;
        return x - Math.floor(x);
      };

      const resolveBulletWeapon = (bullet, playerLookup) => {
        const hint = bullet?.visual?.weapon;
        if (hint && hint !== 'bat') return hint;
        if (playerLookup?.has?.(bullet.ownerId)) {
          const weapon = playerLookup.get(bullet.ownerId)?.weapon;
          if (weapon && weapon !== 'bat') return weapon;
        } else if (state?.players) {
          const owner = state.players.find((p) => p.id === bullet.ownerId);
          if (owner?.weapon && owner.weapon !== 'bat') return owner.weapon;
        }
        if (hint === 'bat') return 'pistol';
        return hint || 'pistol';
      };

      const spawnBulletImpact = (bullet) => {
        if (!bullet) return;
        const trail = bulletTrailHistory.get(bullet.id);
        let angle = 0;
        if (trail && trail.length >= 2) {
          const last = trail[trail.length - 1];
          const prev = trail[trail.length - 2];
          angle = Math.atan2(last.y - prev.y, last.x - prev.x) || 0;
        }
        bulletTrailHistory.delete(bullet.id);
        const weapon = resolveBulletWeapon(bullet);
        const traits = bullet.visual?.traits ? [...bullet.visual.traits] : [];
        const normalized = weapon === 'bat' ? 'pistol' : weapon;
        const duration = normalized === 'railgun' ? 420 : normalized === 'shotgun' ? 300 : normalized === 'flamethrower' ? 260 : 220;
        const shakeStrength = normalized === 'railgun' ? 7 : normalized === 'shotgun' ? 4 : normalized === 'flamethrower' ? 3 : 2.2;
        const seed = [...(bullet.id || '')].reduce((acc, ch) => acc + ch.charCodeAt(0), 0) || Math.floor(Math.random() * 1000);
        effects.push({
          type: 'impact',
          weapon: normalized,
          traits,
          x: bullet.x,
          y: bullet.y,
          angle,
          ttl: duration,
          duration,
          seed,
        });
        shake += shakeStrength;
      };

      const drawBulletTraits = (ctx, x, y, traits, now) => {
        if (!traits || traits.length === 0) return;
        const traitSet = new Set(traits);
        const pulse = 0.5 + 0.5 * Math.sin(now * 0.01 + x * 0.05 + y * 0.05);
        ctx.save();
        if (traitSet.has('burn')) {
          ctx.globalAlpha = 0.4 + 0.25 * pulse;
          ctx.strokeStyle = 'rgba(255, 138, 101, 0.85)';
          ctx.lineWidth = 1.6;
          ctx.beginPath();
          ctx.arc(x, y, 6.5 + pulse * 2, 0, Math.PI * 2);
          ctx.stroke();
        }
        if (traitSet.has('slow')) {
          ctx.globalAlpha = 0.5;
          ctx.strokeStyle = 'rgba(129, 212, 250, 0.75)';
          ctx.lineWidth = 1.1;
          ctx.beginPath();
          ctx.arc(x, y, 8.5, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x, y - 5);
          ctx.lineTo(x, y + 5);
          ctx.moveTo(x - 4, y);
          ctx.lineTo(x + 4, y);
          ctx.stroke();
        }
        if (traitSet.has('bleed')) {
          ctx.globalAlpha = 0.65;
          ctx.fillStyle = 'rgba(244, 67, 54, 0.75)';
          ctx.beginPath();
          ctx.moveTo(x, y - 3);
          ctx.quadraticCurveTo(x - 3, y + 2, x, y + 6);
          ctx.quadraticCurveTo(x + 3, y + 2, x, y - 3);
          ctx.fill();
        }
        if (traitSet.has('chain')) {
          ctx.globalAlpha = 0.6;
          ctx.strokeStyle = 'rgba(167, 255, 235, 0.9)';
          ctx.lineWidth = 1;
          const spin = (now * 0.006) % (Math.PI * 2);
          ctx.beginPath();
          ctx.arc(x, y, 9.5, spin, spin + Math.PI / 3);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x, y, 9.5, spin + Math.PI, spin + Math.PI + Math.PI / 3);
          ctx.stroke();
        }
        if (traitSet.has('ricochet')) {
          ctx.globalAlpha = 0.6;
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y - 6);
          ctx.lineTo(x + 4, y);
          ctx.lineTo(x, y + 6);
          ctx.lineTo(x - 4, y);
          ctx.closePath();
          ctx.stroke();
        }
        if (traitSet.has('pierce')) {
          ctx.globalAlpha = 0.55;
          ctx.strokeStyle = 'rgba(255, 241, 118, 0.85)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x - 6, y);
          ctx.lineTo(x + 6, y);
          ctx.moveTo(x, y - 6);
          ctx.lineTo(x, y + 6);
          ctx.stroke();
        }
        ctx.restore();
      };

      const drawWeaponBullet = (ctx, bullet, weapon, traits, opts) => {
        const { angle, dist, empowered, now } = opts;
        const x = bullet.x;
        const y = bullet.y;
        switch (weapon) {
          case 'smg': {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            const tailLen = Math.min(34, Math.max(14, dist * 7 + 6));
            const grad = ctx.createLinearGradient(0, 0, -tailLen, 0);
            grad.addColorStop(0, 'rgba(128, 222, 234, 0.95)');
            grad.addColorStop(0.45, 'rgba(3, 169, 244, 0.7)');
            grad.addColorStop(1, 'rgba(3, 169, 244, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(2.5, -1.8);
            ctx.lineTo(-tailLen, -0.4);
            ctx.lineTo(-tailLen, 0.4);
            ctx.lineTo(2.5, 1.8);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(3, 169, 244, 0.85)';
            ctx.lineWidth = empowered ? 1.6 : 1.2;
            ctx.beginPath();
            ctx.moveTo(2.5, 0);
            ctx.lineTo(-tailLen, 0);
            ctx.stroke();
            ctx.restore();
            break;
          }
          case 'shotgun': {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            const burst = Math.max(9, dist * 4);
            for (let i = 0; i < 3; i++) {
              ctx.strokeStyle = 'rgba(255, 183, 77, 0.85)';
              ctx.lineWidth = 1.4 - i * 0.2;
              ctx.globalAlpha = 0.9 - i * 0.2;
              const offset = (i - 1) * 1.1;
              ctx.beginPath();
              ctx.moveTo(0, offset);
              ctx.lineTo(-burst * (1 - i * 0.25), offset);
              ctx.stroke();
            }
            ctx.globalAlpha = 0.95;
            ctx.shadowColor = 'rgba(255, 171, 64, 0.7)';
            ctx.shadowBlur = empowered ? 26 : 16;
            ctx.fillStyle = 'rgba(255, 138, 101, 0.9)';
            ctx.beginPath();
            ctx.arc(0, 0, empowered ? 4.4 : 3.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            break;
          }
          case 'railgun': {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            const tailLen = Math.min(150, Math.max(70, dist * 14 + 40));
            const grad = ctx.createLinearGradient(0, 0, -tailLen, 0);
            grad.addColorStop(0, 'rgba(187, 222, 251, 0.98)');
            grad.addColorStop(0.4, 'rgba(100, 181, 246, 0.7)');
            grad.addColorStop(1, 'rgba(30, 136, 229, 0)');
            ctx.strokeStyle = grad;
            ctx.lineWidth = empowered ? 5 : 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-tailLen, 0);
            ctx.stroke();
            ctx.shadowColor = 'rgba(225, 245, 254, 0.9)';
            ctx.shadowBlur = empowered ? 40 : 28;
            ctx.fillStyle = '#bbdefb';
            ctx.globalAlpha = 0.95;
            ctx.beginPath();
            ctx.arc(0, 0, empowered ? 6 : 5.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            break;
          }
          case 'flamethrower': {
            const tailLen = Math.min(32, Math.max(10, dist * 6));
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            const trailGrad = ctx.createLinearGradient(0, 0, -tailLen, 0);
            trailGrad.addColorStop(0, 'rgba(255, 183, 77, 0.8)');
            trailGrad.addColorStop(1, 'rgba(255, 111, 0, 0)');
            ctx.fillStyle = trailGrad;
            ctx.beginPath();
            ctx.moveTo(0, -2.4);
            ctx.lineTo(-tailLen, -0.8);
            ctx.lineTo(-tailLen, 0.8);
            ctx.lineTo(0, 2.4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            const pulse = 0.6 + 0.4 * Math.sin(now * 0.03 + x * 0.04 + y * 0.02);
            const radius = 5.2 + pulse * 2.6;
            const glow = ctx.createRadialGradient(x, y, 0, x, y, radius);
            glow.addColorStop(0, 'rgba(255, 249, 196, 0.95)');
            glow.addColorStop(0.4, 'rgba(255, 202, 40, 0.85)');
            glow.addColorStop(1, 'rgba(255, 87, 34, 0)');
            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 0.45;
            ctx.fillStyle = 'rgba(255, 183, 77, 0.55)';
            const driftX = Math.cos(now * 0.01 + x * 0.03) * 3.5;
            const driftY = Math.sin(now * 0.013 + y * 0.02) * 3.5;
            ctx.beginPath();
            ctx.arc(x - driftX, y - driftY, radius * 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            break;
          }
          default: {
            ctx.save();
            ctx.translate(x, y);
            if (dist > 0.2) {
              ctx.rotate(angle);
              const tailLen = Math.min(28, Math.max(10, dist * 6));
              const grad = ctx.createLinearGradient(0, 0, -tailLen, 0);
              grad.addColorStop(0, empowered ? 'rgba(255, 255, 224, 0.95)' : 'rgba(255, 236, 179, 0.95)');
              grad.addColorStop(1, 'rgba(255, 193, 7, 0)');
              ctx.fillStyle = grad;
              ctx.beginPath();
              ctx.moveTo(0, -2.2);
              ctx.lineTo(-tailLen, -0.5);
              ctx.lineTo(-tailLen, 0.5);
              ctx.lineTo(0, 2.2);
              ctx.closePath();
              ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowColor = empowered ? 'rgba(255, 255, 224, 0.9)' : 'rgba(255, 214, 123, 0.8)';
            ctx.shadowBlur = empowered ? 24 : 12;
            ctx.fillStyle = empowered ? '#fff8e1' : '#ffe082';
            ctx.beginPath();
            ctx.arc(0, 0, empowered ? 4.6 : 3.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            break;
          }
        }
        drawBulletTraits(ctx, x, y, traits, now);
      };

      const renderBullet = (ctx, bullet, now, playerLookup) => {
        const trail = updateBulletTrail(bullet.id, bullet.x, bullet.y, now);
        const len = trail.length;
        const prev = len >= 2 ? trail[len - 2] : null;
        const curr = trail[len - 1];
        const dx = prev ? curr.x - prev.x : 0;
        const dy = prev ? curr.y - prev.y : 0;
        const dist = Math.hypot(dx, dy);
        const angle = prev ? Math.atan2(dy, dx) : 0;
        const weapon = resolveBulletWeapon(bullet, playerLookup);
        const ownerEmpowered = playerLookup?.get?.(bullet.ownerId)?.weaponed;
        const empowered = Boolean(bullet.visual?.empowered || ownerEmpowered);
        drawWeaponBullet(ctx, bullet, weapon, bullet.visual?.traits || [], { angle, dist, empowered, now });
      };

      const link = document.getElementById("roomLink");
      const status = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const bankedEl = document.getElementById("banked");
      const hpEl = document.getElementById("hp");
      const ammoEl = document.getElementById("ammo");
      const weaponEl = document.getElementById("weapon");
      const playersEl = document.getElementById("players");
      const flashEl = document.getElementById("flash");
      const newBtn = document.getElementById("newRoom");
      const testingModeBtn = document.getElementById("testingMode");
      const copyBtn = document.getElementById("copy");
      const timerEl = document.getElementById("timer");
      const nerdToggleBtn = document.getElementById("nerdToggle");
      const swapPromptEl = document.getElementById("swapPrompt");
      const countdownOverlay = document.getElementById("countdownOverlay");
      const countdownText = document.getElementById("countdownText");
      const buffPanel = document.getElementById("buffPanel");
      const buffListEl = document.getElementById("buffList");
      const hudScoreEl = document.getElementById("hudScore");
      const upgradeQueue = [];
      const hudBankedEl = document.getElementById("hudBanked");
      const hudWeaponEl = document.getElementById("hudWeapon");
      const hudWeaponIconEl = document.getElementById("hudWeaponIcon");
      const hudAmmoEl = document.getElementById("hudAmmo");
      const hudHpEl = document.getElementById("hudHp");
      const hudLevelEl = document.getElementById("hudLevel");
      const hudXpEl = document.getElementById("hudXp");
      const healthSegmentsEl = document.getElementById("healthSegments");
      const deathScreenEl = document.getElementById("deathScreen");
      const restartRaidBtn = document.getElementById("restartRaid");
      const exitToMenuBtn = document.getElementById("exitToMenu");
      // Nerd panel overlay element
      const nerdPanel = document.createElement("div");
      nerdPanel.id = "nerdPanel";
      nerdPanel.className = "nerd-panel hidden mono";
      document.body.appendChild(nerdPanel);

      // Upgrade overlay elements
      const overlay = document.getElementById('upgradeOverlay');
      const choiceEls = Array.from(overlay.querySelectorAll('.choice'));
      let currentChoices = [];
      let currentHealthSegments = 0;
      let maxHealthSegments = 10;
      let isPlayerDead = false;
      let roundActive = false;
      let gameStartTime = Date.now();
      let lastPlayerPos = { x: 0, y: 0 };
      let countdownActive = false;
      let countdownHideTimeout = null;
      let lastCountdownDisplayed = null;
      let gamePaused = false;
      let serverUpgradePaused = false;

      const backgroundMusic = new Audio('/Digital Frenzy.mp3');
      backgroundMusic.loop = true;
      backgroundMusic.volume = 0.01;

      const musicMuteButton = document.getElementById("musicMute");
      const musicVolumeSlider = document.getElementById("musicVolume");
      const musicVolumeValue = document.getElementById("musicVolumeValue");
      const DEFAULT_MUSIC_VOLUME = 0.01;
      let lastSetMusicVolume = backgroundMusic.volume || DEFAULT_MUSIC_VOLUME;

      function updateMusicVolumeLabel(value) {
        if (musicVolumeValue) {
          musicVolumeValue.textContent = `${value}%`;
        }
      }

      function updateMusicMuteButton() {
        if (musicMuteButton) {
          musicMuteButton.textContent = backgroundMusic.muted ? "Unmute" : "Mute";
        }
      }

      if (musicVolumeSlider) {
        const initialValue = Math.round(backgroundMusic.volume * 100);
        musicVolumeSlider.value = String(initialValue);
        updateMusicVolumeLabel(initialValue);
        musicVolumeSlider.addEventListener("input", () => {
          const sliderValue = Number(musicVolumeSlider.value);
          const volume = sliderValue / 100;
          backgroundMusic.volume = volume;

          if (sliderValue === 0) {
            backgroundMusic.muted = true;
          } else {
            lastSetMusicVolume = volume;
            if (backgroundMusic.muted) {
              backgroundMusic.muted = false;
            }
          }

          updateMusicMuteButton();
          updateMusicVolumeLabel(sliderValue);
        });
      } else if (musicVolumeValue) {
        updateMusicVolumeLabel(Math.round(backgroundMusic.volume * 100));
      }

      if (musicMuteButton) {
        updateMusicMuteButton();
        musicMuteButton.addEventListener("click", () => {
          if (backgroundMusic.muted || backgroundMusic.volume === 0) {
            backgroundMusic.muted = false;
            const restored = lastSetMusicVolume > 0 ? lastSetMusicVolume : DEFAULT_MUSIC_VOLUME;
            backgroundMusic.volume = restored;
            if (musicVolumeSlider) {
              const sliderValue = Math.round(restored * 100);
              musicVolumeSlider.value = String(sliderValue);
              updateMusicVolumeLabel(sliderValue);
            }
          } else {
            backgroundMusic.muted = true;
            if (backgroundMusic.volume > 0) {
              lastSetMusicVolume = backgroundMusic.volume;
            }
            if (musicVolumeSlider) {
              musicVolumeSlider.value = "0";
              updateMusicVolumeLabel(0);
            }
          }

          updateMusicMuteButton();
        });
      }

      function playBackgroundMusic() {
        if (backgroundMusic.paused) {
          const playPromise = backgroundMusic.play();
          if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch(() => {});
          }
        }
      }

      function pauseBackgroundMusic() {
        if (!backgroundMusic.paused) {
          backgroundMusic.pause();
        }
      }

      // Initialize segmented health bar
      function initHealthBar(maxHp) {
        maxHealthSegments = Math.max(5, Math.min(20, Math.ceil(maxHp / 10))); // 5-20 segments
        healthSegmentsEl.innerHTML = '';
        currentHealthSegments = maxHealthSegments;
        
        for (let i = 0; i < maxHealthSegments; i++) {
          const segment = document.createElement('div');
          segment.className = 'health-segment';
          segment.dataset.index = i;
          healthSegmentsEl.appendChild(segment);
        }
      }

      // Update segmented health bar with smooth animations
      function updateHealthBar(currentHp, maxHp) {
        if (!healthSegmentsEl) return;
        
        const healthPercentage = Math.max(0, Math.min(1, currentHp / maxHp));
        const targetSegments = Math.ceil(healthPercentage * maxHealthSegments);
        const segments = healthSegmentsEl.querySelectorAll('.health-segment');
        
        // Determine health state colors
        const lowHealthThreshold = 0.3;
        const criticalHealthThreshold = 0.15;
        
        segments.forEach((segment, index) => {
          const shouldBeActive = index < targetSegments;
          const isCurrentlyActive = !segment.classList.contains('depleting') && 
                                   segment.style.transform !== 'scaleX(0)';
          
          // Remove previous state classes
          segment.classList.remove('depleting', 'filling', 'low-health', 'critical-health');
          
          if (shouldBeActive && !isCurrentlyActive) {
            // Segment should fill
            segment.classList.add('filling');
            segment.style.transform = 'scaleX(1)';
            segment.style.opacity = '1';
          } else if (!shouldBeActive && isCurrentlyActive) {
            // Segment should deplete
            segment.classList.add('depleting');
            setTimeout(() => {
              segment.style.transform = 'scaleX(0)';
              segment.style.opacity = '0';
            }, 50);
          }
          
          // Apply health state colors
          if (shouldBeActive) {
            if (healthPercentage <= criticalHealthThreshold) {
              segment.classList.add('critical-health');
            } else if (healthPercentage <= lowHealthThreshold) {
              segment.classList.add('low-health');
            }
          }
        });
        
        currentHealthSegments = targetSegments;
      }

      // Death screen functions
      function showDeathScreen(playerStats, reason = 'streamer_dead') {
        isPlayerDead = true;
        roundActive = false;
        pauseBackgroundMusic();

        // Calculate time survived
        const timeAlive = Date.now() - gameStartTime;
        const minutes = Math.floor(timeAlive / 60000);
        const seconds = Math.floor((timeAlive % 60000) / 1000);

        const subtitle = deathScreenEl.querySelector('.death-subtitle');
        if (subtitle) {
          if (reason === 'timeout') {
            subtitle.textContent = 'Raid Complete';
          } else {
            subtitle.textContent = 'Mission Statistics';
          }
        }

        restartRaidBtn.disabled = false;

        // Update death screen stats
        const stats = playerStats || {};
        document.getElementById('deathEnemiesKilled').textContent = stats.raidStats?.enemiesKilled || 0;
        document.getElementById('deathBossesKilled').textContent = stats.raidStats?.bossesKilled || 0;
        document.getElementById('deathBulletsFired').textContent = stats.raidStats?.bulletsFired || 0;

        const accuracy = stats.raidStats?.bulletsFired > 0
          ? Math.round((stats.raidStats.bulletsHit / stats.raidStats.bulletsFired) * 100)
          : 0;
        document.getElementById('deathAccuracy').textContent = accuracy + '%';

        document.getElementById('deathLevel').textContent = stats.level || 1;
        document.getElementById('deathTotalXP').textContent = stats.raidStats?.totalXPGained || 0;
        document.getElementById('deathFinalScore').textContent = stats.score || 0;
        document.getElementById('deathTimeSurvived').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        document.getElementById('deathCoinsCollected').textContent = stats.raidStats?.coinsCollected || 0;
        document.getElementById('deathPickupsTaken').textContent = stats.raidStats?.pickupsTaken || 0;
        document.getElementById('deathDamageDealt').textContent = stats.raidStats?.damageDealt || 0;
        document.getElementById('deathDamageTaken').textContent = stats.raidStats?.damageTaken || 0;

        // Enemy breakdown
        const breakdown = stats.raidStats?.enemyBreakdown || {};
        document.getElementById('deathBasicZombies').textContent = breakdown.basic || 0;
        document.getElementById('deathRunners').textContent = breakdown.runner || 0;
        document.getElementById('deathBrutes').textContent = breakdown.brute || 0;
        document.getElementById('deathSpitters').textContent = breakdown.spitter || 0;
        document.getElementById('deathStalkers').textContent = breakdown.stalker || 0;
        document.getElementById('deathBombers').textContent = breakdown.bomber || 0;

        // Bosses defeated
        const bossesDefeated = stats.raidStats?.bossesDefeated || [];
        if (bossesDefeated.length > 0) {
          console.log('Bosses defeated:', bossesDefeated.join(', '));
        }

        // Final upgrades
        const upgradesEl = document.getElementById('deathFinalUpgrades');
        if (stats.mods && stats.mods.length > 0) {
          upgradesEl.innerHTML = '';
          stats.mods.forEach(mod => {
            const upgradeEl = document.createElement('div');
            upgradeEl.className = 'upgrade-item';
            // Use the mod name if available, otherwise format the ID
            const displayName = mod.name || mod.id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            upgradeEl.textContent = `${displayName} x${mod.stacks}`;
            upgradesEl.appendChild(upgradeEl);
          });
        } else {
          upgradesEl.innerHTML = '<div class="no-upgrades">No upgrades acquired</div>';
        }
        
        // Show the death screen
        deathScreenEl.classList.remove('hidden');
      }

      function hideDeathScreen() {
        deathScreenEl.classList.add('hidden');
        isPlayerDead = false;
      }

      function restartRaid() {
        if (!ws || ws.readyState !== 1) return;
        restartRaidBtn.disabled = true;
        ws.send(JSON.stringify({ type: 'restart_round' }));
      }

      function exitToMenu() {
        hideDeathScreen();
        leaveRoom(true);
        window.location.href = '/index.html';
      }

      function handleRoundRestart() {
        roundActive = false;
        resumeGameplay();
        hideDeathScreen();
        gameStartTime = Date.now();
        lastPlayerPos = { x: 0, y: 0 };
        prevBullets = new Map();
        bulletTrailHistory.clear();
        effects.length = 0;
        muzzleFlashes.length = 0;
        damageNumbers = [];
        trails.clear();
        lastHp = 100;
        lastScore = 0;
        upgradeQueue.length = 0;
        currentChoices = [];
        overlay.classList.add('hidden');
        choiceEls.forEach((el) => { el.textContent = ''; el.disabled = true; });
        restartRaidBtn.disabled = false;
        hideCountdownOverlay();
        // Reset upgrade pause state
        gamePaused = false;
        serverUpgradePaused = false;
      }

      function updateWeaponIcon(weaponType) {
        if (!hudWeaponIconEl) return;
        
        // Remove all weapon classes
        hudWeaponIconEl.className = 'weapon-sprite hud-weapon-icon';
        
        // Add specific weapon class
        switch(weaponType) {
          case 'pistol':
            hudWeaponIconEl.classList.add('weapon-pistol');
            break;
          case 'smg':
            hudWeaponIconEl.classList.add('weapon-smg');
            break;
          case 'shotgun':
            hudWeaponIconEl.classList.add('weapon-shotgun');
            break;
          case 'railgun':
            hudWeaponIconEl.classList.add('weapon-railgun');
            break;
          case 'flamethrower':
            hudWeaponIconEl.classList.add('weapon-flamethrower');
            break;
          case 'melee':
            hudWeaponIconEl.classList.add('weapon-melee');
            break;
          default:
            // Hide icon for unknown weapons
            hudWeaponIconEl.style.display = 'none';
            return;
        }
        hudWeaponIconEl.style.display = 'inline-block';
      }


      function setServerUpgradePause(next) {
        if (serverUpgradePaused === next) return;
        serverUpgradePaused = next;
        if (!ws || ws.readyState !== 1) return;
        try {
          ws.send(JSON.stringify({ type: 'upgrade_pause', paused: next }));
        } catch {}
      }

      function pauseGameplay() {
        if (gamePaused) return;
        gamePaused = true;
        setServerUpgradePause(true);
        if (sendNeutralHandler) {
          try {
            sendNeutralHandler();
          } catch {}
        }
      }

      function resumeGameplay() {
        if (!gamePaused) {
          setServerUpgradePause(false);
          return;
        }
        gamePaused = false;
        setServerUpgradePause(false);
      }

      function showNextUpgrade() {
        if (!upgradeQueue.length) {
          currentChoices = [];
          choiceEls.forEach((el) => { el.textContent = ''; el.disabled = true; });
          overlay.classList.add('hidden');
          resumeGameplay();
          return;
        }
        currentChoices = upgradeQueue.shift();
        choiceEls.forEach((el, i) => {
          const choice = currentChoices[i];
          if (!choice) { el.textContent = ''; el.disabled = true; return; }
          el.disabled = false;
          el.textContent = `${i + 1}) ${choice.name} - ${choice.desc}`;
        });
        pauseGameplay();
        overlay.classList.remove('hidden');
      }

      function queueUpgrade(choices) {
        const normalized = Array.isArray(choices) ? choices.filter(Boolean) : [];
        if (!normalized.length) return;
        upgradeQueue.push(normalized);
        if (overlay.classList.contains('hidden') && currentChoices.length === 0) {
          showNextUpgrade();
        }
      }

      function pickUpgrade(index) {
        const choice = currentChoices[index];
        if (!choice || !ws) return;
        try { ws.send(JSON.stringify({ type: 'choose_upgrade', id: choice.id })); } catch {}
        resumeGameplay();
        showNextUpgrade();
      }

      choiceEls.forEach((el, i) => el.addEventListener('click', () => pickUpgrade(i)));
      window.addEventListener('keydown', (e) => {
        if (overlay.classList.contains('hidden')) return;
        if (e.key === '1') pickUpgrade(0);
        if (e.key === '2') pickUpgrade(1);
        if (e.key === '3') pickUpgrade(2);
      });

      function xpThreshold(level) {
        return 3 + Math.floor(level * 1.8);
      }

      function renderBuffs(mods) {
        if (!buffListEl) return;
        buffListEl.innerHTML = "";
        const data = Array.isArray(mods)
          ? mods.slice()
          : Object.entries(mods || {}).map(([id, stacks]) => ({ id, stacks }));
        if (!data.length) {
          if (buffPanel) buffPanel.classList.add('hidden');
          return;
        }
        data.sort((a, b) => (a.name || a.id || '').localeCompare(b.name || b.id || ''));
        if (buffPanel) buffPanel.classList.remove('hidden');
        for (const mod of data) {
          const row = document.createElement('div');
          row.className = 'hud-buff';
          row.dataset.rarity = (mod.rarity || 'common');
          if (mod.desc) row.title = mod.desc;
          const nameEl = document.createElement('span');
          nameEl.className = 'label';
          nameEl.textContent = mod.name || mod.id;
          const stackEl = document.createElement('span');
          stackEl.className = 'stacks';
          stackEl.textContent = `x${mod.stacks ?? 1}`;
          row.append(nameEl, stackEl);
          buffListEl.appendChild(row);
        }
      }
      renderBuffs([]);

      let nerdOn = localStorage.getItem("nerdStats") === "1";
      function setNerd(on) {
        nerdOn = !!on;
        localStorage.setItem("nerdStats", nerdOn ? "1" : "0");
        nerdPanel.classList.toggle("hidden", !nerdOn);
        nerdToggleBtn.classList.toggle("active", nerdOn);
      }
      setNerd(nerdOn);
      nerdToggleBtn.onclick = () => setNerd(!nerdOn);
      copyBtn.disabled = true;
      // Camera: smooth, mouse-biased, no manual control
      let camX = 0,
        camY = 0; // top-left of viewport in world space
      const zoom = 2.4; // hotline-miami style: a bit more zoomed-in
      const mouseBias = 110; // world px to bias toward aim
      const camLerpBase = 0.05; // smoothing factor per frame higher = faster

      let inputIv = null;
      let sendNeutralHandler = null;
      let visHandler = null;

      let pingIv = null;
      let latency = null;
      let stateMsgCount = 0;
      let statesPerSec = 0;
      let lastStateRateAt = performance.now();
      async function boot() {
        if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;
        
        // Reset death screen state
        gameStartTime = Date.now();
        isPlayerDead = false;
        hideDeathScreen();
        
        roomId = await create();
        const url = `${location.origin}/join.html?room=${roomId}`;
        link.value = url;
        copyBtn.disabled = false;
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(url);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        };

        ws = connect(roomId);
        ws.addEventListener("open", () => {
          status.textContent = "connected";
          status.dataset.state = "connected";
          document.body.classList.add("connected");
          roundActive = false;
          hideCountdownOverlay();
          gameStartTime = Date.now();
          restartRaidBtn.disabled = false;
          const name = nameStorage().get() || "Marine";
          ws.send(
            JSON.stringify({ type: "join_room", role: "streamer", name })
          );
          newBtn.textContent = "End Session";
        });
        latency = createLatencyMonitor(ws);
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        pingIv = setInterval(() => {
          try {
            latency.sendPing();
          } catch {}
        }, 1000);

        ws.addEventListener("message", (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === "map") {
            try {
              const m = msg.map;
              const bin = atob(m.tilesBase64);
              const u8 = new Uint8Array(bin.length);
              for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
              gameMap = {
                w: m.w,
                h: m.h,
                size: m.size,
                theme: m.theme,
                tiles: u8,
                props: m.props || [],
                lights: m.lights || [],
              };
            } catch {}
          }
          if (msg.type === "joined") {
            playerId = msg.playerId;
            arena = msg.arena;
          }
          if (msg.type === 'round_end') {
            roundActive = false;
            hideCountdownOverlay();
            const finalStats = msg.streamer || state.players.find((p) => p.id === playerId);
            showDeathScreen(finalStats, msg.reason || 'streamer_dead');
            status.textContent = 'connected  - raid ended';
            status.dataset.state = 'ended';
          }
          if (msg.type === 'round_restart') {
            handleRoundRestart();
            status.textContent = 'connected  - raid starting';
            status.dataset.state = 'starting';
          }
          if (msg.type === 'round_countdown') {
            updateCountdownOverlay(Number(msg.seconds) || 0);
          }
          
          // Update testing mode when game state changes
          if (msg.type === 'game_state' || msg.type === 'round_restart' || msg.type === 'state') {
            const gameMode = msg.gameMode || state.gameMode || 'normal';
            console.log('Detected game mode:', gameMode, 'from message type:', msg.type);
            updateTestingMode(gameMode);
          }
          if (msg.type === "state") {
            stateMsgCount++;
            const nextRoundActive = msg.roundActive !== false;
            if (!roundActive && nextRoundActive) {
              gameStartTime = Date.now();
              playBackgroundMusic();
              if (!countdownActive && lastCountdownDisplayed !== 0) {
                hideCountdownOverlay();
              }
            }
            if (roundActive && !nextRoundActive) {
              pauseBackgroundMusic();
            }
            if (typeof msg.countdownRemaining === 'number') {
              const remaining = Math.max(0, Math.floor(msg.countdownRemaining));
              if (remaining > 0) {
                updateCountdownOverlay(remaining);
              } else if (countdownActive || lastCountdownDisplayed !== null) {
                updateCountdownOverlay(0);
              }
            }
            roundActive = nextRoundActive;
            // detect removed bullets for small impact effect
            const curMap = new Map(msg.bullets.map((b) => [b.id, b]));
            for (const [id, prev] of prevBullets) {
              if (!curMap.has(id)) {
                spawnBulletImpact(prev);
              }
            }
            prevBullets = curMap;

            // Process damage numbers
            if (msg.damageNumbers) {
              // Create a set of existing IDs for faster lookup
              const existingIds = new Set(damageNumbers.map(dn => dn.id));
              
              for (const dn of msg.damageNumbers) {
                // Check if we already have this damage number
                if (!existingIds.has(dn.id)) {
                  // Find the target entity (player or AI zombie) to attach damage number to
                  let targetId = null;
                  let isAI = false;
                  
                  // Check if damage number is near any player
                  for (const player of msg.players) {
                    const dist = Math.hypot(player.x - dn.x, player.y - dn.y);
                    if (dist < 30) { // Within 30 pixels
                      targetId = player.id;
                      break;
                    }
                  }
                  
                  // If not found near players, check AI zombies
                  if (!targetId && msg.aiZombies) {
                    for (const zombie of msg.aiZombies) {
                      const dist = Math.hypot(zombie.x - dn.x, zombie.y - dn.y);
                      if (dist < 30) { // Within 30 pixels
                        targetId = zombie.id;
                        isAI = true;
                        break;
                      }
                    }
                  }
                  
                  damageNumbers.push({
                    id: dn.id,
                    x: dn.x,
                    y: dn.y,
                    damage: dn.damage,
                    isCrit: dn.isCrit,
                    isDot: dn.isDot,
                    timestamp: dn.timestamp,
                    startTime: Date.now(),
                    offsetY: 0,
                    targetId: targetId,
                    isAI: isAI,
                    initialX: dn.x,
                    initialY: dn.y
                  });
                  
                  // Add to existing IDs set to prevent duplicates within this message
                  existingIds.add(dn.id);
                }
              }
            }

            state = msg;
            const me = msg.players.find((p) => p.id === playerId);
            if (me) {
              const hpVal = me.hp ?? 0;
              const maxHp = me.maxHp ?? hpVal;
              const level = me.level ?? 0;
              const xpVal = me.xp ?? 0;
              const xpNeed = me.xpForNext ?? xpThreshold(level);
              scoreEl.textContent = me.score;
              bankedEl.textContent = me.banked ?? 0;
              
              // Check if HP has decreased
              const prevHpText = hpEl.textContent.split('/')[0];
              const prevHp = parseInt(prevHpText) || maxHp;
              const hpDecreased = hpVal < prevHp && prevHp <= maxHp; // Only trigger if HP actually decreased and not just respawned
              
              // Update HP display
              hpEl.innerHTML = `<span id="hp-value">${hpVal}</span>/<span id="hp-max">${maxHp}</span>`;
              
              // Add pulse effect if HP decreased
              if (hpDecreased) {
                const hpValueEl = document.getElementById('hp-value');
                if (hpValueEl) {
                  hpValueEl.classList.add('hp-damage-pulse');
                  setTimeout(() => {
                    if (hpValueEl) hpValueEl.classList.remove('hp-damage-pulse');
                  }, 400);
                }
              }
              const w = me.weapon || "pistol";
              weaponEl.textContent = w;
              const ammoByWeapon = {
                pistol: me.pistolAmmo ?? 0,
                smg: me.smgAmmo ?? 0,
                shotgun: me.shotgunAmmo ?? 0,
                railgun: me.railgunAmmo ?? 0,
                flamethrower: me.flamethrowerAmmo ?? 0,
                bat: Infinity
              };
              let ammo = ammoByWeapon[w] ?? 0;
              if (!Number.isFinite(ammo)) ammo = 0;
              
              // Check if ammo has decreased
              const prevAmmo = parseInt(ammoEl.textContent) || 0;
              const ammoDecreased = ammo < prevAmmo;
              
              ammoEl.textContent = ammo;
              
              // Add pulse class if ammo decreased
              if (ammoDecreased) {
                ammoEl.classList.add('ammo-pulse');
                // Remove the class after animation completes
                setTimeout(() => ammoEl.classList.remove('ammo-pulse'), 300);
              }
              
              if (hudScoreEl) hudScoreEl.textContent = String(me.score ?? 0);
              if (hudBankedEl) hudBankedEl.textContent = String(me.banked ?? 0);
              if (hudWeaponEl) hudWeaponEl.textContent = w;
              updateWeaponIcon(w);
              
              // Initialize health bar if not done yet
              if (healthSegmentsEl && healthSegmentsEl.children.length === 0) {
                initHealthBar(maxHp);
              }
              
              // Update segmented health bar
              updateHealthBar(hpVal, maxHp);
              
              // Update HUD ammo counter with the same pulse effect
              if (hudAmmoEl) {
                const prevHudAmmo = parseInt(hudAmmoEl.textContent) || 0;
                hudAmmoEl.textContent = String(ammo);
                if (ammo < prevHudAmmo) {
                  hudAmmoEl.classList.add('ammo-pulse');
                  setTimeout(() => hudAmmoEl.classList.remove('ammo-pulse'), 300);
                }
              }
              // Health bar is now handled by updateHealthBar function
              if (hudLevelEl) hudLevelEl.textContent = String(level);
              if (hudXpEl) hudXpEl.textContent = `${xpVal}/${xpNeed}`;
              renderBuffs(me.mods || []);
              // Ownership inference
              const hasSmg = (me.smgAmmo ?? 0) > 0 || w === "smg";
              const hasShotgun = (me.shotgunAmmo ?? 0) > 0 || w === "shotgun";
              const hasRailgun = (me.railgunAmmo ?? 0) > 0 || w === "railgun";
              const hasFlamethrower = (me.flamethrowerAmmo ?? 0) > 0 || w === "flamethrower";
              const banked = me.banked || 0;
              // Button states
} else {
              renderBuffs([]);
              if (hudScoreEl) hudScoreEl.textContent = '0';
              if (hudBankedEl) hudBankedEl.textContent = '0';
              if (hudWeaponEl) hudWeaponEl.textContent = '--';
        updateWeaponIcon('');
              if (hudAmmoEl) hudAmmoEl.textContent = '0';
              // Clear health bar segments
              if (healthSegmentsEl) healthSegmentsEl.innerHTML = '';
              if (hudLevelEl) hudLevelEl.textContent = '0';
              if (hudXpEl) hudXpEl.textContent = '0/0';
            }
            const ping = Math.max(0, Date.now() - (msg.t || Date.now()));
            if (roundActive) {
              status.textContent = `connected  - ${ping} ms  - players: ${msg.players.length}`;
              status.dataset.state = "connected";
            } else if (countdownActive || lastCountdownDisplayed !== null) {
              status.textContent = 'connected  - raid starting';
              status.dataset.state = "starting";
            } else {
              status.textContent = 'connected  - raid ended';
              status.dataset.state = "ended";
            }
            state.remainingTime = msg.remainingTime;
            updateTimer(state.remainingTime);
            updatePlayerList(msg.players);
            if (me && (me.hp ?? 0) < lastHp) {
              flash();
            }
            
            // Check for death - only trigger death screen, don't auto-hide on respawn
            if (!roundActive && me && me.role === 'streamer' && me.alive === false && !isPlayerDead) {
              showDeathScreen(me);
            }
            
            // Update last position
            if (me) {
              lastPlayerPos = { x: me.x, y: me.y };
            }
            
            lastScore = me ? me.score : lastScore;
            lastHp = me ? me.hp ?? lastHp : lastHp;
            lastStateTime = performance.now();
          }
          if (msg.type === "pong") {
            if (latency) latency.handlePong(Number(msg.timestamp) || 0);
          }
          if (msg.type === "notice") {
            try {
              toast(msg.message);
            } catch {}
            
            // Check for respawn notice (pit death)
          }
          if (msg.type === 'upgrade_offer') {
            queueUpgrade(msg.choices || []);
          }
        });
        inputIv = setInterval(() => {
          if (ws && ws.readyState === 1 && !isPlayerDead && roundActive && !gamePaused) {
            // Convert screen aim to world coordinates via camera + zoom
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: input.up,
                down: input.down,
                left: input.left,
                right: input.right,
                shoot: input.shoot,
                melee: input.melee,
                dash: input.dash,
                interact: input.interact,
                aimX: aimWX,
                aimY: aimWY,
              })
            );

            // Spawn a local muzzle flash near the player's muzzle for immediate feedback
            const meNow = state.players.find((p) => p.id === playerId);
            if (meNow) {
              const now = performance.now();
              const wantFlash =
                input.shoot && (!prevShoot || now - lastMuzzleAt > 110);
              if (wantFlash) {
                const dx = aimWX - meNow.x;
                const dy = aimWY - meNow.y;
                const d = Math.hypot(dx, dy) || 1;
                const muzzleOffset = 16; // distance from player center to muzzle
                const fx = meNow.x + (dx / d) * muzzleOffset;
                const fy = meNow.y + (dy / d) * muzzleOffset;
                muzzleFlashes.push({ x: fx, y: fy, ttl: 90 });
                lastMuzzleAt = now;
              }
              prevShoot = input.shoot;
            }
          }
        }, 50);

        // If focus is lost, immediately send a neutral input (interval covers it, but faster feedback helps)
        sendNeutralHandler = () => {
          if (ws && ws.readyState === 1 && !isPlayerDead && roundActive) {
            const aimWX = camX + input.aimX / zoom;
            const aimWY = camY + input.aimY / zoom;
            ws.send(
              JSON.stringify({
                type: "input",
                up: false,
                down: false,
                left: false,
                right: false,
                shoot: false,
                melee: false,
                dash: false,
                interact: false,
                aimX: aimWX,
                aimY: aimWY,
              })
            );
          }
        };
        visHandler = () => {
          if (document.hidden) sendNeutralHandler();
        };
        window.addEventListener("blur", sendNeutralHandler);
        document.addEventListener("visibilitychange", visHandler);

        const onClose = () => {
          leaveRoom(false);
        };
        ws.addEventListener("close", onClose, { once: true });
      }

      function leaveRoom(manual = true) {
        resumeGameplay();
        if (swapPromptEl) swapPromptEl.classList.remove('show');
        swapPromptState = null;
        hideCountdownOverlay();
        if (inputIv) {
          clearInterval(inputIv);
          inputIv = null;
        }
        if (pingIv) {
          clearInterval(pingIv);
          pingIv = null;
        }
        if (sendNeutralHandler) {
          window.removeEventListener("blur", sendNeutralHandler);
          sendNeutralHandler = null;
        }
        if (visHandler) {
          document.removeEventListener("visibilitychange", visHandler);
          visHandler = null;
        }
        if (ws) {
          try {
            if (manual && ws.readyState === 1) ws.close(1000, "leave");
          } catch {}
          ws = null;
        }
        status.textContent = "disconnected";
        status.dataset.state = "disconnected";
        document.body.classList.remove("connected");
        newBtn.textContent = "Create Room";
        copyBtn.disabled = true;
        link.value = "";
        playerId = null;
        prevBullets = new Map();
        bulletTrailHistory.clear();
        effects.length = 0;
        muzzleFlashes.length = 0;
        lastScore = 0;
        lastHp = 100;
        state = { players: [], bullets: [], arena };
        updatePlayerList([]);
        hideDeathScreen();
        roundActive = false;
        restartRaidBtn.disabled = false;
      }

      // Smoothing map for positions (reduces 20Hz stutter)
      const smooth = new Map(); // id -> {x,y}
      const SMOOTH_TAU = 90; // ms time constant
      function getSmoothedPos(id, tx, ty, dt) {
        let s = smooth.get(id);
        if (!s) {
          s = { x: tx, y: ty };
          smooth.set(id, s);
          return { x: tx, y: ty };
        }
        const alpha = 1 - Math.exp(-dt / Math.max(1, SMOOTH_TAU));
        s.x += (tx - s.x) * alpha;
        s.y += (ty - s.y) * alpha;
        return { x: s.x, y: s.y };
      }

      function draw(dt = 16) {
        if (gamePaused) {
          return;
        }
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const rect = c.getBoundingClientRect();
        const frameNow = performance.now();
        // Reset and clear in device pixels
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, c.width, c.height);
        // Base transform to CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // Fill background with dungeon-themed dark color in CSS px
        ctx.fillStyle = "#0a0c0f";
        ctx.fillRect(0, 0, rect.width, rect.height);
        // Update camera target (follow player with slight mouse bias)
        const meRawForCam = state.players.find((p) => p.id === playerId);
        const meHud = meRawForCam || null;
        swapPromptState = null;
        const meCam = meRawForCam
          ? getSmoothedPos(meRawForCam.id, meRawForCam.x, meRawForCam.y, dt)
          : null;
        if (meCam) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          const dx = aimWX - meCam.x,
            dy = aimWY - meCam.y;
          const d = Math.hypot(dx, dy) || 1;
          const offX = (dx / d) * mouseBias,
            offY = (dy / d) * mouseBias;
          const viewW = rect.width / zoom,
            viewH = rect.height / zoom;
          const targetX = Math.min(
            Math.max(0, meCam.x + offX - viewW / 2),
            Math.max(0, arena.w - viewW)
          );
          const targetY = Math.min(
            Math.max(0, meCam.y + offY - viewH / 2),
            Math.max(0, arena.h - viewH)
          );
          const k = Math.min(1, (dt / 16) * camLerpBase);
          camX = camX + (targetX - camX) * k;
          camY = camY + (targetY - camY) * k;
        }
        // Begin world transform
        ctx.save();
        ctx.scale(zoom, zoom);
        // Screen shake
        const sAmt = Math.max(0, shake);
        shake = Math.max(0, shake * 0.9 - 0.2);
        const sdx = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        const sdy = (Math.random() - 0.5) * 2 * (sAmt / zoom);
        ctx.translate(-camX + sdx, -camY + sdy);
        // Tile layer
        if (gameMap)
          drawTiles(camX, camY, rect.width / zoom, rect.height / zoom);
        // Walls/rooms
        if (state.walls) {
          ctx.fillStyle = "#2a2f36";
          for (const w of state.walls) {
            ctx.fillRect(w.x, w.y, w.w, w.h);
          }
        }
        if (state.weaponDrops) {
          for (const drop of state.weaponDrops) {
            const glow = ctx.createRadialGradient(drop.x, drop.y, 6, drop.x, drop.y, 34);
            glow.addColorStop(0, 'rgba(255, 235, 130, 0.95)');
            glow.addColorStop(1, 'rgba(253, 156, 43, 0)');
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(drop.x, drop.y, 34, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.save();
            ctx.fillStyle = '#ffecb3';
            ctx.font = '12px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(drop.weapon.toUpperCase(), drop.x, drop.y - 18);
            ctx.fillStyle = '#ffd180';
            ctx.font = '10px system-ui';
            ctx.fillText('Press F', drop.x, drop.y + 18);
            ctx.restore();

            if (meHud) {
              const dist = Math.hypot(meHud.x - drop.x, meHud.y - drop.y);
              if (dist < 28) {
                swapPromptState = { weapon: drop.weapon, ammo: drop.ammo };
              }
            }
          }
        }

        // Extractions removed
        // Pickups
        if (state.pickups) {
          for (const pk of state.pickups) {
            ctx.save();
            ctx.shadowColor = "rgba(255,255,255,.16)";
            ctx.shadowBlur = 8;
            if (pk.type === "health") {
              ctx.strokeStyle = "#66bb6a";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 8, 16, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x + 6, pk.y);
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "speed") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x - 5, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x - 2, pk.y - 2);
              ctx.lineTo(pk.x + 5, pk.y + 8);
              ctx.stroke();
            } else if (pk.type === "ammo") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 7, pk.y - 5, 14, 10);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y + 1);
              ctx.lineTo(pk.x - 4, pk.y - 1);
              ctx.moveTo(pk.x, pk.y + 1);
              ctx.lineTo(pk.x, pk.y - 1);
              ctx.moveTo(pk.x + 4, pk.y + 1);
              ctx.lineTo(pk.x + 4, pk.y - 1);
              ctx.stroke();
            } else if (pk.type === "weapon") {
              ctx.strokeStyle = "#ffa726";
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x - 6, pk.y);
              ctx.stroke();
            } else if (pk.type === "shield") {
              ctx.strokeStyle = "#26c6da";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 9, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 6);
              ctx.lineTo(pk.x, pk.y + 6);
              ctx.stroke();
            } else if (pk.type === "magnet") {
              ctx.strokeStyle = "#ab47bc";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x - 3, pk.y, 6, -Math.PI / 2, Math.PI / 2);
              ctx.arc(pk.x + 3, pk.y, 6, Math.PI / 2, -Math.PI / 2);
              ctx.stroke();
            } else if (pk.type === "freeze") {
              ctx.strokeStyle = "#90caf9";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x, pk.y + 7);
              ctx.moveTo(pk.x - 7, pk.y);
              ctx.lineTo(pk.x + 7, pk.y);
              ctx.moveTo(pk.x - 5, pk.y - 5);
              ctx.lineTo(pk.x + 5, pk.y + 5);
              ctx.moveTo(pk.x - 5, pk.y + 5);
              ctx.lineTo(pk.x + 5, pk.y - 5);
              ctx.stroke();
            } else if (pk.type === "blast") {
              ctx.strokeStyle = "#ff7043";
              ctx.lineWidth = 2;
              for (let i = 0; i < 8; i++) {
                const a = (i * Math.PI) / 4;
                ctx.beginPath();
                ctx.moveTo(pk.x + Math.cos(a) * 3, pk.y + Math.sin(a) * 3);
                ctx.lineTo(pk.x + Math.cos(a) * 10, pk.y + Math.sin(a) * 10);
                ctx.stroke();
              }
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 3, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "treasure") {
              ctx.strokeStyle = "#ffd54f";
              ctx.lineWidth = 2;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y - 2);
              ctx.lineTo(pk.x + 8, pk.y - 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x, pk.y + 1, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "coin") {
              ctx.strokeStyle = "#ffc107";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 6, 0, Math.PI * 2);
              ctx.stroke();
              ctx.fillStyle = "#ffc107";
              ctx.globalAlpha = 0.3;
              ctx.fill();
            } else if (pk.type === "gem") {
              ctx.strokeStyle = "#e91e63";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 7);
              ctx.lineTo(pk.x - 5, pk.y - 2);
              ctx.lineTo(pk.x - 3, pk.y + 7);
              ctx.lineTo(pk.x + 3, pk.y + 7);
              ctx.lineTo(pk.x + 5, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "crystal") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#9c27b0";
              ctx.shadowBlur = 6;
              ctx.beginPath();
              ctx.moveTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x - 4, pk.y - 2);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.lineTo(pk.x, pk.y + 8);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.lineTo(pk.x + 4, pk.y - 2);
              ctx.closePath();
              ctx.stroke();
            } else if (pk.type === "orb") {
              ctx.strokeStyle = "#2196f3";
              ctx.lineWidth = 2;
              ctx.shadowColor = "#2196f3";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 7, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(pk.x - 2, pk.y - 2, 2, 0, Math.PI * 2);
              ctx.stroke();
            } else if (pk.type === "relic") {
              ctx.strokeStyle = "#795548";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#795548";
              ctx.shadowBlur = 6;
              ctx.strokeRect(pk.x - 6, pk.y - 8, 12, 16);
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y - 4);
              ctx.moveTo(pk.x - 2, pk.y);
              ctx.lineTo(pk.x + 2, pk.y);
              ctx.stroke();
            } else if (pk.type === "artifact") {
              ctx.strokeStyle = "#607d8b";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#607d8b";
              ctx.shadowBlur = 8;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y - 2, 6, 0, Math.PI);
              ctx.stroke();
              ctx.strokeRect(pk.x - 4, pk.y - 2, 8, 8);
            } else if (pk.type === "medallion") {
              ctx.strokeStyle = "#ff9800";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#ff9800";
              ctx.shadowBlur = 10;
              ctx.beginPath();
              ctx.arc(pk.x, pk.y, 8, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(pk.x - 4, pk.y - 4);
              ctx.lineTo(pk.x + 4, pk.y + 4);
              ctx.moveTo(pk.x + 4, pk.y - 4);
              ctx.lineTo(pk.x - 4, pk.y + 4);
              ctx.stroke();
            } else if (pk.type === "scroll") {
              ctx.strokeStyle = "#8bc34a";
              ctx.lineWidth = 3;
              ctx.shadowColor = "#8bc34a";
              ctx.shadowBlur = 12;
              ctx.strokeRect(pk.x - 8, pk.y - 6, 16, 12);
              ctx.beginPath();
              ctx.moveTo(pk.x - 6, pk.y - 2);
              ctx.lineTo(pk.x + 6, pk.y - 2);
              ctx.moveTo(pk.x - 6, pk.y + 2);
              ctx.lineTo(pk.x + 6, pk.y + 2);
              ctx.stroke();
            } else if (pk.type === "crown") {
              ctx.strokeStyle = "#ffd700";
              ctx.lineWidth = 4;
              ctx.shadowColor = "#ffd700";
              ctx.shadowBlur = 15;
              ctx.beginPath();
              ctx.moveTo(pk.x - 8, pk.y + 4);
              ctx.lineTo(pk.x - 4, pk.y - 6);
              ctx.lineTo(pk.x - 2, pk.y + 2);
              ctx.lineTo(pk.x, pk.y - 8);
              ctx.lineTo(pk.x + 2, pk.y + 2);
              ctx.lineTo(pk.x + 4, pk.y - 6);
              ctx.lineTo(pk.x + 8, pk.y + 4);
              ctx.lineTo(pk.x - 8, pk.y + 4);
              ctx.stroke();
            }
            // label under pickup
            ctx.font =
              "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.fillStyle = "#cfd8dc";
            ctx.globalAlpha = 0.95;
            const labelMap = {
              health: "HEALTH",
              speed: "SPEED",
              ammo: "AMMO",
              weapon: "WEAPON",
              shield: "SHIELD",
              magnet: "MAGNET",
              freeze: "FREEZE",
              blast: "BLAST",
              treasure: "TREASURE",
              key: "KEY",
              coin: "COIN (10)",
              gem: "GEM (25)",
              crystal: "CRYSTAL (50)",
              orb: "ORB (75)",
              relic: "RELIC (100)",
              artifact: "ARTIFACT (150)",
              medallion: "MEDALLION (250)",
              scroll: "SCROLL (400)",
              crown: "CROWN (1000)",
            };
            const lbl = labelMap[pk.type] || String(pk.type).toUpperCase();
            if (lbl) ctx.fillText(lbl, pk.x, pk.y + 14);
            ctx.restore();
          }
          ctx.lineWidth = 1;
        }

        // Test Overlaps (testing mode only)
        if (state.testOverlaps && state.gameMode === 'testing') {
          for (const overlap of state.testOverlaps) {
            ctx.save();
            
            // Draw overlap circle
            ctx.strokeStyle = overlap.color;
            ctx.fillStyle = overlap.color + '20'; // Add transparency
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(overlap.x, overlap.y, overlap.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw cooldown indicator if on cooldown
            if (overlap.cooldownRemaining > 0) {
              const progress = 1 - (overlap.cooldownRemaining / 1000); // Assuming cooldown in ms
              ctx.strokeStyle = '#ff5722';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.arc(overlap.x, overlap.y, overlap.radius + 5, -Math.PI/2, -Math.PI/2 + (progress * Math.PI * 2));
              ctx.stroke();
            }
            
            // Draw label
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.font = '12px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeText(overlap.label, overlap.x, overlap.y);
            ctx.fillText(overlap.label, overlap.x, overlap.y);
            
            ctx.restore();
          }
        }
        // Bullets
        if (state.bullets && state.bullets.length) {
          const bulletNow = frameNow;
          const playerLookup = new Map(state.players.map((p) => [p.id, p]));
          for (const b of state.bullets) {
            renderBullet(ctx, b, bulletNow, playerLookup);
          }
        }
        // Spitter globs (enemy projectiles)
        if (state.globs) {
          ctx.fillStyle = "#ce93d8";
          for (const g of state.globs) {
            ctx.save();
            ctx.shadowColor = "rgba(206,147,216,.6)";
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(g.x, g.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }
        // Bullet impact effects
        const effectNow = frameNow;
        for (let i = effects.length - 1; i >= 0; i--) {
          const e = effects[i];
          e.ttl -= dt;
          if (e.ttl <= 0) {
            effects.splice(i, 1);
            continue;
          }
          const total = e.duration || 220;
          const life = Math.max(0, Math.min(1, e.ttl / total));
          const progress = 1 - life;
          ctx.save();
          if (e.type === 'impact') {
            switch (e.weapon) {
              case 'railgun': {
                const angle = e.angle || 0;
                const len = 170 + 120 * progress;
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.45 * life + 0.2;
                ctx.strokeStyle = 'rgba(144, 202, 249, 0.95)';
                ctx.lineWidth = 4 + 4 * life;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(e.x - Math.cos(angle) * len, e.y - Math.sin(angle) * len);
                ctx.lineTo(e.x + Math.cos(angle) * 18, e.y + Math.sin(angle) * 18);
                ctx.stroke();
                ctx.globalAlpha = 0.25 * life;
                ctx.fillStyle = 'rgba(187, 222, 251, 0.35)';
                ctx.beginPath();
                ctx.arc(e.x, e.y, 18 + 42 * progress, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 0.5 * life;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.75)';
                ctx.lineWidth = 1.4;
                ctx.beginPath();
                ctx.arc(e.x, e.y, 26 + 48 * progress, 0, Math.PI * 2);
                ctx.stroke();
                break;
              }
              case 'shotgun': {
                const sparks = 5;
                for (let s = 0; s < sparks; s++) {
                  const ang = seededRand(e.seed || 1, s) * Math.PI * 2;
                  const length = 12 + seededRand(e.seed || 1, s + 5) * 28;
                  ctx.globalAlpha = (0.75 - s * 0.12) * life;
                  ctx.strokeStyle = 'rgba(255, 183, 77, 0.9)';
                  ctx.lineWidth = 1.3 - s * 0.15;
                  ctx.beginPath();
                  ctx.moveTo(e.x, e.y);
                  ctx.lineTo(
                    e.x + Math.cos(ang) * length * life,
                    e.y + Math.sin(ang) * length * life
                  );
                  ctx.stroke();
                }
                ctx.globalAlpha = 0.4 * life;
                ctx.fillStyle = 'rgba(255, 138, 101, 0.6)';
                ctx.beginPath();
                ctx.arc(e.x, e.y, 5 + 10 * progress, 0, Math.PI * 2);
                ctx.fill();
                break;
              }
              case 'smg': {
                const angle = e.angle || 0;
                const len = 28 + 36 * progress;
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.55 * life;
                ctx.strokeStyle = 'rgba(3, 169, 244, 0.8)';
                ctx.lineWidth = 1.2 + 1.5 * life;
                ctx.beginPath();
                ctx.moveTo(e.x - Math.cos(angle) * len, e.y - Math.sin(angle) * len);
                ctx.lineTo(e.x + Math.cos(angle) * 8, e.y + Math.sin(angle) * 8);
                ctx.stroke();
                ctx.globalAlpha = 0.35 * life;
                ctx.beginPath();
                ctx.moveTo(e.x - Math.cos(angle + Math.PI / 2) * 6, e.y - Math.sin(angle + Math.PI / 2) * 6);
                ctx.lineTo(e.x + Math.cos(angle + Math.PI / 2) * 6, e.y + Math.sin(angle + Math.PI / 2) * 6);
                ctx.stroke();
                break;
              }
              case 'flamethrower': {
                const angle = e.angle || 0;
                const radius = 9 + 18 * progress;
                ctx.globalAlpha = 0.55 * life;
                ctx.fillStyle = 'rgba(255, 138, 101, 0.65)';
                ctx.beginPath();
                ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 0.4 * life;
                ctx.fillStyle = 'rgba(255, 202, 40, 0.45)';
                ctx.beginPath();
                ctx.arc(
                  e.x - Math.cos(angle) * (6 + 14 * progress),
                  e.y - Math.sin(angle) * (6 + 14 * progress),
                  radius * 0.6,
                  0,
                  Math.PI * 2
                );
                ctx.fill();
                break;
              }
              default: {
                const radius = 5 + 12 * progress;
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.5 * life + 0.2;
                ctx.fillStyle = 'rgba(255, 214, 126, 0.6)';
                ctx.beginPath();
                ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 0.35 * life;
                ctx.strokeStyle = 'rgba(255, 241, 148, 0.8)';
                ctx.lineWidth = 1.5 + 2.5 * life;
                ctx.beginPath();
                ctx.arc(e.x, e.y, radius + 4, 0, Math.PI * 2);
                ctx.stroke();
                break;
              }
            }
            if (e.traits && e.traits.length) {
              drawBulletTraits(ctx, e.x, e.y, e.traits, effectNow);
            }
          } else {
            ctx.globalAlpha = life;
            ctx.fillStyle = 'rgba(255, 107, 53, 0.7)';
            ctx.beginPath();
            ctx.arc(e.x, e.y, 4 + 10 * progress, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        // Damage numbers - clean up old ones first
        const now = Date.now();
        
        // Remove damage numbers older than server timestamp or animation time
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
          const dn = damageNumbers[i];
          const age = now - dn.startTime;
          const maxAge = 1500; // 1.5 seconds
          const serverAge = now - dn.timestamp;
          
          // Remove if animation is done OR if server timestamp is too old
          if (age > maxAge || serverAge > 2000) {
            damageNumbers.splice(i, 1);
            continue;
          }
        }
        
        // Render remaining damage numbers
        for (let i = damageNumbers.length - 1; i >= 0; i--) {
          const dn = damageNumbers[i];
          const age = now - dn.startTime;
          const maxAge = 1500; // 1.5 seconds
          
          // Update position to follow target entity
          let renderX = dn.initialX;
          let renderY = dn.initialY;
          
          if (dn.targetId) {
            if (dn.isAI) {
              // Follow AI zombie
              const zombie = state.aiZombies?.find(z => z.id === dn.targetId);
              if (zombie) {
                renderX = zombie.x;
                renderY = zombie.y - 15; // Slightly above the zombie
              }
            } else {
              // Follow player
              const player = state.players.find(p => p.id === dn.targetId);
              if (player) {
                renderX = player.x;
                renderY = player.y - 15; // Slightly above the player
              }
            }
          }
          
          // Animation: float up and fade out
          const progress = age / maxAge;
          const alpha = Math.max(0, 1 - progress * progress); // Quadratic fade
          const offsetY = -progress * 60; // Float up 60 pixels
          
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Different styles for different damage types
          if (dn.isCrit) {
            ctx.font = 'bold 18px monospace';
            ctx.fillStyle = '#ff4444';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeText(dn.damage.toString(), renderX, renderY + offsetY);
            ctx.fillText(dn.damage.toString(), renderX, renderY + offsetY);
          } else if (dn.isDot) {
            ctx.font = '12px monospace';
            ctx.fillStyle = '#88ff44';
            ctx.fillText(dn.damage.toString(), renderX, renderY + offsetY);
          } else {
            ctx.font = '14px monospace';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(dn.damage.toString(), renderX, renderY + offsetY);
          }
          
          ctx.restore();
        }
        // AI Zombies
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            ctx.save();
            
            // Main zombie body
            ctx.fillStyle = "#ef5350";
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Class outline
            if (zombie.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (zombie.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (zombie.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else if (zombie.zClass === "stalker") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
            } else if (zombie.zClass === "bomber") {
              ctx.strokeStyle = "#f44336";
              ctx.lineWidth = 2.5;
            } else {
              ctx.strokeStyle = "#666";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(zombie.x, zombie.y, zombie.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            
            // State indicator
            if (zombie.state === "chasing") {
              ctx.strokeStyle = "#ff5722";
              ctx.lineWidth = 2;
              ctx.globalAlpha = 0.8;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 18, 0, Math.PI * 2);
              ctx.stroke();
            } else if (zombie.state === "attacking") {
              ctx.strokeStyle = "#d32f2f";
              ctx.lineWidth = 3;
              ctx.globalAlpha = 1;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, 20, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Detection range indicator (when idle or chasing)
            if (zombie.state !== "attacking") {
              ctx.strokeStyle = "rgba(255, 87, 34, 0.15)";
              ctx.lineWidth = 1;
              ctx.globalAlpha = 0.3;
              ctx.beginPath();
              ctx.arc(zombie.x, zombie.y, zombie.detectionRange, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // HP bar
            const barWidth = 24;
            const barHeight = 4;
            const barX = zombie.x - barWidth / 2;
            const barY = zombie.y - 20;
            const hpRatio = zombie.hp / zombie.maxHp;
            
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = hpRatio > 0.6 ? "#4caf50" : hpRatio > 0.3 ? "#ff9800" : "#f44336";
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
            
            // Name/class label
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.font = "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(`AI ${zombie.zClass}`, zombie.x, zombie.y + 25);
            
            ctx.restore();
          }
        }

        // Bosses
        if (state.bosses) {
          for (const boss of state.bosses) {
            const visual = boss.visual || {};
            ctx.save();

            if (boss.type === "shadowLord") {
              const range = boss.lifeDrainRange || 0;
              if (range > 0) {
                ctx.save();
                ctx.globalAlpha = 0.18;
                ctx.fillStyle = "rgba(129, 212, 250, 0.18)";
                ctx.beginPath();
                ctx.arc(boss.pos.x, boss.pos.y, range, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 0.9;
                ctx.strokeStyle = "rgba(129, 212, 250, 0.85)";
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 6]);
                ctx.stroke();
                ctx.restore();
              }
            }

            // Boss glow effect
            ctx.shadowColor = visual.glowColor || "#ff0000";
            ctx.shadowBlur = 20;
            
            // Main boss body - larger circle with unique colors
            ctx.fillStyle = visual.color || "#8B0000";
            ctx.strokeStyle = visual.secondaryColor || "#FF4500";
            ctx.lineWidth = 4;
            
            // Phase effect for Shadow Lord
            if (boss.phased) {
              ctx.globalAlpha = 0.3;
              ctx.setLineDash([5, 5]);
            }
            
            ctx.beginPath();
            ctx.arc(boss.pos.x, boss.pos.y, boss.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
            
            // Boss symbol in center
            ctx.fillStyle = "#ffffff";
            ctx.font = "20px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(visual.symbol || "üëπ", boss.pos.x, boss.pos.y);
            
            // HP bar above boss
            const barWidth = boss.radius * 2.5;
            const barHeight = 6;
            const barX = boss.pos.x - barWidth / 2;
            const barY = boss.pos.y - boss.radius - 15;
            const hpRatio = boss.hp / boss.maxHp;
            
            // HP bar background
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // HP bar fill with color based on health
            ctx.fillStyle = hpRatio > 0.6 ? "#4caf50" : hpRatio > 0.3 ? "#ff9800" : "#f44336";
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
            
            // Enrage effect for Brute King
            if (boss.enraged) {
              ctx.strokeStyle = "#ff4444";
              ctx.lineWidth = 3;
              ctx.globalAlpha = 0.8;
              ctx.beginPath();
              ctx.arc(boss.pos.x, boss.pos.y, boss.radius + 8, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Boss name and type
            ctx.globalAlpha = 1;
            ctx.fillStyle = "#ffffff";
            ctx.font = "14px system-ui";
            ctx.textAlign = "center";
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 2;
            ctx.strokeText(boss.type.toUpperCase(), boss.pos.x, boss.pos.y - boss.radius - 25);
            ctx.fillText(boss.type.toUpperCase(), boss.pos.x, boss.pos.y - boss.radius - 25);
            
            ctx.restore();
          }
        }

        // Boss minions
        if (state.bossMinions) {
          for (const minion of state.bossMinions) {
            ctx.save();
            
            // Minion body - smaller, darker
            ctx.fillStyle = "#4a148c";
            ctx.strokeStyle = "#7b1fa2";
            ctx.lineWidth = 2;
            ctx.shadowColor = "#7b1fa2";
            ctx.shadowBlur = 8;
            
            ctx.beginPath();
            ctx.arc(minion.pos.x, minion.pos.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Minion symbol
            ctx.fillStyle = "#ffffff";
            ctx.font = "12px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("üíÄ", minion.pos.x, minion.pos.y);
            
            ctx.restore();
          }
        }

        // Poison fields
        if (state.poisonFields) {
          for (const field of state.poisonFields) {
            ctx.save();

            // Poison field effect - pulsing green circle
            const time = Date.now() / 1000;
            const pulse = 0.7 + 0.3 * Math.sin(time * 3);
            
            ctx.globalAlpha = 0.4 * pulse;
            ctx.fillStyle = "#4caf50";
            ctx.shadowColor = "#4caf50";
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.arc(field.pos.x, field.pos.y, field.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Poison field border
            ctx.globalAlpha = 0.8;
            ctx.strokeStyle = "#8bc34a";
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.restore();
          }
        }

        if (state.elementalTrails) {
          const nowMs = Date.now();
          const palettes = {
            ignite: {
              inner: 'rgba(255, 183, 77, 0.65)',
              outer: 'rgba(255, 61, 0, 0.0)',
              ring: 'rgba(255, 204, 128, 0.95)',
              glow: 'rgba(255, 111, 0, 0.6)',
            },
            poison: {
              inner: 'rgba(165, 214, 167, 0.6)',
              outer: 'rgba(46, 125, 50, 0.0)',
              ring: 'rgba(129, 199, 132, 0.9)',
              glow: 'rgba(102, 187, 106, 0.55)',
            },
            shock: {
              inner: 'rgba(144, 202, 249, 0.6)',
              outer: 'rgba(30, 136, 229, 0.0)',
              ring: 'rgba(100, 181, 246, 0.9)',
              glow: 'rgba(3, 169, 244, 0.55)',
            },
          };

          for (const seg of state.elementalTrails) {
            const palette = palettes[seg.effect] || palettes.ignite;
            const createdAt = seg.createdAt || nowMs;
            const expiresAt = seg.expiresAt || nowMs;
            const total = Math.max(1, expiresAt - createdAt);
            const elapsed = Math.min(total, Math.max(0, nowMs - createdAt));
            const progress = Math.min(1, elapsed / total);
            const fade = Math.max(0.1, 1 - progress);
            const pulse = 0.6 + 0.4 * Math.sin(progress * Math.PI * 4);
            const baseRadius = seg.radius || 24;
            const renderRadius = baseRadius + pulse * 6;

            ctx.save();
            const gradient = ctx.createRadialGradient(seg.pos.x, seg.pos.y, baseRadius * 0.3, seg.pos.x, seg.pos.y, renderRadius);
            gradient.addColorStop(0, palette.inner);
            gradient.addColorStop(1, palette.outer);
            ctx.globalAlpha = 0.55 * fade;
            ctx.fillStyle = gradient;
            ctx.shadowColor = palette.glow;
            ctx.shadowBlur = 18 * fade;
            ctx.beginPath();
            ctx.arc(seg.pos.x, seg.pos.y, renderRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 0.9 * fade;
            ctx.strokeStyle = palette.ring;
            ctx.lineWidth = 2 + ((seg.stacks || 1) * 0.6);
            ctx.setLineDash([6, 10]);
            ctx.beginPath();
            ctx.arc(seg.pos.x, seg.pos.y, baseRadius + 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.restore();
          }
        }

        // Players
        ctx.font =
          "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.textAlign = "center";
        let me = state.players.find((p) => p.id === playerId);
        // Detect local melee edge and record for immediate visuals
        if (me) {
          if (input.melee && !prevMelee) {
            const aimWX_forMelee = camX + input.aimX / zoom;
            const aimWY_forMelee = camY + input.aimY / zoom;
            const dx = aimWX_forMelee - me.x,
              dy = aimWY_forMelee - me.y;
            const d = Math.hypot(dx, dy) || 1;
            localMeleeDirX = dx / d;
            localMeleeDirY = dy / d;
            localMeleeAt = performance.now();
          }
          prevMelee = input.melee;
        }
        // Update and draw dash trails (under players)
        const nowT = performance.now();
        if (state.players) {
          for (const p of state.players) {
            const sp = getSmoothedPos(p.id, p.x, p.y, 0); // position for trail sampling
            let arr = trails.get(p.id) || [];
            // Append when dashing
            if (p.dashing) {
              arr.push({ x: sp.x, y: sp.y, t: nowT });
              if (arr.length > TRAIL_MAX) arr.shift();
            }
            // Prune old
            arr = arr.filter((pt) => nowT - pt.t <= TRAIL_TTL);
            trails.set(p.id, arr);
            // Draw trail
            if (arr.length >= 2) {
              for (let i = 0; i < arr.length; i++) {
                const age = nowT - arr[i].t;
                const a = Math.max(0, 1 - age / TRAIL_TTL);
                const r = 6 + 10 * a;
                ctx.save();
                // teal-ish trail with soft glow
                ctx.globalAlpha = 0.25 + 0.45 * a;
                ctx.fillStyle = "rgba(158,241,209,1)";
                ctx.shadowColor = "rgba(158,241,209,.8)";
                ctx.shadowBlur = 14 * a;
                ctx.beginPath();
                ctx.arc(arr[i].x, arr[i].y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              }
            }
          }
        }

        for (const p of state.players) {
          const sp = getSmoothedPos(p.id, p.x, p.y, dt);
          ctx.save();
          if (p.role === "streamer" && p.alive === false) {
            ctx.restore();
            continue;
          }
          if (p.role === "streamer") {
            ctx.strokeStyle = "#4caf50";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 10, 0, Math.PI * 2);
            ctx.stroke();
            if (p.weaponed) {
              ctx.strokeStyle = "#ffa726";
              ctx.globalAlpha = 0.6;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 14, 0, Math.PI * 2);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }
            ctx.fillStyle = "#4caf50";
            ctx.globalAlpha = 0.95;
            ctx.fillText(p.name, sp.x, sp.y - 16);
          } else {
            ctx.fillStyle = p.alive ? "#ef5350" : "rgba(239,83,80,.25)";
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 12, 0, Math.PI * 2);
            ctx.fill();
            // Class outline
            if (p.zClass === "runner") {
              ctx.strokeStyle = "#64b5f6";
              ctx.lineWidth = 1.5;
            } else if (p.zClass === "brute") {
              ctx.strokeStyle = "#ffa726";
              ctx.lineWidth = 3;
            } else if (p.zClass === "spitter") {
              ctx.strokeStyle = "#ba68c8";
              ctx.lineWidth = 2;
            } else if (p.zClass === "stalker") {
              ctx.strokeStyle = "#9c27b0";
              ctx.lineWidth = 2;
            } else if (p.zClass === "bomber") {
              ctx.strokeStyle = "#f44336";
              ctx.lineWidth = 2.5;
            } else {
              ctx.strokeStyle = "#e57373";
              ctx.lineWidth = 1;
            }
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, p.zClass === "brute" ? 14 : 13, 0, Math.PI * 2);
            ctx.stroke();
            if (p.boosted) {
              ctx.strokeStyle = "#64b5f6";
              ctx.globalAlpha = 0.7;
              ctx.beginPath();
              ctx.arc(sp.x, sp.y, 16, 0, Math.PI * 2);
              ctx.stroke();
            }
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#e57373";
            ctx.fillText(p.name, sp.x, sp.y - 16);
            // Emote above zombie head for 5s
            if (p.emote && (p.emoteUntil || 0) > Date.now()) {
              ctx.font =
                "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
              ctx.globalAlpha = 1;
              ctx.fillText(p.emote, sp.x, sp.y - 32);
              ctx.font =
                "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
            }
          }
          // Bat swing arc visual (short-lived)
          const swingAge = (state.t || Date.now()) - (p.meleeAt || 0);
          if (swingAge >= 0 && swingAge < 220) {
            const alpha = 1 - swingAge / 220;
            const ang = Math.atan2(p.meleeDirY || 0, p.meleeDirX || 1);
            const span = Math.PI / 1.8; // ~100√Ç¬∞
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              sp.x + Math.cos(ang - span / 2) * r0,
              sp.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              sp.x + Math.cos(ang + span / 2) * r0,
              sp.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(sp.x, sp.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
          ctx.restore();
        }

        // Crosshair for local player (world coordinates)
        me = state.players.find((p) => p.id === playerId);
        if (me) {
          const aimWX = camX + input.aimX / zoom;
          const aimWY = camY + input.aimY / zoom;
          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,.5)";
          ctx.beginPath();
          ctx.arc(aimWX, aimWY, 6, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(aimWX - 8, aimWY);
          ctx.lineTo(aimWX + 8, aimWY);
          ctx.moveTo(aimWX, aimWY - 8);
          ctx.lineTo(aimWX, aimWY + 8);
          ctx.stroke();
          ctx.restore();
          // Muzzle flashes rendering
          for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
            const mf = muzzleFlashes[i];
            mf.ttl -= dt;
            if (mf.ttl <= 0) {
              muzzleFlashes.splice(i, 1);
              continue;
            }
            const a = Math.max(0, mf.ttl / 90);
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            ctx.globalAlpha = a;
            const g = ctx.createRadialGradient(mf.x, mf.y, 0, mf.x, mf.y, 18);
            g.addColorStop(0, "rgba(255,220,160,0.9)");
            g.addColorStop(1, "rgba(255,220,160,0)");
            ctx.fillStyle = g;
            ctx.fillRect(mf.x - 20, mf.y - 20, 40, 40);
            ctx.restore();
          }

          // Local predicted bat swing arc so streamer sees swing instantly
          const age = performance.now() - localMeleeAt;
          if (age >= 0 && age < 220) {
            const alpha = 1 - age / 220;
            const ang = Math.atan2(localMeleeDirY, localMeleeDirX);
            const span = Math.PI / 1.8; // ~100√Ç¬∞
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }

          // Also render server-synced swing for local player (fallback)
          const swingAgeSrv = (state.t || Date.now()) - (me.meleeAt || 0);
          if (swingAgeSrv >= 0 && swingAgeSrv < 220) {
            const alpha = 1 - swingAgeSrv / 220;
            const ang = Math.atan2(me.meleeDirY || 0, me.meleeDirX || 1);
            const span = Math.PI / 1.8;
            const r0 = 14,
              r1 = 34;
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha * 0.9);
            ctx.fillStyle = "rgba(255,213,79,0.35)";
            ctx.beginPath();
            ctx.moveTo(
              me.x + Math.cos(ang - span / 2) * r0,
              me.y + Math.sin(ang - span / 2) * r0
            );
            ctx.arc(me.x, me.y, r1, ang - span / 2, ang + span / 2);
            ctx.lineTo(
              me.x + Math.cos(ang + span / 2) * r0,
              me.y + Math.sin(ang + span / 2) * r0
            );
            ctx.arc(me.x, me.y, r0, ang + span / 2, ang - span / 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
        }

        // End world transform
        // Darkness/lighting overlay in world space
        drawLighting(camX, camY, rect.width / zoom, rect.height / zoom);
        ctx.restore();

        // Dash cooldown indicator (bottom-center) ‚Äî doubled size
        if (meHud) {
          const readyAt = meHud.dashReadyAt || 0;
          const lastAt = meHud.lastDashAt || 0;
          const nowMs = Date.now();
          const total = Math.max(1, readyAt - lastAt);
          const remain = Math.max(0, readyAt - nowMs);
          const frac = 1 - Math.min(1, remain / total);
          const meterPad = 24; // padding from bottom
          const r2 = 24; // doubled radius
          const cx2 = rect.width / 2;
          const cy2 = rect.height - meterPad - 52; // push up to fit bigger meter
          ctx.save();
          // backdrop behind the meter
          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(18,20,24,.86)";
          ctx.strokeStyle = "rgba(255,255,255,.08)";
          ctx.lineWidth = 2;
          roundRect(ctx, cx2 - 52, cy2 - 52, 104, 110, 28, true, true);
          // background circle
          ctx.beginPath();
          ctx.strokeStyle = "rgba(255,255,255,.18)";
          ctx.lineWidth = 6;
          ctx.arc(cx2, cy2, r2, 0, Math.PI * 2);
          ctx.stroke();
          // progress arc
          ctx.beginPath();
          ctx.strokeStyle = remain <= 0 ? "#2dd4bf" : "#90caf9";
          ctx.lineWidth = 7;
          ctx.arc(
            cx2,
            cy2,
            r2,
            -Math.PI / 2,
            -Math.PI / 2 + Math.PI * 2 * frac
          );
          ctx.stroke();
          // label below meter
          ctx.fillStyle = "#cfd8dc";
          ctx.font =
            "18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Dash", cx2, cy2 + 48);
          ctx.restore();
        }

        // Mini-map (bottom-right, circular)
        drawMiniMap();


        // Screen-space border overlay
        ctx.globalAlpha = 1;
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#808080";
        ctx.strokeRect(1, 1, rect.width - 2, rect.height - 2);
      }

      // small util for rounded rects on HUD
      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (typeof r === "number") r = { tl: r, tr: r, br: r, bl: r };
        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        ctx.quadraticCurveTo(x, y, x + r.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      function drawMiniMap() {
        const rect = c.getBoundingClientRect();
        const mmSize = 160;
        const pad = 12;
        const cx = rect.width - pad - mmSize / 2;
        const cy = rect.height - pad - mmSize / 2;
        const R = mmSize / 2 - 4;
        const W = (state.arena && state.arena.w) || 960;
        const H = (state.arena && state.arena.h) || 540;
        // Zoom in a bit and center around the local player if available
        const meMM =
          state.players && state.players.find((p) => p.id === playerId);
        const centerX = meMM ? meMM.x : W / 2;
        const centerY = meMM ? meMM.y : H / 2;
        const MM_ZOOM = 1.6; // >1 zooms in
        const scale = (2 * R * MM_ZOOM) / Math.max(W, H);
        // frame
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(18,20,24,.86)";
        ctx.beginPath();
        ctx.arc(cx, cy, mmSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.08)";
        ctx.lineWidth = 2;
        ctx.stroke();
        // clip to circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, Math.PI * 2);
        ctx.clip();
        // walls
        if (state.walls) {
          ctx.strokeStyle = "rgba(255,255,255,.25)";
          ctx.lineWidth = 1;
          for (const w of state.walls) {
            const x = cx + (w.x - centerX) * scale;
            const y = cy + (w.y - centerY) * scale;
            const ww = w.w * scale;
            const hh = w.h * scale;
            ctx.strokeRect(x, y, ww, hh);
          }
        }
        // extractions removed
        // players
        if (state.players) {
          for (const p of state.players) {
            const px = cx + (p.x - centerX) * scale;
            const py = cy + (p.y - centerY) * scale;
            const r = p.role === "streamer" ? 3 : 2;
            ctx.beginPath();
            ctx.fillStyle =
              p.role === "streamer"
                ? "#4caf50"
                : p.alive
                ? "#ef5350"
                : "rgba(239,83,80,.4)";
            ctx.arc(px, py, r, 0, Math.PI * 2);
            ctx.fill();
            if (p.id === playerId) {
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        
        // AI zombies on minimap
        if (state.aiZombies) {
          for (const zombie of state.aiZombies) {
            const px = cx + (zombie.x - centerX) * scale;
            const py = cy + (zombie.y - centerY) * scale;
            ctx.beginPath();
            ctx.fillStyle = zombie.state === "chasing" ? "#ff5722" : zombie.state === "attacking" ? "#d32f2f" : "#ef5350";
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Small state indicator
            if (zombie.state === "chasing" || zombie.state === "attacking") {
              ctx.strokeStyle = zombie.state === "attacking" ? "#d32f2f" : "#ff5722";
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        
        // Bosses on minimap
        if (state.bosses) {
          for (const boss of state.bosses) {
            const px = cx + (boss.pos.x - centerX) * scale;
            const py = cy + (boss.pos.y - centerY) * scale;
            const visual = boss.visual || {};
            
            ctx.save();
            
            // Boss icon - larger and more prominent
            ctx.fillStyle = visual.color || "#8B0000";
            ctx.strokeStyle = visual.glowColor || "#ff0000";
            ctx.lineWidth = 2;
            ctx.shadowColor = visual.glowColor || "#ff0000";
            ctx.shadowBlur = 4;
            
            // Pulsing effect for bosses
            const time = Date.now() / 1000;
            const pulse = 0.8 + 0.2 * Math.sin(time * 2);
            const radius = 4 * pulse;
            
            ctx.beginPath();
            ctx.arc(px, py, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Boss symbol on minimap
            ctx.fillStyle = "#ffffff";
            ctx.font = "8px system-ui";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(visual.minimapIcon || "üíÄ", px, py);
            
            // Enrage indicator
            if (boss.enraged) {
              ctx.strokeStyle = "#ff4444";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(px, py, radius + 2, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            ctx.restore();
          }
        }
        ctx.restore(); // unclip
        ctx.restore();
      }

      function drawTiles(viewX, viewY, viewW, viewH) {
        const m = gameMap;
        if (!m) return;
        const sz = m.size;
        const theme = m.theme || "dungeon";
        const pal =
          theme === "dungeon"
            ? {
                floor: "#0e1115",
                wall: "#2a2f36",
                pit: "#0b0d11",
                water: "#0d1b2a",
                edge: "#9aa4b2",
                propCrate: "#6d4c41",
                propPillar: "#b0bec5",
                propBone: "#8d6e63",
              }
            : theme === "cave"
            ? {
                floor: "#0d1113",
                wall: "#263238",
                pit: "#0a0e10",
                water: "#0b1f2d",
                edge: "#90a4ae",
                propCrate: "#546e7a",
                propPillar: "#90caf9",
                propBone: "#80cbc4",
              }
            : {
                floor: "#111416",
                wall: "#3c4148",
                pit: "#0b0c0d",
                water: "#14212e",
                edge: "#b0bec5",
                propCrate: "#90a4ae",
                propPillar: "#cfd8dc",
                propBone: "#b0bec5",
              };
        const sx = Math.max(0, Math.floor(viewX / sz) - 1),
          sy = Math.max(0, Math.floor(viewY / sz) - 1);
        const ex = Math.min(m.w - 1, Math.ceil((viewX + viewW) / sz) + 1),
          ey = Math.min(m.h - 1, Math.ceil((viewY + viewH) / sz) + 1);
        // Floor
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 0) {
              // floor
              ctx.fillStyle = pal.floor;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Pits/Water
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            const id = m.tiles[y * m.w + x];
            if (id === 2) {
              ctx.fillStyle = pal.pit;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
            if (id === 3) {
              ctx.fillStyle = pal.water;
              ctx.fillRect(x * sz, y * sz, sz, sz);
            }
          }
        }
        // Walls autotile outline
        const isWall = (ix, iy) =>
          ix >= 0 &&
          iy >= 0 &&
          ix < m.w &&
          iy < m.h &&
          m.tiles[iy * m.w + ix] === 1;
        ctx.fillStyle = pal.wall;
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            if (!isWall(x, y)) continue;
            const px = x * sz,
              py = y * sz;
            ctx.fillRect(px, py, sz, sz);
            ctx.strokeStyle = pal.edge;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.15;
            if (!isWall(x, y - 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px + sz, py);
              ctx.stroke();
            }
            if (!isWall(x + 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px + sz, py);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x, y + 1)) {
              ctx.beginPath();
              ctx.moveTo(px, py + sz);
              ctx.lineTo(px + sz, py + sz);
              ctx.stroke();
            }
            if (!isWall(x - 1, y)) {
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px, py + sz);
              ctx.stroke();
            }
            ctx.globalAlpha = 1;
          }
        }
        // Props
        for (const p of m.props || []) {
          const px = p.x * sz,
            py = p.y * sz;
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle =
            p.type === "crate"
              ? pal.propCrate
              : p.type === "pillar"
              ? pal.propPillar
              : pal.propBone;
          ctx.fillRect(px + 4, py + 4, sz - 8, sz - 8);
          ctx.restore();
        }
        // Lights (simple ambient blit)
        for (const l of m.lights || []) {
          const cx = l.x * sz + sz / 2,
            cy = l.y * sz + sz / 2;
          const rr = l.r * sz;
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rr);
          g.addColorStop(0, `rgba(255,255,200,${0.35 * l.a})`);
          g.addColorStop(1, "rgba(255,255,200,0)");
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = g;
          ctx.fillRect(cx - rr, cy - rr, rr * 2, rr * 2);
          ctx.restore();
        }
      }
        ctx.restore();
      
        
        ctx.restore();
      
      function drawLighting(viewX, viewY, viewW, viewH) {
        // Lighting system temporarily disabled to remove dots
        return;
      }

      function updatePlayerList(players) {
        playersEl.innerHTML = players
          .map(
            (p) =>
              `<span class="pill ${p.role}">${
                p.role === "streamer" ? "üü¢" : "üßü"
              } ${p.name}${p.role === "streamer" ? " ¬∑ " + p.score : ""}</span>`
          )
          .join(" ");
      }

      function flash() {
        flashEl.classList.add("show");
        setTimeout(() => flashEl.classList.remove("show"), 150);
      }

      function updateCountdownOverlay(seconds) {
        if (!countdownOverlay || !countdownText) return;
        const normalized = Math.max(0, Math.floor(Number.isFinite(seconds) ? seconds : 0));
        if (normalized === lastCountdownDisplayed && (normalized > 0 || countdownHideTimeout)) return;
        if (countdownHideTimeout) {
          clearTimeout(countdownHideTimeout);
          countdownHideTimeout = null;
        }
        if (normalized > 0) {
          countdownOverlay.classList.remove('hidden');
          countdownText.textContent = String(normalized);
          countdownActive = true;
          lastCountdownDisplayed = normalized;
        } else {
          countdownOverlay.classList.remove('hidden');
          countdownText.textContent = 'GO!';
          countdownActive = false;
          lastCountdownDisplayed = 0;
          countdownHideTimeout = setTimeout(() => {
            if (!countdownOverlay || !countdownText) return;
            countdownOverlay.classList.add('hidden');
            countdownText.textContent = '';
            lastCountdownDisplayed = null;
          }, 700);
        }
      }

      function hideCountdownOverlay() {
        if (!countdownOverlay || !countdownText) return;
        if (countdownHideTimeout) {
          clearTimeout(countdownHideTimeout);
          countdownHideTimeout = null;
        }
        countdownOverlay.classList.add('hidden');
        countdownText.textContent = '';
        countdownActive = false;
        lastCountdownDisplayed = null;
      }

      function updateTimer(seconds) {
        if (!roundActive) {
          timerEl.textContent = 'Time: --';
          return;
        }
        const min = Math.floor(seconds / 60);
        const sec = seconds % 60;
        timerEl.textContent = `Time: ${min}:${sec.toString().padStart(2, "0")}`;
      }

      // Animation loop for effects and smoother visuals
      let last = performance.now();
      const fpsSamples = [];
      const fpsWindow = 120; // ~2s at 60fps
      let lastNerdUpdate = 0;
      lastHp = 100;
      function loop() {
        const now = performance.now();
        const dt = now - last;
        last = now;
        draw(dt);
        if (swapPromptEl) {
          if (swapPromptState) {
            const ammoText = typeof swapPromptState.ammo === 'number' ? ` (${swapPromptState.ammo} ammo)` : '';
            swapPromptEl.textContent = `Press F to equip ${swapPromptState.weapon.toUpperCase()}${ammoText}`;
            swapPromptEl.classList.add('show');
          } else {
            swapPromptEl.classList.remove('show');
          }
        }
        // FPS tracking
        const fps = dt > 0 ? 1000 / dt : 0;
        fpsSamples.push(fps);
        if (fpsSamples.length > fpsWindow) fpsSamples.shift();
        // State messages per second
        if (now - lastStateRateAt >= 1000) {
          statesPerSec = stateMsgCount;
          stateMsgCount = 0;
          lastStateRateAt = now;
        }
        // Update nerd overlay at ~4Hz
        if (nerdOn && now - lastNerdUpdate > 250) {
          const avgFps = fpsSamples.length
            ? fpsSamples.reduce((a, b) => a + b, 0) / fpsSamples.length
            : 0;
          const minFps = fpsSamples.length ? Math.min(...fpsSamples) : 0;
          const maxFps = fpsSamples.length ? Math.max(...fpsSamples) : 0;
          const lat = latency
            ? latency.getLatencyStats()
            : { avg: 0, min: 0, max: 0, jitter: 0 };
          const players = state.players?.length || 0;
          const zombies =
            state.players?.filter((p) => p.role === "zombie").length || 0;
          const bullets = state.bullets?.length || 0;
          const pickups = state.pickups?.length || 0;
          const walls = state.walls?.length || 0;
          const wsBuf = (ws && ws.bufferedAmount) || 0;
          nerdPanel.innerHTML = `
          <div><strong>Nerd Stats</strong></div>
          <div>FPS: ${avgFps.toFixed(1)} (min ${minFps.toFixed(
            0
          )} max ${maxFps.toFixed(0)})</div>
          <div>Latency: ${lat.avg.toFixed(1)} ms (min ${lat.min.toFixed(
            0
          )} max ${lat.max.toFixed(0)}) jitter ${lat.jitter.toFixed(1)} ms</div>
          <div>States/s: ${statesPerSec.toFixed(0)}</div>
          <div>Entities: players ${players} (z ${zombies}) bullets ${bullets} pickups ${pickups} walls ${walls}</div>
          <div>WS buf: ${wsBuf}</div>
        `;
          lastNerdUpdate = now;
        }
        
        // Handle canvas resize for weapon drop positioning
        const resizeObserver = new ResizeObserver(() => {
          setTimeout(renderWeaponDropSprites, 50);
        });
        if (document.querySelector('canvas.arena')) {
          resizeObserver.observe(document.querySelector('canvas.arena'));
        }
                renderWeaponDropSprites();
        requestAnimationFrame(loop);
      }
      
      // Weapon drop sprite rendering
      function renderWeaponDropSprites() {
        if (!state || !state.weaponDrops) return;
        
        // Clear existing weapon drop sprites
        document.querySelectorAll('.world-weapon-drop').forEach(el => el.remove());
        
        const gameContainer = document.querySelector('.stage') || document.body;
        
        state.weaponDrops.forEach(drop => {
          const spriteEl = document.createElement('div');
          spriteEl.className = 'weapon-sprite world-weapon-drop weapon-' + (drop.weapon || 'pistol');
          spriteEl.style.position = 'absolute';
          spriteEl.style.left = (drop.x - 24) + 'px';
          spriteEl.style.top = (drop.y - 12) + 'px';
          spriteEl.style.zIndex = '10';
          spriteEl.style.pointerEvents = 'none';
          spriteEl.style.filter = 'drop-shadow(0 0 12px #ffd700) drop-shadow(0 0 6px #ffaa00) brightness(1.2)';
          
          gameContainer.appendChild(spriteEl);
        });
      }
            loop();

      // Fullscreen toggle
      document.getElementById("fullscreen").onclick = async () => {
        if (!document.fullscreenElement) {
          await document.documentElement.requestFullscreen().catch(() => {});
        } else {
          await document.exitFullscreen().catch(() => {});
        }
      };

      newBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (ws && ws.readyState === 1) {
          leaveRoom(true);
        } else {
          boot();
        }
      };
      copyBtn.onclick = (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        if (!copyBtn.disabled && link.value) {
          navigator.clipboard.writeText(link.value);
          toast("Join link copied");
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy Link"), 800);
        }
      };

      testingModeBtn.onclick = async (ev) => {
        if (ev && ev.currentTarget && ev.currentTarget.blur)
          ev.currentTarget.blur();
        
        console.log('Testing Mode button clicked');
        
        // Force show the upgrade panel for testing
        console.log('Forcing upgrade panel to show...');
        updateTestingMode('testing');
        
        try {
          // Send request to enable testing mode
          const response = await fetch(`/api/rooms/${roomId}/setup`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              overrides: { gameMode: 'testing' } 
            })
          });
          
          if (response.ok) {
            toast("Testing mode enabled! Restart the round to see test overlaps.");
            testingModeBtn.textContent = "Testing Mode ‚úì";
            testingModeBtn.disabled = true;
          } else {
            toast("Failed to enable testing mode");
          }
        } catch (error) {
          console.error('Error enabling testing mode:', error);
          toast("Error enabling testing mode");
        }
      };

      // Death screen button event listeners
      if (restartRaidBtn) {
        restartRaidBtn.addEventListener("click", restartRaid);
      }
      
      if (exitToMenuBtn) {
        exitToMenuBtn.addEventListener("click", exitToMenu);
      }

    </script>
  </body>
</html>









